{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Understanding Projectile Motion Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyzing how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework. The Mathematics Behind Projectile Motion The equations governing projectile motion involve both linear and quadratic relationships, making them accessible yet deeply insightful. The motion can be broken down into two independent components: Horizontal Motion: Governed by uniform velocity, assuming no air resistance. Vertical Motion: Influenced by gravitational acceleration, leading to a parabolic trajectory. Key Equations Time of Flight: $$ T = \\frac{2v_0 \\sin \\theta}{g} $$ Horizontal Range: $$ R = \\frac{v_0^2 \\sin 2\\theta}{g} $$ Maximum Height: $$ H = \\frac{v_0^2 \\sin^2 \\theta}{2g} $$ Where: \\( v_0 \\) = Initial velocity \\( \\theta \\) = Angle of projection \\( g \\) = Gravitational acceleration The Role of Free Parameters What makes this topic particularly compelling is the number of free parameters involved in these equations, such as: Initial Velocity: Determines the overall reach of the projectile. Gravitational Acceleration: Affects the downward pull, varying across planetary conditions. Launch Height: Alters the time of flight and final impact position. Real-World Applications These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, including: The arc of a soccer ball during a free kick. The flight path of a basketball shot. The trajectory of a rocket launched into space. Understanding projectile motion is not just an academic exercise but a crucial principle in engineering, sports science, and aerospace technology. Equations of Motion The motion of a projectile in a vacuum (neglecting air resistance) is governed by: \\[ x(t) = v_0 \\cos(\\theta) t \\] \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] where: v 0 is the initial velocity, \\(\\theta\\) is the launch angle, \\(g\\) is the acceleration due to gravity, \\(t\\) is the time. The range \\(R\\) (horizontal distance) is obtained by solving for \\(t\\) when \\(y = 0\\) : \\(R = \\frac{v_0^2 \\sin(2\\theta)}{g}\\) Family of Solutions Different initial velocities \\( v_0 \\) yield higher or lower trajectories. Varying launch angles \\( \\theta \\) create different parabolic paths\u2014steeper angles mean greater height but shorter horizontal reach. Gravity ( \\( g \\) ) affects descent\u2014on planets like Mars: \\[ g = 3.7 \\, \\text{m/s}^2 \\] Due to the lower gravitational acceleration compared to Earth ( \\( g \\approx 9.81 \\) m/s\u00b2), a projectile on Mars would travel a longer range and stay in the air for a greater duration. Graphical Representations of Range vs. Angle The range equation (neglecting air resistance) is: \\[ [ R = \\frac{v_0^2 \\sin 2\\theta}{g} ] \\] Python Code to Plot Range vs. Angle import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 30 # Initial velocity in m/s g = 9.81 # Gravitational acceleration in m/s\u00b2 theta = np.linspace(0, 90, 100) # Angle from 0\u00b0 to 90\u00b0 # Compute range for each angle R = (v0**2 * np.sin(np.radians(2 * theta))) / g # Plot plt.figure(figsize=(8,6)) plt.plot(theta, R, label=\"Projectile Range vs. Angle\") plt.axvline(x=45, color='r', linestyle='--', label=\"Max Range at 45\u00b0\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.title(\"Projectile Range vs. Launch Angle\") plt.legend() plt.grid() plt.show() \ud83d\udccc This graph will: Show range peaking at 45\u00b0 (ideal case). Demonstrate how increasing \\( v_0 \\) scales up range. Shift if gravity ( g ) is altered (e.g., Moon vs. Earth). Limitations of the Idealized Projectile Motion Model While the standard projectile motion equations provide valuable insights, they rely on idealized assumptions that may not hold in real-world scenarios. In practical applications, factors such as air resistance, wind, and varying gravitational forces play a significant role. Limitations of the Idealized Model The basic equations assume: No Air Resistance \u2013 In reality, air resistance slows down projectiles, reducing range and altering trajectory. Uniform Gravity \u2013 Gravity may vary slightly with altitude and location. No Wind Effects \u2013 Wind can introduce lateral forces, influencing the flight path. Instantaneous Launch and Impact \u2013 Real launches involve acceleration phases, and impacts may cause rebounds or deformation. Incorporating Realistic Factors To improve accuracy, we can modify the model by including: Drag Force ( \\( F_d \\) ) Modeled using \\( F_d = \\frac{1}{2} C_d \\rho A v^2 \\) , where: \\( C_d \\) = Drag coefficient \\( \\rho \\) = Air density \\( A \\) = Cross-sectional area \\( v \\) = Velocity Wind Influence Wind velocity adds or subtracts from projectile velocity, affecting trajectory. Crosswinds introduce lateral displacement. Variable Gravity For long-range trajectories, gravity variation can be modeled using altitude-based corrections. Applications of Improved Models These refined equations have significant impact in: Ballistics and Military Applications \u2013 Accounting for air resistance in projectile weapons. Sports Science \u2013 Improving predictions for ball trajectories in soccer, baseball, and golf. Aerospace Engineering \u2013 Modeling atmospheric descent for spacecraft and satellites.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#understanding-projectile-motion","text":"Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyzing how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework.","title":"Understanding Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#the-mathematics-behind-projectile-motion","text":"The equations governing projectile motion involve both linear and quadratic relationships, making them accessible yet deeply insightful. The motion can be broken down into two independent components: Horizontal Motion: Governed by uniform velocity, assuming no air resistance. Vertical Motion: Influenced by gravitational acceleration, leading to a parabolic trajectory.","title":"The Mathematics Behind Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-equations","text":"Time of Flight: $$ T = \\frac{2v_0 \\sin \\theta}{g} $$ Horizontal Range: $$ R = \\frac{v_0^2 \\sin 2\\theta}{g} $$ Maximum Height: $$ H = \\frac{v_0^2 \\sin^2 \\theta}{2g} $$ Where: \\( v_0 \\) = Initial velocity \\( \\theta \\) = Angle of projection \\( g \\) = Gravitational acceleration","title":"Key Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#the-role-of-free-parameters","text":"What makes this topic particularly compelling is the number of free parameters involved in these equations, such as: Initial Velocity: Determines the overall reach of the projectile. Gravitational Acceleration: Affects the downward pull, varying across planetary conditions. Launch Height: Alters the time of flight and final impact position.","title":"The Role of Free Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#real-world-applications","text":"These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, including: The arc of a soccer ball during a free kick. The flight path of a basketball shot. The trajectory of a rocket launched into space. Understanding projectile motion is not just an academic exercise but a crucial principle in engineering, sports science, and aerospace technology.","title":"Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion","text":"The motion of a projectile in a vacuum (neglecting air resistance) is governed by: \\[ x(t) = v_0 \\cos(\\theta) t \\] \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] where: v 0 is the initial velocity, \\(\\theta\\) is the launch angle, \\(g\\) is the acceleration due to gravity, \\(t\\) is the time. The range \\(R\\) (horizontal distance) is obtained by solving for \\(t\\) when \\(y = 0\\) : \\(R = \\frac{v_0^2 \\sin(2\\theta)}{g}\\)","title":"Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"Different initial velocities \\( v_0 \\) yield higher or lower trajectories. Varying launch angles \\( \\theta \\) create different parabolic paths\u2014steeper angles mean greater height but shorter horizontal reach. Gravity ( \\( g \\) ) affects descent\u2014on planets like Mars: \\[ g = 3.7 \\, \\text{m/s}^2 \\] Due to the lower gravitational acceleration compared to Earth ( \\( g \\approx 9.81 \\) m/s\u00b2), a projectile on Mars would travel a longer range and stay in the air for a greater duration. Graphical Representations of Range vs. Angle The range equation (neglecting air resistance) is: \\[ [ R = \\frac{v_0^2 \\sin 2\\theta}{g} ] \\] Python Code to Plot Range vs. Angle import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 30 # Initial velocity in m/s g = 9.81 # Gravitational acceleration in m/s\u00b2 theta = np.linspace(0, 90, 100) # Angle from 0\u00b0 to 90\u00b0 # Compute range for each angle R = (v0**2 * np.sin(np.radians(2 * theta))) / g # Plot plt.figure(figsize=(8,6)) plt.plot(theta, R, label=\"Projectile Range vs. Angle\") plt.axvline(x=45, color='r', linestyle='--', label=\"Max Range at 45\u00b0\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.title(\"Projectile Range vs. Launch Angle\") plt.legend() plt.grid() plt.show() \ud83d\udccc This graph will: Show range peaking at 45\u00b0 (ideal case). Demonstrate how increasing \\( v_0 \\) scales up range. Shift if gravity ( g ) is altered (e.g., Moon vs. Earth).","title":"Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations-of-the-idealized-projectile-motion-model","text":"While the standard projectile motion equations provide valuable insights, they rely on idealized assumptions that may not hold in real-world scenarios. In practical applications, factors such as air resistance, wind, and varying gravitational forces play a significant role.","title":"Limitations of the Idealized Projectile Motion Model"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations-of-the-idealized-model","text":"The basic equations assume: No Air Resistance \u2013 In reality, air resistance slows down projectiles, reducing range and altering trajectory. Uniform Gravity \u2013 Gravity may vary slightly with altitude and location. No Wind Effects \u2013 Wind can introduce lateral forces, influencing the flight path. Instantaneous Launch and Impact \u2013 Real launches involve acceleration phases, and impacts may cause rebounds or deformation.","title":"Limitations of the Idealized Model"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#incorporating-realistic-factors","text":"To improve accuracy, we can modify the model by including: Drag Force ( \\( F_d \\) ) Modeled using \\( F_d = \\frac{1}{2} C_d \\rho A v^2 \\) , where: \\( C_d \\) = Drag coefficient \\( \\rho \\) = Air density \\( A \\) = Cross-sectional area \\( v \\) = Velocity Wind Influence Wind velocity adds or subtracts from projectile velocity, affecting trajectory. Crosswinds introduce lateral displacement. Variable Gravity For long-range trajectories, gravity variation can be modeled using altitude-based corrections.","title":"Incorporating Realistic Factors"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#applications-of-improved-models","text":"These refined equations have significant impact in: Ballistics and Military Applications \u2013 Accounting for air resistance in projectile weapons. Sports Science \u2013 Improving predictions for ball trajectories in soccer, baseball, and golf. Aerospace Engineering \u2013 Modeling atmospheric descent for spacecraft and satellites.","title":"Applications of Improved Models"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a captivating example of a physical system with intricate behavior resulting from the interplay of damping, restoring forces, and external driving forces. By introducing both damping and external periodic forcing, the system demonstrates a transition from simple harmonic motion to a rich spectrum of dynamics, including resonance, chaos, and quasiperiodic behavior. These phenomena serve as a foundation for understanding complex real-world systems, such as driven oscillators, climate systems, and mechanical structures under periodic stress. Adding forcing introduces new parameters, such as the amplitude and frequency of the external force, which significantly affect the pendulum's behavior. By systematically varying these parameters, a diverse class of solutions can be observed, including synchronized oscillations, chaotic motion, and resonance phenomena. These behaviors not only highlight fundamental physics principles but also provide insights into engineering applications such as energy harvesting, vibration isolation, and mechanical resonance. Theoretical Foundation The motion of a forced damped pendulum is described by the following second-order differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\Omega t) \\] Where: \\(\\theta(t)\\) is the angular displacement of the pendulum, \\(\\gamma\\) is the damping coefficient, \\(\\omega_0\\) is the natural frequency of the undamped pendulum, \\(A\\) is the driving amplitude, \\(\\Omega\\) is the driving frequency. Small-Angle Approximation (Linearization) For small oscillations, we can make the small-angle approximation, where \\(\\sin(\\theta) \\approx \\theta\\) (assuming \\(\\theta\\) is in radians and small): \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\Omega t) \\] This is a linear second-order ordinary differential equation for a driven damped harmonic oscillator. The solution of this equation depends on the relative values of the damping coefficient, the driving frequency, and the natural frequency of the pendulum. Resonance Conditions Resonance occurs when the driving frequency \\(\\Omega\\) matches the natural frequency \\(\\omega_0\\) of the pendulum. Under these conditions, even small driving forces can lead to large oscillations because the system efficiently absorbs energy from the external force. To explore resonance more concretely, we can examine the solution to the differential equation in the form of: \\[ \\theta(t) = \\theta_0 e^{-\\gamma t} \\cos(\\omega t - \\delta) \\] Where \\(\\omega\\) is the effective frequency of the system, and \\(\\delta\\) is a phase shift. The amplitude \\(A\\) of the oscillations will depend on the driving force, the damping coefficient, and the detuning between the driving frequency and the natural frequency of the system. The resonance condition is when \\(\\Omega \\approx \\omega_0\\) , and the amplitude increases dramatically when \\(\\Omega\\) is close to \\(\\omega_0\\) . In summary, resonance causes the system to oscillate with large amplitude at the driving frequency, and it leads to high energy absorption. Analysis of Dynamics Effect of the Damping Coefficient ( \\(\\gamma\\) ) The damping coefficient determines how quickly the energy in the system is dissipated. In the forced damped pendulum, damping: Low damping : Allows for large amplitude oscillations and may contribute to a sharp resonance peak. High damping : Reduces the amplitude of oscillations, and if sufficiently high, the system may not oscillate at all. This may suppress chaotic behavior and lead to a smooth, decaying response. Critical damping : Occurs when \\(\\gamma = 2\\sqrt{mK}\\) , where the pendulum returns to equilibrium as quickly as possible without oscillating. Effect of the Driving Amplitude ( \\(A\\) ) The driving amplitude influences how much energy is being transferred to the pendulum. As \\(A\\) increases: At low \\(A\\) , the system may undergo regular oscillations. As \\(A\\) increases, periodic motion may switch to quasiperiodic or even chaotic motion. This transition happens due to nonlinear interactions between the driving force and the pendulum's motion. Effect of the Driving Frequency ( \\(\\Omega\\) ) The driving frequency affects how the system absorbs energy from the driving force. When \\(\\Omega\\) is near \\(\\omega_0\\) , resonance occurs and the system can absorb large amounts of energy, leading to large amplitude oscillations. If \\(\\Omega\\) is far from \\(\\omega_0\\) , the system is less likely to enter resonance, and the oscillations are typically smaller. Regular vs. Chaotic Motion As we vary \\(A\\) , \\(\\gamma\\) , and \\(\\Omega\\) , the pendulum's motion can transition from periodic to chaotic: Periodic motion : The pendulum oscillates in a stable, repeating manner. Quasiperiodic motion : The system oscillates in a non-repeating but predictable manner. Chaotic motion : Small changes in initial conditions lead to unpredictable motion, and the system exhibits sensitive dependence on initial conditions. Chaos can emerge if the system is driven at certain amplitudes and frequencies, especially when nonlinearity and resonance effects combine. Practical Applications The forced damped pendulum model has various practical applications across multiple domains, particularly in systems subjected to periodic forces. Energy Harvesting Devices The forced damped pendulum model can be used to design energy harvesting devices, where oscillations induced by external forces (such as vibrations from machinery or ambient energy) are converted into electrical energy. By tuning the system to resonate at the frequency of the external force, large amounts of energy can be harvested. Suspension Bridges Suspension bridges, especially those with long spans, are susceptible to oscillations caused by wind or other external periodic forces. The dynamics of the bridge under these forces can be modeled by a forced damped pendulum, where the damping (structural damping) and driving forces (wind or traffic-induced forces) must be carefully balanced to avoid resonance, which could lead to catastrophic failure. Oscillating Circuits In electrical engineering, forced damped oscillators are used to model circuits with resistors, capacitors, and inductors driven by an external alternating current (AC). The resonance condition plays a critical role in the design of tuned circuits for radios, televisions, and other wireless communication technologies. Implementation To simulate the motion of a forced damped pendulum computationally, we can solve the equation numerically for various values of the damping coefficient, driving force, and initial conditions. Here\u2019s a general outline of the steps to simulate the system: Numerical Solution of the Differential Equation : Use a method like the Euler method or Runge-Kutta method to solve the second-order differential equation numerically. Phase Diagrams and Poincar\u00e9 Sections : These can be used to visualize the dynamics. In a phase diagram, the state of the system is plotted in terms of position vs. velocity, showing how the system evolves over time. Poincar\u00e9 sections can capture the transitions between periodic, quasiperiodic, and chaotic regimes by plotting intersections of the system's trajectory with a plane of constant time. Visualization : We can plot time series, phase space trajectories, and bifurcation diagrams to analyze how the system behaves under different conditions. Computational Model Example Here's a basic framework for simulating the system: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants gamma = 0.2 # damping coefficient omega_0 = 1.0 # natural frequency A = 1.0 # driving amplitude Omega = 1.0 # driving frequency # Define the differential equation def forced_pendulum(t, y): theta, theta_dot = y dtheta_dt = theta_dot dtheta_dot_dt = -gamma * theta_dot - omega_0**2 * np.sin(theta) + A * np.cos(Omega * t) return [dtheta_dt, dtheta_dot_dt] # Initial conditions y0 = [0.5, 0] # Initial angle and velocity # Time span t_span = (0, 50) t_eval = np.linspace(0, 50, 1000) # Solve the differential equation solution = solve_ivp(forced_pendulum, t_span, y0, t_eval=t_eval) # Plotting the time series and phase diagram plt.figure(figsize=(10, 5)) # Time series plot plt.subplot(1, 2, 1) plt.plot(solution.t, solution.y[0]) plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Time Series of the Forced Damped Pendulum') # Phase diagram plot plt.subplot(1, 2, 2) plt.plot(solution.y[0], solution.y[1]) plt.xlabel('Angle (rad)') plt.ylabel('Velocity (rad/s)') plt.title('Phase Diagram') plt.tight_layout() plt.show() In the above simulation: - We use solve_ivp to numerically solve the second-order differential equation. - The results are visualized both in time series and phase space. To observe transitions to chaos, varying parameters like \\(A\\) , \\(\\gamma\\) , and \\(\\Omega\\) will result in different types of motion, which can be analyzed through phase space diagrams and Poincar\u00e9 sections. Conclusion The forced damped pendulum is a rich system that demonstrates complex dynamics such as resonance, chaos, and quasiperiodic behavior, depending on the damping coefficient, driving amplitude, and frequency. These phenomena have broad applications in real-world systems like energy harvesting, structural engineering, and electronics. Through computational modeling, we can better understand how changes in system parameters influence behavior and predict transitions between regular and chaotic motion.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a captivating example of a physical system with intricate behavior resulting from the interplay of damping, restoring forces, and external driving forces. By introducing both damping and external periodic forcing, the system demonstrates a transition from simple harmonic motion to a rich spectrum of dynamics, including resonance, chaos, and quasiperiodic behavior. These phenomena serve as a foundation for understanding complex real-world systems, such as driven oscillators, climate systems, and mechanical structures under periodic stress. Adding forcing introduces new parameters, such as the amplitude and frequency of the external force, which significantly affect the pendulum's behavior. By systematically varying these parameters, a diverse class of solutions can be observed, including synchronized oscillations, chaotic motion, and resonance phenomena. These behaviors not only highlight fundamental physics principles but also provide insights into engineering applications such as energy harvesting, vibration isolation, and mechanical resonance.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#theoretical-foundation","text":"The motion of a forced damped pendulum is described by the following second-order differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\Omega t) \\] Where: \\(\\theta(t)\\) is the angular displacement of the pendulum, \\(\\gamma\\) is the damping coefficient, \\(\\omega_0\\) is the natural frequency of the undamped pendulum, \\(A\\) is the driving amplitude, \\(\\Omega\\) is the driving frequency.","title":"Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation-linearization","text":"For small oscillations, we can make the small-angle approximation, where \\(\\sin(\\theta) \\approx \\theta\\) (assuming \\(\\theta\\) is in radians and small): \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\Omega t) \\] This is a linear second-order ordinary differential equation for a driven damped harmonic oscillator. The solution of this equation depends on the relative values of the damping coefficient, the driving frequency, and the natural frequency of the pendulum.","title":"Small-Angle Approximation (Linearization)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions","text":"Resonance occurs when the driving frequency \\(\\Omega\\) matches the natural frequency \\(\\omega_0\\) of the pendulum. Under these conditions, even small driving forces can lead to large oscillations because the system efficiently absorbs energy from the external force. To explore resonance more concretely, we can examine the solution to the differential equation in the form of: \\[ \\theta(t) = \\theta_0 e^{-\\gamma t} \\cos(\\omega t - \\delta) \\] Where \\(\\omega\\) is the effective frequency of the system, and \\(\\delta\\) is a phase shift. The amplitude \\(A\\) of the oscillations will depend on the driving force, the damping coefficient, and the detuning between the driving frequency and the natural frequency of the system. The resonance condition is when \\(\\Omega \\approx \\omega_0\\) , and the amplitude increases dramatically when \\(\\Omega\\) is close to \\(\\omega_0\\) . In summary, resonance causes the system to oscillate with large amplitude at the driving frequency, and it leads to high energy absorption.","title":"Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#analysis-of-dynamics","text":"","title":"Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-the-damping-coefficient-gamma","text":"The damping coefficient determines how quickly the energy in the system is dissipated. In the forced damped pendulum, damping: Low damping : Allows for large amplitude oscillations and may contribute to a sharp resonance peak. High damping : Reduces the amplitude of oscillations, and if sufficiently high, the system may not oscillate at all. This may suppress chaotic behavior and lead to a smooth, decaying response. Critical damping : Occurs when \\(\\gamma = 2\\sqrt{mK}\\) , where the pendulum returns to equilibrium as quickly as possible without oscillating.","title":"Effect of the Damping Coefficient (\\(\\gamma\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-the-driving-amplitude-a","text":"The driving amplitude influences how much energy is being transferred to the pendulum. As \\(A\\) increases: At low \\(A\\) , the system may undergo regular oscillations. As \\(A\\) increases, periodic motion may switch to quasiperiodic or even chaotic motion. This transition happens due to nonlinear interactions between the driving force and the pendulum's motion.","title":"Effect of the Driving Amplitude (\\(A\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-the-driving-frequency-omega","text":"The driving frequency affects how the system absorbs energy from the driving force. When \\(\\Omega\\) is near \\(\\omega_0\\) , resonance occurs and the system can absorb large amounts of energy, leading to large amplitude oscillations. If \\(\\Omega\\) is far from \\(\\omega_0\\) , the system is less likely to enter resonance, and the oscillations are typically smaller.","title":"Effect of the Driving Frequency (\\(\\Omega\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#regular-vs-chaotic-motion","text":"As we vary \\(A\\) , \\(\\gamma\\) , and \\(\\Omega\\) , the pendulum's motion can transition from periodic to chaotic: Periodic motion : The pendulum oscillates in a stable, repeating manner. Quasiperiodic motion : The system oscillates in a non-repeating but predictable manner. Chaotic motion : Small changes in initial conditions lead to unpredictable motion, and the system exhibits sensitive dependence on initial conditions. Chaos can emerge if the system is driven at certain amplitudes and frequencies, especially when nonlinearity and resonance effects combine.","title":"Regular vs. Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#practical-applications","text":"The forced damped pendulum model has various practical applications across multiple domains, particularly in systems subjected to periodic forces.","title":"Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#energy-harvesting-devices","text":"The forced damped pendulum model can be used to design energy harvesting devices, where oscillations induced by external forces (such as vibrations from machinery or ambient energy) are converted into electrical energy. By tuning the system to resonate at the frequency of the external force, large amounts of energy can be harvested.","title":"Energy Harvesting Devices"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#suspension-bridges","text":"Suspension bridges, especially those with long spans, are susceptible to oscillations caused by wind or other external periodic forces. The dynamics of the bridge under these forces can be modeled by a forced damped pendulum, where the damping (structural damping) and driving forces (wind or traffic-induced forces) must be carefully balanced to avoid resonance, which could lead to catastrophic failure.","title":"Suspension Bridges"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#oscillating-circuits","text":"In electrical engineering, forced damped oscillators are used to model circuits with resistors, capacitors, and inductors driven by an external alternating current (AC). The resonance condition plays a critical role in the design of tuned circuits for radios, televisions, and other wireless communication technologies.","title":"Oscillating Circuits"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#implementation","text":"To simulate the motion of a forced damped pendulum computationally, we can solve the equation numerically for various values of the damping coefficient, driving force, and initial conditions. Here\u2019s a general outline of the steps to simulate the system: Numerical Solution of the Differential Equation : Use a method like the Euler method or Runge-Kutta method to solve the second-order differential equation numerically. Phase Diagrams and Poincar\u00e9 Sections : These can be used to visualize the dynamics. In a phase diagram, the state of the system is plotted in terms of position vs. velocity, showing how the system evolves over time. Poincar\u00e9 sections can capture the transitions between periodic, quasiperiodic, and chaotic regimes by plotting intersections of the system's trajectory with a plane of constant time. Visualization : We can plot time series, phase space trajectories, and bifurcation diagrams to analyze how the system behaves under different conditions.","title":"Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#computational-model-example","text":"Here's a basic framework for simulating the system: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants gamma = 0.2 # damping coefficient omega_0 = 1.0 # natural frequency A = 1.0 # driving amplitude Omega = 1.0 # driving frequency # Define the differential equation def forced_pendulum(t, y): theta, theta_dot = y dtheta_dt = theta_dot dtheta_dot_dt = -gamma * theta_dot - omega_0**2 * np.sin(theta) + A * np.cos(Omega * t) return [dtheta_dt, dtheta_dot_dt] # Initial conditions y0 = [0.5, 0] # Initial angle and velocity # Time span t_span = (0, 50) t_eval = np.linspace(0, 50, 1000) # Solve the differential equation solution = solve_ivp(forced_pendulum, t_span, y0, t_eval=t_eval) # Plotting the time series and phase diagram plt.figure(figsize=(10, 5)) # Time series plot plt.subplot(1, 2, 1) plt.plot(solution.t, solution.y[0]) plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Time Series of the Forced Damped Pendulum') # Phase diagram plot plt.subplot(1, 2, 2) plt.plot(solution.y[0], solution.y[1]) plt.xlabel('Angle (rad)') plt.ylabel('Velocity (rad/s)') plt.title('Phase Diagram') plt.tight_layout() plt.show() In the above simulation: - We use solve_ivp to numerically solve the second-order differential equation. - The results are visualized both in time series and phase space. To observe transitions to chaos, varying parameters like \\(A\\) , \\(\\gamma\\) , and \\(\\Omega\\) will result in different types of motion, which can be analyzed through phase space diagrams and Poincar\u00e9 sections.","title":"Computational Model Example"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"The forced damped pendulum is a rich system that demonstrates complex dynamics such as resonance, chaos, and quasiperiodic behavior, depending on the damping coefficient, driving amplitude, and frequency. These phenomena have broad applications in real-world systems like energy harvesting, structural engineering, and electronics. Through computational modeling, we can better understand how changes in system parameters influence behavior and predict transitions between regular and chaotic motion.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Motivation The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law, is a cornerstone of celestial mechanics. This simple yet profound relationship allows for the determination of planetary motions and has implications for understanding gravitational interactions on both local and cosmic scales. By analyzing this relationship, one can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems. Derivation of Kepler\u2019s Third Law for Circular Orbits Newton\u2019s form of Kepler\u2019s Third Law comes from equating the centripetal force required to keep a body in circular orbit with the gravitational force. Gravitational Force and Orbital Motion Gravitational Force (Newton's Law of Gravitation): \\[ F = \\frac{G M m}{r^2} \\] Where: \\(G\\) is the gravitational constant. \\(M\\) is the mass of the central body (e.g., the Sun for planets, the Earth for the Moon). \\(m\\) is the mass of the orbiting body. \\(r\\) is the orbital radius. Centripetal Force needed to keep the body in circular motion: \\[ F = \\frac{m v^2}{r} \\] Where: \\(v\\) is the orbital velocity. Setting gravitational force equal to centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Cancel \\(m\\) from both sides: \\[ \\frac{G M}{r^2} = \\frac{v^2}{r} \\] Rearrange: \\[ G M = v^2 r \\] Orbital Velocity and Orbital Period: The orbital velocity \\(v\\) is related to the orbital period \\(T\\) by: \\[ v = \\frac{2 \\pi r}{T} \\] Substituting into our equation: \\[ G M = \\left( \\frac{2 \\pi r}{T} \\right)^2 r \\] Expanding and solving for \\(T^2\\) : \\[ T^2 = \\frac{4 \\pi^2}{G M} r^3 \\] This shows that: \\[ T^2 \\propto r^3 \\] Conclusion: This proportionality is Kepler\u2019s Third Law . Implications for Astronomy Calculating Planetary Masses: Rearranging the equation: \\( M = \\frac{4\\pi^2 r^3}{G T^2} \\) If we know the orbital radius and period of a satellite, we can estimate the mass of the central body. Determining Distances in the Solar System: Using known periods, astronomers can determine the semi-major axis of a planet's orbit. Exoplanet Detection: By measuring the orbital period of an exoplanet (e.g., through transit or radial velocity methods), its orbital radius can be estimated. Real-World Examples Moon's Orbit Around Earth: The Moon has an orbital period of 27.3 days and a mean orbital radius of 384,400 km . Using Kepler\u2019s Third Law, we can verify the Earth\u2019s mass. Planets in the Solar System: Applying the law to planets orbiting the Sun reveals a consistent pattern that holds across different planetary orbits. Computational Model: Simulation of Circular Orbits This Python script numerically simulates circular orbits and verifies Kepler\u2019s Third Law. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation, PillowWriter # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Actual planetary data (Orbital radii in meters and periods in seconds) planet_data = { \"Mercury\": {\"radius\": 5.79e10, \"period\": 7.6e6, \"color\": \"gold\", \"size\": 300}, \"Venus\": {\"radius\": 1.08e11, \"period\": 1.94e7, \"color\": \"orange\", \"size\": 600}, \"Earth\": {\"radius\": 1.50e11, \"period\": 3.15e7, \"color\": \"blue\", \"size\": 800}, \"Mars\": {\"radius\": 2.28e11, \"period\": 5.94e7, \"color\": \"red\", \"size\": 400}, \"Jupiter\": {\"radius\": 7.78e11, \"period\": 3.73e8, \"color\": \"brown\", \"size\": 2000}, \"Saturn\": {\"radius\": 1.43e12, \"period\": 9.29e8, \"color\": \"yellow\", \"size\": 1700}, \"Uranus\": {\"radius\": 2.87e12, \"period\": 2.65e9, \"color\": \"cyan\", \"size\": 1500}, \"Neptune\": {\"radius\": 4.50e12, \"period\": 5.2e9, \"color\": \"purple\", \"size\": 1400}, } # Extract data into arrays radii = np.array([data[\"radius\"] for data in planet_data.values()]) periods = np.array([data[\"period\"] for data in planet_data.values()]) planet_colors = [data[\"color\"] for data in planet_data.values()] planet_sizes = [data[\"size\"] for data in planet_data.values()] planet_names = list(planet_data.keys()) # Normalize radii and periods for better scaling radii_cubed = radii**3 / 1e36 # Scale to make numbers manageable periods_squared = periods**2 / 1e16 # Create the figure and 3D axis fig = plt.figure(figsize=(12, 8)) ax = fig.add_subplot(111, projection='3d') # Plot planets as styled circles planet_plots = [] for i, (radius, period, color, size) in enumerate(zip(radii_cubed, periods_squared, planet_colors, planet_sizes)): p = ax.scatter( radius, period, zs=0, s=size, color=color, edgecolors='black', label=planet_names[i] ) planet_plots.append(p) # Annotate planets for i, (planet, radius, period) in enumerate(zip(planet_names, radii_cubed, periods_squared)): ax.text( radius, period, 0, planet, fontsize=10, color='black', bbox=dict(facecolor='white', edgecolor='black', boxstyle='round,pad=0.3') ) # Axis labels and title ax.set_xlabel(\"Orbital Radius Cubed (r\u00b3) [10\u00b3\u2076 m\u00b3]\", fontsize=12) ax.set_ylabel(\"Orbital Period Squared (T\u00b2) [10\u00b9\u2076 s\u00b2]\", fontsize=12) ax.set_zlabel(\"Z-axis (Fixed at 0)\", fontsize=12) ax.set_title(\"3D Visualization of Kepler's Third Law\", fontsize=14, fontweight='bold') # Animation function def update(frame): ax.view_init(elev=30, azim=frame) # Rotate the plot by changing the azimuthal angle return planet_plots # Create the animation ani = FuncAnimation(fig, update, frames=np.arange(0, 360, 2), interval=50, blit=False) # Save as GIF ani.save(\"kepler_3d_animation.gif\", writer=PillowWriter(fps=20)) # Display success message print(\"GIF saved as 'kepler_3d_animation.gif'\") This script: Simulates various orbital radii. Computes the corresponding orbital periods. Plots \\( T^2 \\) vs. \\( r^3 \\) , which should yield a straight line, confirming Kepler's Third Law. Extending to Elliptical Orbits Kepler\u2019s Third Law applies to elliptical orbits as well, but instead of \\( r \\) , we use the semi-major axis \\( a \\) . The law still holds: \\[ T^2 = \\frac{4\\pi^2 a^3}{G M} \\] Example: Halley's Comet, which follows an elliptical orbit, still obeys this principle. Conclusion Kepler\u2019s Third Law provides a fundamental relationship between orbital period and radius. It is widely used in planetary science, space exploration, and astrophysics. The computational model successfully verifies the law and its real-world applications.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law, is a cornerstone of celestial mechanics. This simple yet profound relationship allows for the determination of planetary motions and has implications for understanding gravitational interactions on both local and cosmic scales. By analyzing this relationship, one can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law-for-circular-orbits","text":"Newton\u2019s form of Kepler\u2019s Third Law comes from equating the centripetal force required to keep a body in circular orbit with the gravitational force.","title":"Derivation of Kepler\u2019s Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#gravitational-force-and-orbital-motion","text":"","title":"Gravitational Force and Orbital Motion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#gravitational-force-newtons-law-of-gravitation","text":"\\[ F = \\frac{G M m}{r^2} \\] Where: \\(G\\) is the gravitational constant. \\(M\\) is the mass of the central body (e.g., the Sun for planets, the Earth for the Moon). \\(m\\) is the mass of the orbiting body. \\(r\\) is the orbital radius.","title":"Gravitational Force (Newton's Law of Gravitation):"},{"location":"1%20Physics/2%20Gravity/Problem_1/#centripetal-force-needed-to-keep-the-body-in-circular-motion","text":"\\[ F = \\frac{m v^2}{r} \\] Where: \\(v\\) is the orbital velocity.","title":"Centripetal Force needed to keep the body in circular motion:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#setting-gravitational-force-equal-to-centripetal-force","text":"\\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Cancel \\(m\\) from both sides: \\[ \\frac{G M}{r^2} = \\frac{v^2}{r} \\] Rearrange: \\[ G M = v^2 r \\]","title":"Setting gravitational force equal to centripetal force:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-velocity-and-orbital-period","text":"The orbital velocity \\(v\\) is related to the orbital period \\(T\\) by: \\[ v = \\frac{2 \\pi r}{T} \\] Substituting into our equation: \\[ G M = \\left( \\frac{2 \\pi r}{T} \\right)^2 r \\] Expanding and solving for \\(T^2\\) : \\[ T^2 = \\frac{4 \\pi^2}{G M} r^3 \\] This shows that: \\[ T^2 \\propto r^3 \\]","title":"Orbital Velocity and Orbital Period:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"This proportionality is Kepler\u2019s Third Law .","title":"Conclusion:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-for-astronomy","text":"Calculating Planetary Masses: Rearranging the equation: \\( M = \\frac{4\\pi^2 r^3}{G T^2} \\) If we know the orbital radius and period of a satellite, we can estimate the mass of the central body. Determining Distances in the Solar System: Using known periods, astronomers can determine the semi-major axis of a planet's orbit. Exoplanet Detection: By measuring the orbital period of an exoplanet (e.g., through transit or radial velocity methods), its orbital radius can be estimated.","title":"Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"Moon's Orbit Around Earth: The Moon has an orbital period of 27.3 days and a mean orbital radius of 384,400 km . Using Kepler\u2019s Third Law, we can verify the Earth\u2019s mass. Planets in the Solar System: Applying the law to planets orbiting the Sun reveals a consistent pattern that holds across different planetary orbits.","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#computational-model-simulation-of-circular-orbits","text":"This Python script numerically simulates circular orbits and verifies Kepler\u2019s Third Law. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation, PillowWriter # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Actual planetary data (Orbital radii in meters and periods in seconds) planet_data = { \"Mercury\": {\"radius\": 5.79e10, \"period\": 7.6e6, \"color\": \"gold\", \"size\": 300}, \"Venus\": {\"radius\": 1.08e11, \"period\": 1.94e7, \"color\": \"orange\", \"size\": 600}, \"Earth\": {\"radius\": 1.50e11, \"period\": 3.15e7, \"color\": \"blue\", \"size\": 800}, \"Mars\": {\"radius\": 2.28e11, \"period\": 5.94e7, \"color\": \"red\", \"size\": 400}, \"Jupiter\": {\"radius\": 7.78e11, \"period\": 3.73e8, \"color\": \"brown\", \"size\": 2000}, \"Saturn\": {\"radius\": 1.43e12, \"period\": 9.29e8, \"color\": \"yellow\", \"size\": 1700}, \"Uranus\": {\"radius\": 2.87e12, \"period\": 2.65e9, \"color\": \"cyan\", \"size\": 1500}, \"Neptune\": {\"radius\": 4.50e12, \"period\": 5.2e9, \"color\": \"purple\", \"size\": 1400}, } # Extract data into arrays radii = np.array([data[\"radius\"] for data in planet_data.values()]) periods = np.array([data[\"period\"] for data in planet_data.values()]) planet_colors = [data[\"color\"] for data in planet_data.values()] planet_sizes = [data[\"size\"] for data in planet_data.values()] planet_names = list(planet_data.keys()) # Normalize radii and periods for better scaling radii_cubed = radii**3 / 1e36 # Scale to make numbers manageable periods_squared = periods**2 / 1e16 # Create the figure and 3D axis fig = plt.figure(figsize=(12, 8)) ax = fig.add_subplot(111, projection='3d') # Plot planets as styled circles planet_plots = [] for i, (radius, period, color, size) in enumerate(zip(radii_cubed, periods_squared, planet_colors, planet_sizes)): p = ax.scatter( radius, period, zs=0, s=size, color=color, edgecolors='black', label=planet_names[i] ) planet_plots.append(p) # Annotate planets for i, (planet, radius, period) in enumerate(zip(planet_names, radii_cubed, periods_squared)): ax.text( radius, period, 0, planet, fontsize=10, color='black', bbox=dict(facecolor='white', edgecolor='black', boxstyle='round,pad=0.3') ) # Axis labels and title ax.set_xlabel(\"Orbital Radius Cubed (r\u00b3) [10\u00b3\u2076 m\u00b3]\", fontsize=12) ax.set_ylabel(\"Orbital Period Squared (T\u00b2) [10\u00b9\u2076 s\u00b2]\", fontsize=12) ax.set_zlabel(\"Z-axis (Fixed at 0)\", fontsize=12) ax.set_title(\"3D Visualization of Kepler's Third Law\", fontsize=14, fontweight='bold') # Animation function def update(frame): ax.view_init(elev=30, azim=frame) # Rotate the plot by changing the azimuthal angle return planet_plots # Create the animation ani = FuncAnimation(fig, update, frames=np.arange(0, 360, 2), interval=50, blit=False) # Save as GIF ani.save(\"kepler_3d_animation.gif\", writer=PillowWriter(fps=20)) # Display success message print(\"GIF saved as 'kepler_3d_animation.gif'\") This script: Simulates various orbital radii. Computes the corresponding orbital periods. Plots \\( T^2 \\) vs. \\( r^3 \\) , which should yield a straight line, confirming Kepler's Third Law.","title":"Computational Model: Simulation of Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extending-to-elliptical-orbits","text":"Kepler\u2019s Third Law applies to elliptical orbits as well, but instead of \\( r \\) , we use the semi-major axis \\( a \\) . The law still holds: \\[ T^2 = \\frac{4\\pi^2 a^3}{G M} \\] Example: Halley's Comet, which follows an elliptical orbit, still obeys this principle.","title":"Extending to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion_1","text":"Kepler\u2019s Third Law provides a fundamental relationship between orbital period and radius. It is widely used in planetary science, space exploration, and astrophysics. The computational model successfully verifies the law and its real-world applications.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Motivation The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. Definitions 1. First Cosmic Velocity The first cosmic velocity is the minimum velocity required for a body to maintain a circular orbit around a celestial object: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] Where: \\(G\\) : Gravitational constant. \\(M\\) : Mass of the celestial object. \\(r\\) : Radius of the orbit (distance from the center of the celestial body). 2. Second Cosmic Velocity (Escape Velocity) The second cosmic velocity is the minimum velocity required to escape a celestial body's gravitational influence entirely: \\[ v_2 = \\sqrt{\\frac{2 G M}{r}} \\] 3. Third Cosmic Velocity The third cosmic velocity is the minimum velocity required to escape the gravitational pull of a star system (e.g., leaving the Solar System): \\[ v_3 \\text{ depends on the Sun's mass, distance from the Sun, and interaction with other celestial bodies.} \\] Analysis and Derivations First Cosmic Velocity : Derived from equating centripetal force and gravitational force. Second Cosmic Velocity : Derived from the total energy (kinetic + potential) equaling zero. Third Cosmic Velocity : Involves the combined gravitational influence of the star and celestial bodies. Example Calculations For Earth First Cosmic Velocity : \\(v_1 \\approx 7.91 \\, \\text{km/s}\\) Second Cosmic Velocity : \\(v_2 \\approx 11.19 \\, \\text{km/s}\\) Third Cosmic Velocity : \\(v_3 \\approx 51.60 \\, \\text{km/s}\\) For Mars First Cosmic Velocity : \\(v_1 \\approx 3.55 \\, \\text{km/s}\\) Second Cosmic Velocity : \\(v_2 \\approx 5.0 \\, \\text{km/s}\\) Third Cosmic Velocity : \\(v_3 \\approx 41.80 \\, \\text{km/s}\\) For Jupiter First Cosmic Velocity : \\(v_1 \\approx 42.57 \\, \\text{km/s}\\) Second Cosmic Velocity : \\(v_2 \\approx 60.20 \\, \\text{km/s}\\) Third Cosmic Velocity : \\(v_3 \\approx 22.62 \\, \\text{km/s}\\) Note : Calculations vary based on celestial parameters such as radius and mass. Importance in Space Exploration Launching Satellites : First cosmic velocity defines stable satellite orbits. Second cosmic velocity ensures satellites can leave Earth for interplanetary destinations. Missions to Other Planets : Understanding escape velocities helps optimize fuel usage for spacecraft. Interstellar Travel : The third cosmic velocity enables the possibility of leaving the Solar System for interstellar missions. These concepts are foundational for modern space missions, from launching satellites to planning interplanetary exploration and beyond. Visualization To better understand the cosmic velocities, you can create plots comparing their values for different celestial bodies using tools like Python or MATLAB. import matplotlib.pyplot as plt import numpy as np # Define constants G = 6.67430e-11 # Gravitational constant, m^3 kg^-1 s^-2 M_sun = 1.989e30 # Mass of the Sun, kg # Celestial body parameters: (name, mass in kg, radius in meters, distance from Sun in meters) celestial_bodies = [ (\"Earth\", 5.972e24, 6.371e6, 1.496e11), (\"Mars\", 6.417e23, 3.3895e6, 2.279e11), (\"Jupiter\", 1.898e27, 6.9911e7, 7.785e11), ] # Function to calculate first, second, and third cosmic velocities def calculate_velocities(mass, radius, distance_from_sun): # First Cosmic Velocity v1 = np.sqrt(G * mass / radius) # Second Cosmic Velocity v2 = np.sqrt(2 * G * mass / radius) # Escape velocity from the Sun v_esc_sun = np.sqrt(2 * G * M_sun / distance_from_sun) # Orbital velocity of the celestial body around the Sun v_orb = np.sqrt(G * M_sun / distance_from_sun) # Third Cosmic Velocity v3 = np.sqrt(v_esc_sun**2 + v_orb**2) return v1, v2, v3 # Prepare data for plotting labels = [] # Planet names v1_values = [] # First Cosmic Velocity (km/s) v2_values = [] # Second Cosmic Velocity (km/s) v3_values = [] # Third Cosmic Velocity (km/s) for body in celestial_bodies: name, mass, radius, distance = body v1, v2, v3 = calculate_velocities(mass, radius, distance) labels.append(name) v1_values.append(v1 / 1000) # Convert m/s to km/s v2_values.append(v2 / 1000) # Convert m/s to km/s v3_values.append(v3 / 1000) # Convert m/s to km/s # Print calculated velocities for clarity for label, v1, v2, v3 in zip(labels, v1_values, v2_values, v3_values): print(f\"{label}:\") print(f\" First Cosmic Velocity: {v1:.2f} km/s\") print(f\" Second Cosmic Velocity: {v2:.2f} km/s\") print(f\" Third Cosmic Velocity: {v3:.2f} km/s\\n\") # Plot the velocities x = np.arange(len(labels)) # X-axis positions plt.figure(figsize=(12, 6)) plt.bar(x - 0.3, v1_values, width=0.3, label=\"First Cosmic Velocity (km/s)\", color=\"blue\") plt.bar(x, v2_values, width=0.3, label=\"Second Cosmic Velocity (km/s)\", color=\"orange\") plt.bar(x + 0.3, v3_values, width=0.3, label=\"Third Cosmic Velocity (km/s)\", color=\"green\") # Add labels, title, and grid plt.xticks(x, labels) # Label x-axis positions with planet names plt.xlabel(\"Celestial Bodies\") plt.ylabel(\"Velocity (km/s)\") plt.title(\"First, Second, and Third Cosmic Velocities for Celestial Bodies\") plt.legend() plt.grid(axis=\"y\", linestyle=\"--\", alpha=0.7) plt.tight_layout() # Show the plot plt.show()","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions","text":"","title":"Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity","text":"The first cosmic velocity is the minimum velocity required for a body to maintain a circular orbit around a celestial object: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] Where: \\(G\\) : Gravitational constant. \\(M\\) : Mass of the celestial object. \\(r\\) : Radius of the orbit (distance from the center of the celestial body).","title":"1. First Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-velocity","text":"The second cosmic velocity is the minimum velocity required to escape a celestial body's gravitational influence entirely: \\[ v_2 = \\sqrt{\\frac{2 G M}{r}} \\]","title":"2. Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity","text":"The third cosmic velocity is the minimum velocity required to escape the gravitational pull of a star system (e.g., leaving the Solar System): \\[ v_3 \\text{ depends on the Sun's mass, distance from the Sun, and interaction with other celestial bodies.} \\]","title":"3. Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#analysis-and-derivations","text":"First Cosmic Velocity : Derived from equating centripetal force and gravitational force. Second Cosmic Velocity : Derived from the total energy (kinetic + potential) equaling zero. Third Cosmic Velocity : Involves the combined gravitational influence of the star and celestial bodies.","title":"Analysis and Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#example-calculations","text":"","title":"Example Calculations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#for-earth","text":"First Cosmic Velocity : \\(v_1 \\approx 7.91 \\, \\text{km/s}\\) Second Cosmic Velocity : \\(v_2 \\approx 11.19 \\, \\text{km/s}\\) Third Cosmic Velocity : \\(v_3 \\approx 51.60 \\, \\text{km/s}\\)","title":"For Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#for-mars","text":"First Cosmic Velocity : \\(v_1 \\approx 3.55 \\, \\text{km/s}\\) Second Cosmic Velocity : \\(v_2 \\approx 5.0 \\, \\text{km/s}\\) Third Cosmic Velocity : \\(v_3 \\approx 41.80 \\, \\text{km/s}\\)","title":"For Mars"},{"location":"1%20Physics/2%20Gravity/Problem_2/#for-jupiter","text":"First Cosmic Velocity : \\(v_1 \\approx 42.57 \\, \\text{km/s}\\) Second Cosmic Velocity : \\(v_2 \\approx 60.20 \\, \\text{km/s}\\) Third Cosmic Velocity : \\(v_3 \\approx 22.62 \\, \\text{km/s}\\) Note : Calculations vary based on celestial parameters such as radius and mass.","title":"For Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"Launching Satellites : First cosmic velocity defines stable satellite orbits. Second cosmic velocity ensures satellites can leave Earth for interplanetary destinations. Missions to Other Planets : Understanding escape velocities helps optimize fuel usage for spacecraft. Interstellar Travel : The third cosmic velocity enables the possibility of leaving the Solar System for interstellar missions. These concepts are foundational for modern space missions, from launching satellites to planning interplanetary exploration and beyond.","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#visualization","text":"To better understand the cosmic velocities, you can create plots comparing their values for different celestial bodies using tools like Python or MATLAB. import matplotlib.pyplot as plt import numpy as np # Define constants G = 6.67430e-11 # Gravitational constant, m^3 kg^-1 s^-2 M_sun = 1.989e30 # Mass of the Sun, kg # Celestial body parameters: (name, mass in kg, radius in meters, distance from Sun in meters) celestial_bodies = [ (\"Earth\", 5.972e24, 6.371e6, 1.496e11), (\"Mars\", 6.417e23, 3.3895e6, 2.279e11), (\"Jupiter\", 1.898e27, 6.9911e7, 7.785e11), ] # Function to calculate first, second, and third cosmic velocities def calculate_velocities(mass, radius, distance_from_sun): # First Cosmic Velocity v1 = np.sqrt(G * mass / radius) # Second Cosmic Velocity v2 = np.sqrt(2 * G * mass / radius) # Escape velocity from the Sun v_esc_sun = np.sqrt(2 * G * M_sun / distance_from_sun) # Orbital velocity of the celestial body around the Sun v_orb = np.sqrt(G * M_sun / distance_from_sun) # Third Cosmic Velocity v3 = np.sqrt(v_esc_sun**2 + v_orb**2) return v1, v2, v3 # Prepare data for plotting labels = [] # Planet names v1_values = [] # First Cosmic Velocity (km/s) v2_values = [] # Second Cosmic Velocity (km/s) v3_values = [] # Third Cosmic Velocity (km/s) for body in celestial_bodies: name, mass, radius, distance = body v1, v2, v3 = calculate_velocities(mass, radius, distance) labels.append(name) v1_values.append(v1 / 1000) # Convert m/s to km/s v2_values.append(v2 / 1000) # Convert m/s to km/s v3_values.append(v3 / 1000) # Convert m/s to km/s # Print calculated velocities for clarity for label, v1, v2, v3 in zip(labels, v1_values, v2_values, v3_values): print(f\"{label}:\") print(f\" First Cosmic Velocity: {v1:.2f} km/s\") print(f\" Second Cosmic Velocity: {v2:.2f} km/s\") print(f\" Third Cosmic Velocity: {v3:.2f} km/s\\n\") # Plot the velocities x = np.arange(len(labels)) # X-axis positions plt.figure(figsize=(12, 6)) plt.bar(x - 0.3, v1_values, width=0.3, label=\"First Cosmic Velocity (km/s)\", color=\"blue\") plt.bar(x, v2_values, width=0.3, label=\"Second Cosmic Velocity (km/s)\", color=\"orange\") plt.bar(x + 0.3, v3_values, width=0.3, label=\"Third Cosmic Velocity (km/s)\", color=\"green\") # Add labels, title, and grid plt.xticks(x, labels) # Label x-axis positions with planet names plt.xlabel(\"Celestial Bodies\") plt.ylabel(\"Velocity (km/s)\") plt.title(\"First, Second, and Third Cosmic Velocities for Celestial Bodies\") plt.legend() plt.grid(axis=\"y\", linestyle=\"--\", alpha=0.7) plt.tight_layout() # Show the plot plt.show()","title":"Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When a payload is released from a moving rocket near Earth, its trajectory depends on its initial conditions (position, velocity, and altitude) as well as Earth's gravitational pull. Depending on the initial speed and direction, the payload can follow one of several possible paths: - Elliptical Orbit: When the payload's speed is less than the circular orbital speed, it will remain bound to Earth on an elliptical orbit. - Parabolic Trajectory: When the payload's speed is exactly the escape velocity, it follows a parabolic path, representing the threshold between bound and unbound orbits. - Hyperbolic Trajectory: If the payload's speed exceeds the escape velocity, it follows a hyperbolic path and escapes Earth\u2019s gravitational pull. Understanding these trajectories is crucial for: - Orbital Insertion: Placing satellites and payloads into stable orbits. - Reentry: Safely returning objects to Earth. - Escape Scenarios: Planning missions that leave Earth\u2019s gravitational field for interplanetary or even interstellar travel. Theoretical Background When an object moves under the influence of Earth's gravity, its acceleration is given by Newton's law of universal gravitation: \\[ \\vec{a} = -\\frac{\\mu}{r^3}\\vec{r} \\quad \\text{with} \\quad \\mu = G M_{\\text{earth}} \\] Where: \\( G \\) is the gravitational constant. \\( M_{\\text{earth}} \\) is Earth's mass. \\( r \\) is the distance from Earth's center. If the payload is released at an altitude \\( h \\) above Earth's surface, the initial distance is: \\[ r_0 = R_{\\text{earth}} + h \\] Depending on the payload's speed \\( v_0 \\) : For elliptical orbits : \\( v_0 < v_{\\text{circular}} \\) where \\( v_{\\text{circular}} = \\sqrt{\\mu / r_0} \\) For a parabolic trajectory : \\( v_0 = v_{\\text{escape}} = \\sqrt{2\\mu / r_0} \\) For hyperbolic trajectories : \\( v_0 > v_{\\text{escape}} \\) Numerical Simulation and Visualization The following Python script uses a numerical integrator to solve the two-dimensional equations of motion for a payload released near Earth. It simulates three cases: - Elliptical Orbit: \\( v_0 = 0.95 \\times v_{\\text{circular}} \\) - Parabolic Trajectory: \\( v_0 = v_{\\text{escape}} \\) - Hyperbolic Trajectory: \\( v_0 = 1.1 \\times v_{\\text{escape}} \\) import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant, m^3 kg^-1 s^-2 M = 5.972e24 # Mass of Earth, kg R = 6.371e6 # Radius of Earth, m # Initial conditions for the three cases initial_conditions = { \"Elliptical Orbit\": 0.95 * np.sqrt(G * M / R), # v0 < v_circular \"Parabolic Trajectory\": np.sqrt(2 * G * M / R), # v0 = v_escape \"Hyperbolic Trajectory\": 1.1 * np.sqrt(2 * G * M / R) # v0 > v_escape } # Simulation parameters time_step = 0.1 # Time step in seconds total_time = 300 # Total simulation time in seconds times = np.arange(0, total_time, time_step) def simulate_trajectory(v0, G, M, R): # Initialize position and velocity x, y = R, 0 # Initial position vx, vy = 0, v0 # Initial velocity # Lists to store trajectory points x_vals, y_vals = [x], [y] for t in times: # Compute gravitational force r = np.sqrt(x**2 + y**2) force_mag = G * M / r**2 fx = -force_mag * x / r fy = -force_mag * y / r # Update velocity using acceleration vx += fx * time_step vy += fy * time_step # Update position using velocity x += vx * time_step y += vy * time_step # Store updated position x_vals.append(x) y_vals.append(y) # Stop if object escapes gravity influence (r > 10*R) if r > 10 * R: break return x_vals, y_vals # Plot trajectories for the three cases plt.figure(figsize=(10, 8)) for case, v0 in initial_conditions.items(): x_vals, y_vals = simulate_trajectory(v0, G, M, R) plt.plot(x_vals, y_vals, label=case) # Plot Earth earth = plt.Circle((0, 0), R, color='blue', alpha=0.3, label=\"Earth\") plt.gca().add_artist(earth) # Labels and legend plt.title(\"Trajectories Under Newton's Law of Universal Gravitation\", fontsize=14) plt.xlabel(\"X Position (m)\", fontsize=12) plt.ylabel(\"Y Position (m)\", fontsize=12) plt.legend() plt.grid() plt.axis(\"equal\") # Display plot plt.show() Discussion Trajectory Analysis Elliptical Orbits: With an initial speed less than the circular orbital velocity, the payload enters a bound, elliptical trajectory. Such orbits are common for satellites. Parabolic Trajectories: A payload released with exactly the escape velocity follows a parabolic path\u2014this is the critical condition between remaining bound and escaping Earth's gravity. Hyperbolic Trajectories: With an initial speed exceeding the escape velocity, the payload follows a hyperbolic trajectory. This extra speed allows the payload to permanently escape Earth\u2019s gravitational influence, which is essential in certain interplanetary or deep-space missions. Applications in Space Missions Orbital Insertion: Precise adjustments of speed and direction are necessary to insert payloads into stable orbits (typically elliptical). Reentry: Understanding these trajectories helps in planning safe reentry paths for returning spacecraft. Escape Trajectories: Hyperbolic trajectories are crucial for missions targeting journeys beyond Earth\u2019s gravitational well. Conclusion By varying the initial velocity and direction of a payload released near Earth, we can observe different trajectories\u2014elliptical, parabolic, or hyperbolic\u2014each corresponding to distinct mission profiles such as satellite insertion, reentry, or escape. The accompanying Python simulation serves as a computational tool for visualizing these scenarios, offering insights vital for space mission planning and execution.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a moving rocket near Earth, its trajectory depends on its initial conditions (position, velocity, and altitude) as well as Earth's gravitational pull. Depending on the initial speed and direction, the payload can follow one of several possible paths: - Elliptical Orbit: When the payload's speed is less than the circular orbital speed, it will remain bound to Earth on an elliptical orbit. - Parabolic Trajectory: When the payload's speed is exactly the escape velocity, it follows a parabolic path, representing the threshold between bound and unbound orbits. - Hyperbolic Trajectory: If the payload's speed exceeds the escape velocity, it follows a hyperbolic path and escapes Earth\u2019s gravitational pull. Understanding these trajectories is crucial for: - Orbital Insertion: Placing satellites and payloads into stable orbits. - Reentry: Safely returning objects to Earth. - Escape Scenarios: Planning missions that leave Earth\u2019s gravitational field for interplanetary or even interstellar travel.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-background","text":"When an object moves under the influence of Earth's gravity, its acceleration is given by Newton's law of universal gravitation: \\[ \\vec{a} = -\\frac{\\mu}{r^3}\\vec{r} \\quad \\text{with} \\quad \\mu = G M_{\\text{earth}} \\] Where: \\( G \\) is the gravitational constant. \\( M_{\\text{earth}} \\) is Earth's mass. \\( r \\) is the distance from Earth's center. If the payload is released at an altitude \\( h \\) above Earth's surface, the initial distance is: \\[ r_0 = R_{\\text{earth}} + h \\] Depending on the payload's speed \\( v_0 \\) : For elliptical orbits : \\( v_0 < v_{\\text{circular}} \\) where \\( v_{\\text{circular}} = \\sqrt{\\mu / r_0} \\) For a parabolic trajectory : \\( v_0 = v_{\\text{escape}} = \\sqrt{2\\mu / r_0} \\) For hyperbolic trajectories : \\( v_0 > v_{\\text{escape}} \\)","title":"Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation-and-visualization","text":"The following Python script uses a numerical integrator to solve the two-dimensional equations of motion for a payload released near Earth. It simulates three cases: - Elliptical Orbit: \\( v_0 = 0.95 \\times v_{\\text{circular}} \\) - Parabolic Trajectory: \\( v_0 = v_{\\text{escape}} \\) - Hyperbolic Trajectory: \\( v_0 = 1.1 \\times v_{\\text{escape}} \\) import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant, m^3 kg^-1 s^-2 M = 5.972e24 # Mass of Earth, kg R = 6.371e6 # Radius of Earth, m # Initial conditions for the three cases initial_conditions = { \"Elliptical Orbit\": 0.95 * np.sqrt(G * M / R), # v0 < v_circular \"Parabolic Trajectory\": np.sqrt(2 * G * M / R), # v0 = v_escape \"Hyperbolic Trajectory\": 1.1 * np.sqrt(2 * G * M / R) # v0 > v_escape } # Simulation parameters time_step = 0.1 # Time step in seconds total_time = 300 # Total simulation time in seconds times = np.arange(0, total_time, time_step) def simulate_trajectory(v0, G, M, R): # Initialize position and velocity x, y = R, 0 # Initial position vx, vy = 0, v0 # Initial velocity # Lists to store trajectory points x_vals, y_vals = [x], [y] for t in times: # Compute gravitational force r = np.sqrt(x**2 + y**2) force_mag = G * M / r**2 fx = -force_mag * x / r fy = -force_mag * y / r # Update velocity using acceleration vx += fx * time_step vy += fy * time_step # Update position using velocity x += vx * time_step y += vy * time_step # Store updated position x_vals.append(x) y_vals.append(y) # Stop if object escapes gravity influence (r > 10*R) if r > 10 * R: break return x_vals, y_vals # Plot trajectories for the three cases plt.figure(figsize=(10, 8)) for case, v0 in initial_conditions.items(): x_vals, y_vals = simulate_trajectory(v0, G, M, R) plt.plot(x_vals, y_vals, label=case) # Plot Earth earth = plt.Circle((0, 0), R, color='blue', alpha=0.3, label=\"Earth\") plt.gca().add_artist(earth) # Labels and legend plt.title(\"Trajectories Under Newton's Law of Universal Gravitation\", fontsize=14) plt.xlabel(\"X Position (m)\", fontsize=12) plt.ylabel(\"Y Position (m)\", fontsize=12) plt.legend() plt.grid() plt.axis(\"equal\") # Display plot plt.show()","title":"Numerical Simulation and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_3/#discussion","text":"","title":"Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectory-analysis","text":"Elliptical Orbits: With an initial speed less than the circular orbital velocity, the payload enters a bound, elliptical trajectory. Such orbits are common for satellites. Parabolic Trajectories: A payload released with exactly the escape velocity follows a parabolic path\u2014this is the critical condition between remaining bound and escaping Earth's gravity. Hyperbolic Trajectories: With an initial speed exceeding the escape velocity, the payload follows a hyperbolic trajectory. This extra speed allows the payload to permanently escape Earth\u2019s gravitational influence, which is essential in certain interplanetary or deep-space missions.","title":"Trajectory Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_3/#applications-in-space-missions","text":"Orbital Insertion: Precise adjustments of speed and direction are necessary to insert payloads into stable orbits (typically elliptical). Reentry: Understanding these trajectories helps in planning safe reentry paths for returning spacecraft. Escape Trajectories: Hyperbolic trajectories are crucial for missions targeting journeys beyond Earth\u2019s gravitational well.","title":"Applications in Space Missions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"By varying the initial velocity and direction of a payload released near Earth, we can observe different trajectories\u2014elliptical, parabolic, or hyperbolic\u2014each corresponding to distinct mission profiles such as satellite insertion, reentry, or escape. The accompanying Python simulation serves as a computational tool for visualizing these scenarios, offering insights vital for space mission planning and execution.","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a water surface Motivation: Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be easily observed when ripples from different points meet, forming distinctive interference patterns. These patterns can show us how waves combine in different ways, either reinforcing each other or canceling out. Studying these patterns helps us understand wave behavior in a simple, visual way. It also allows us to explore important concepts, like the relationship between wave phase and the effects of multiple sources. This task offers a hands-on approach to learning about wave interactions and their real-world applications, making it an interesting and engaging way to dive into wave Task A circular wave on the water surface, emanating from a point source located at \\((x_0, y_0)\\) , can be described by the Single Disturbance equation: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos \\left( kr - \\omega t + \\phi \\right) \\] where: \\(\\eta(x, y, t)\\) is the displacement of the water surface at point \\((x, y)\\) and time \\(t\\) , \\(A\\) is the amplitude of the wave, \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, related to the wavelength \\(\\lambda\\) , \\(\\omega = 2\\pi f\\) is the angular frequency, related to the frequency \\(f\\) , \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source to the point \\((x, y)\\) , \\(\\phi\\) is the initial phase. 1. Sinusoidal Surface Plot import numpy as np import matplotlib.pyplot as plt # Define grid x = np.linspace(-5, 5, 100) y = np.linspace(-5, 5, 100) x, y = np.meshgrid(x, y) # Define sinusoidal surface z = np.sin(np.sqrt(x**2 + y**2)) # Plot 2D heatmap plt.figure(figsize=(8, 6)) plt.contourf(x, y, z, levels=50, cmap='viridis') plt.colorbar(label='Amplitude') plt.title('2D Heatmap of Sinusoidal Wave') plt.xlabel('X position') plt.ylabel('Y position') plt.show() # Plot 3D surface fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(x, y, z, cmap='viridis', edgecolor='k', alpha=0.8) ax.set_title('3D Surface Plot of Sinusoidal Wave') ax.set_xlabel('X position') ax.set_ylabel('Y position') ax.set_zlabel('Amplitude') plt.show() 2. Circular Wave Interference import numpy as np import matplotlib.pyplot as plt # Wave parameters A = 1 # Amplitude k = 2 * np.pi / 1 # Wave number omega = 2 * np.pi * 1 # Angular frequency def circular_wave(x, y, sources, t): \"\"\"Compute circular wave pattern.\"\"\" z = np.zeros_like(x) for sx, sy in sources: r = np.sqrt((x - sx)**2 + (y - sy)**2) z += A * np.cos(k * r - omega * t) return z # Define grid x_vals = np.linspace(-10, 10, 400) y_vals = np.linspace(-10, 10, 400) x, y = np.meshgrid(x_vals, y_vals) # Sources sources = np.array([[0, 0], [5, 5], [-5, -5]]) # Static pattern z = circular_wave(x, y, sources, t=0) # Plot 2D heatmap plt.figure(figsize=(8, 6)) plt.contourf(x, y, z, levels=50, cmap='plasma') plt.colorbar(label='Wave Amplitude') plt.scatter(sources[:, 0], sources[:, 1], color='black', label='Sources') plt.legend() plt.title('Circular Wave Interference Pattern') plt.xlabel('X position') plt.ylabel('Y position') plt.show() # Plot 3D surface fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(x, y, z, cmap='plasma', edgecolor='k', alpha=0.8) ax.set_title('3D Surface Plot of Circular Wave Interference') ax.set_xlabel('X position') ax.set_ylabel('Y position') ax.set_zlabel('Amplitude') plt.show() With more sources import numpy as np import matplotlib.pyplot as plt # Wave parameters A = 1 # Amplitude k = 2 * np.pi / 1 # Wave number omega = 2 * np.pi * 1 # Angular frequency def circular_wave(x, y, sources, t): \"\"\"Compute circular wave pattern.\"\"\" z = np.zeros_like(x) for sx, sy in sources: r = np.sqrt((x - sx)**2 + (y - sy)**2) z += A * np.cos(k * r - omega * t) return z # Define grid x_vals = np.linspace(-10, 10, 400) y_vals = np.linspace(-10, 10, 400) x, y = np.meshgrid(x_vals, y_vals) # Sources - Expanded for more interference sources = np.array([[0, 0], [5, 5], [-5, -5], [5, -5], [-5, 5], [0, 5], [0, -5], [5, 0], [-5, 0]]) # Static pattern z = circular_wave(x, y, sources, t=0) # Plot 2D heatmap plt.figure(figsize=(8, 6)) plt.contourf(x, y, z, levels=50, cmap='plasma') plt.colorbar(label='Wave Amplitude') plt.scatter(sources[:, 0], sources[:, 1], color='black', label='Sources') plt.legend() plt.title('Circular Wave Interference Pattern (with More Sources)') plt.xlabel('X position') plt.ylabel('Y position') plt.show() # Plot 3D surface fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(x, y, z, cmap='plasma', edgecolor='k', alpha=0.8) ax.set_title('3D Surface Plot of Circular Wave Interference (with More Sources)') ax.set_xlabel('X position') ax.set_ylabel('Y position') ax.set_zlabel('Amplitude') plt.show() 3. Dynamic Ripple Animation import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Parameters A = 1 # Amplitude k = 2 * np.pi / 1 # Wave number omega = 2 * np.pi * 0.5 # Angular frequency # Define grid x_vals = np.linspace(-10, 10, 200) y_vals = np.linspace(-10, 10, 200) x, y = np.meshgrid(x_vals, y_vals) # Update function for animation def update(t): z = A * np.cos(k * np.sqrt(x**2 + y**2) - omega * t) plt.clf() plt.contourf(x, y, z, levels=50, cmap='coolwarm') plt.colorbar(label='Amplitude') plt.title(f'Ripple Pattern at t = {t:.2f}') plt.xlabel('X position') plt.ylabel('Y position') # Animate fig = plt.figure(figsize=(8, 6)) ani = FuncAnimation(fig, update, frames=np.arange(0, 20, 0.2), interval=100) plt.show() Explanation of Interference Patterns for a Regular Polygon Wave Source 1. Understanding Wave Superposition When multiple wave sources emit waves simultaneously, the resulting wave pattern is determined by the principle of superposition . This principle states that the total displacement at any point on the water surface is the sum of the displacements caused by each individual wave. Mathematically, the total displacement \\(\\eta_{\\text{total}}(x, y, t)\\) is given by: $$ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{\\sqrt{r_i}} \\cos (k r_i - \\omega t + \\phi) $$ where: \\( N \\) is the number of sources (equal to the number of polygon vertices), \\( A \\) is the amplitude of the waves, \\( k = \\frac{2\\pi}{\\lambda} \\) is the wave number, \\( \\omega = 2\\pi f \\) is the angular frequency, \\( r_i \\) is the distance from the \\( i \\) -th source to the observation point \\( (x, y) \\) , \\( \\phi \\) is the initial phase. 2. How Polygon Shape Affects Interference The specific arrangement of wave sources affects the interference pattern: - Triangle (3 sources) : Forms a simple three-lobed interference pattern with well-defined constructive and destructive interference zones. - Square (4 sources) : Produces a grid-like interference pattern , with symmetry along both x- and y-axes. - Pentagon (5 sources, default in the script) : Introduces circular and radial symmetry , leading to more intricate interference fringes . - Higher polygons (e.g., hexagon, octagon, etc.) : As the number of sources increases, the interference pattern becomes denser and more complex , resembling a circular wave diffraction pattern . 3. Key Observations in the Interference Pattern Constructive Interference (Bright Regions in the Plot) Occurs when waves from multiple sources add up in phase (peaks coincide). Forms regions of high amplitude , appearing as bright red zones in the plot. Destructive Interference (Dark Regions in the Plot) Occurs when waves from multiple sources cancel out (peak of one wave meets the trough of another). Results in low-amplitude regions , appearing as dark blue zones in the plot. Symmetry and Wavefront Formation The regular polygon's symmetry ensures a highly structured interference pattern . The distance between sources and the wavelength determines the spacing of the interference fringes. At certain points, wave energy converges , reinforcing the wave amplitude significantly. 4. Visualizing the Interference Pattern The contour plot in the Python script represents wave displacement at each point in space. The color gradient (red to blue) indicates the magnitude of displacement\u2014constructive vs. destructive interference. The black dots represent the polygon vertices (wave sources) . The pattern remains static at a fixed time , but if animated over time, it would reveal the dynamic evolution of wave interactions . Conclusion This simulation provides a powerful visual representation of wave superposition. By modifying the number of polygon sides ( n_sides in the script), we can analyze how interference patterns evolve with different wave source configurations. This understanding is crucial in fields such as optics (diffraction patterns), acoustics (sound wave interference), and fluid dynamics (water wave interactions). \ud83d\ude80","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a water surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be easily observed when ripples from different points meet, forming distinctive interference patterns. These patterns can show us how waves combine in different ways, either reinforcing each other or canceling out. Studying these patterns helps us understand wave behavior in a simple, visual way. It also allows us to explore important concepts, like the relationship between wave phase and the effects of multiple sources. This task offers a hands-on approach to learning about wave interactions and their real-world applications, making it an interesting and engaging way to dive into wave","title":"Motivation:"},{"location":"1%20Physics/3%20Waves/Problem_1/#task","text":"A circular wave on the water surface, emanating from a point source located at \\((x_0, y_0)\\) , can be described by the Single Disturbance equation: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos \\left( kr - \\omega t + \\phi \\right) \\] where: \\(\\eta(x, y, t)\\) is the displacement of the water surface at point \\((x, y)\\) and time \\(t\\) , \\(A\\) is the amplitude of the wave, \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, related to the wavelength \\(\\lambda\\) , \\(\\omega = 2\\pi f\\) is the angular frequency, related to the frequency \\(f\\) , \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source to the point \\((x, y)\\) , \\(\\phi\\) is the initial phase.","title":"Task"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-sinusoidal-surface-plot","text":"import numpy as np import matplotlib.pyplot as plt # Define grid x = np.linspace(-5, 5, 100) y = np.linspace(-5, 5, 100) x, y = np.meshgrid(x, y) # Define sinusoidal surface z = np.sin(np.sqrt(x**2 + y**2)) # Plot 2D heatmap plt.figure(figsize=(8, 6)) plt.contourf(x, y, z, levels=50, cmap='viridis') plt.colorbar(label='Amplitude') plt.title('2D Heatmap of Sinusoidal Wave') plt.xlabel('X position') plt.ylabel('Y position') plt.show() # Plot 3D surface fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(x, y, z, cmap='viridis', edgecolor='k', alpha=0.8) ax.set_title('3D Surface Plot of Sinusoidal Wave') ax.set_xlabel('X position') ax.set_ylabel('Y position') ax.set_zlabel('Amplitude') plt.show()","title":"1. Sinusoidal Surface Plot"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-circular-wave-interference","text":"import numpy as np import matplotlib.pyplot as plt # Wave parameters A = 1 # Amplitude k = 2 * np.pi / 1 # Wave number omega = 2 * np.pi * 1 # Angular frequency def circular_wave(x, y, sources, t): \"\"\"Compute circular wave pattern.\"\"\" z = np.zeros_like(x) for sx, sy in sources: r = np.sqrt((x - sx)**2 + (y - sy)**2) z += A * np.cos(k * r - omega * t) return z # Define grid x_vals = np.linspace(-10, 10, 400) y_vals = np.linspace(-10, 10, 400) x, y = np.meshgrid(x_vals, y_vals) # Sources sources = np.array([[0, 0], [5, 5], [-5, -5]]) # Static pattern z = circular_wave(x, y, sources, t=0) # Plot 2D heatmap plt.figure(figsize=(8, 6)) plt.contourf(x, y, z, levels=50, cmap='plasma') plt.colorbar(label='Wave Amplitude') plt.scatter(sources[:, 0], sources[:, 1], color='black', label='Sources') plt.legend() plt.title('Circular Wave Interference Pattern') plt.xlabel('X position') plt.ylabel('Y position') plt.show() # Plot 3D surface fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(x, y, z, cmap='plasma', edgecolor='k', alpha=0.8) ax.set_title('3D Surface Plot of Circular Wave Interference') ax.set_xlabel('X position') ax.set_ylabel('Y position') ax.set_zlabel('Amplitude') plt.show()","title":"2. Circular Wave Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#with-more-sources","text":"import numpy as np import matplotlib.pyplot as plt # Wave parameters A = 1 # Amplitude k = 2 * np.pi / 1 # Wave number omega = 2 * np.pi * 1 # Angular frequency def circular_wave(x, y, sources, t): \"\"\"Compute circular wave pattern.\"\"\" z = np.zeros_like(x) for sx, sy in sources: r = np.sqrt((x - sx)**2 + (y - sy)**2) z += A * np.cos(k * r - omega * t) return z # Define grid x_vals = np.linspace(-10, 10, 400) y_vals = np.linspace(-10, 10, 400) x, y = np.meshgrid(x_vals, y_vals) # Sources - Expanded for more interference sources = np.array([[0, 0], [5, 5], [-5, -5], [5, -5], [-5, 5], [0, 5], [0, -5], [5, 0], [-5, 0]]) # Static pattern z = circular_wave(x, y, sources, t=0) # Plot 2D heatmap plt.figure(figsize=(8, 6)) plt.contourf(x, y, z, levels=50, cmap='plasma') plt.colorbar(label='Wave Amplitude') plt.scatter(sources[:, 0], sources[:, 1], color='black', label='Sources') plt.legend() plt.title('Circular Wave Interference Pattern (with More Sources)') plt.xlabel('X position') plt.ylabel('Y position') plt.show() # Plot 3D surface fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(x, y, z, cmap='plasma', edgecolor='k', alpha=0.8) ax.set_title('3D Surface Plot of Circular Wave Interference (with More Sources)') ax.set_xlabel('X position') ax.set_ylabel('Y position') ax.set_zlabel('Amplitude') plt.show()","title":"With more sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-dynamic-ripple-animation","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Parameters A = 1 # Amplitude k = 2 * np.pi / 1 # Wave number omega = 2 * np.pi * 0.5 # Angular frequency # Define grid x_vals = np.linspace(-10, 10, 200) y_vals = np.linspace(-10, 10, 200) x, y = np.meshgrid(x_vals, y_vals) # Update function for animation def update(t): z = A * np.cos(k * np.sqrt(x**2 + y**2) - omega * t) plt.clf() plt.contourf(x, y, z, levels=50, cmap='coolwarm') plt.colorbar(label='Amplitude') plt.title(f'Ripple Pattern at t = {t:.2f}') plt.xlabel('X position') plt.ylabel('Y position') # Animate fig = plt.figure(figsize=(8, 6)) ani = FuncAnimation(fig, update, frames=np.arange(0, 20, 0.2), interval=100) plt.show()","title":"3. Dynamic Ripple Animation"},{"location":"1%20Physics/3%20Waves/Problem_1/#explanation-of-interference-patterns-for-a-regular-polygon-wave-source","text":"","title":"Explanation of Interference Patterns for a Regular Polygon Wave Source"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-understanding-wave-superposition","text":"When multiple wave sources emit waves simultaneously, the resulting wave pattern is determined by the principle of superposition . This principle states that the total displacement at any point on the water surface is the sum of the displacements caused by each individual wave. Mathematically, the total displacement \\(\\eta_{\\text{total}}(x, y, t)\\) is given by: $$ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{\\sqrt{r_i}} \\cos (k r_i - \\omega t + \\phi) $$ where: \\( N \\) is the number of sources (equal to the number of polygon vertices), \\( A \\) is the amplitude of the waves, \\( k = \\frac{2\\pi}{\\lambda} \\) is the wave number, \\( \\omega = 2\\pi f \\) is the angular frequency, \\( r_i \\) is the distance from the \\( i \\) -th source to the observation point \\( (x, y) \\) , \\( \\phi \\) is the initial phase.","title":"1. Understanding Wave Superposition"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-how-polygon-shape-affects-interference","text":"The specific arrangement of wave sources affects the interference pattern: - Triangle (3 sources) : Forms a simple three-lobed interference pattern with well-defined constructive and destructive interference zones. - Square (4 sources) : Produces a grid-like interference pattern , with symmetry along both x- and y-axes. - Pentagon (5 sources, default in the script) : Introduces circular and radial symmetry , leading to more intricate interference fringes . - Higher polygons (e.g., hexagon, octagon, etc.) : As the number of sources increases, the interference pattern becomes denser and more complex , resembling a circular wave diffraction pattern .","title":"2. How Polygon Shape Affects Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-key-observations-in-the-interference-pattern","text":"Constructive Interference (Bright Regions in the Plot) Occurs when waves from multiple sources add up in phase (peaks coincide). Forms regions of high amplitude , appearing as bright red zones in the plot. Destructive Interference (Dark Regions in the Plot) Occurs when waves from multiple sources cancel out (peak of one wave meets the trough of another). Results in low-amplitude regions , appearing as dark blue zones in the plot. Symmetry and Wavefront Formation The regular polygon's symmetry ensures a highly structured interference pattern . The distance between sources and the wavelength determines the spacing of the interference fringes. At certain points, wave energy converges , reinforcing the wave amplitude significantly.","title":"3. Key Observations in the Interference Pattern"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-visualizing-the-interference-pattern","text":"The contour plot in the Python script represents wave displacement at each point in space. The color gradient (red to blue) indicates the magnitude of displacement\u2014constructive vs. destructive interference. The black dots represent the polygon vertices (wave sources) . The pattern remains static at a fixed time , but if animated over time, it would reveal the dynamic evolution of wave interactions .","title":"4. Visualizing the Interference Pattern"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"This simulation provides a powerful visual representation of wave superposition. By modifying the number of polygon sides ( n_sides in the script), we can analyze how interference patterns evolve with different wave source configurations. This understanding is crucial in fields such as optics (diffraction patterns), acoustics (sound wave interference), and fluid dynamics (water wave interactions). \ud83d\ude80","title":"Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulating the effects of the Lorentz Force The Lorentz Force governs the motion of charged particles in electric and magnetic fields. It is defined as: \\[ \\mathbf{F} = q (\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] Where: \\( q \\) is the charge of the particle. \\( \\mathbf{E} \\) is the electric field vector. \\( \\mathbf{v} \\) is the velocity vector of the particle. \\( \\mathbf{B} \\) is the magnetic field vector. Exploration of Applications Key Systems Where the Lorentz Force Plays a Role: Particle Accelerators \u2013 The Lorentz force is crucial in synchrotrons and cyclotrons, where charged particles are steered and accelerated using electric and magnetic fields. Mass Spectrometers \u2013 These devices use the Lorentz force to separate ions based on their mass-to-charge ratio by bending their trajectories in a magnetic field. Plasma Confinement \u2013 In fusion reactors (e.g., tokamaks), magnetic fields confine high-energy charged particles, preventing them from escaping and sustaining plasma conditions for fusion. Cathode Ray Tubes (CRTs) \u2013 Used in old television screens and oscilloscopes, the motion of electrons is controlled via electric and magnetic fields. Hall Effect Sensors \u2013 The Lorentz force influences charge carriers in a conductor placed in a magnetic field, helping measure magnetic field strength. Relevance of Electric and Magnetic Fields in Controlling Charged Particles: Electric Fields ( \\(\\mathbf{E}\\) ): Control particle velocity by accelerating or decelerating charged particles in a linear direction. Magnetic Fields ( \\(\\mathbf{B}\\) ): Deflect charged particles perpendicular to their velocity, leading to circular or helical motion. Combined Effects: Used in electromagnetic traps, spectrometers, and fusion devices to precisely manipulate particle motion for research and industrial applications. Steps to Simulate Particle Motion Define Parameters: Charge \\(q\\) and mass \\(m\\) of the particle. Initial position \\(\\vec{r}(t_0)\\) and velocity \\(\\vec{v}(t_0)\\) . Electric field \\(\\vec{E}\\) and magnetic field \\(\\vec{B}\\) configurations. Set Up Equations of Motion: Use the Lorentz force equation: $$ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) $$ This provides acceleration: $$ \\vec{a} = \\frac{\\vec{F}}{m} $$ Time-Stepping: Discretize time using a small timestep \\(\\Delta t\\) . Update velocity and position iteratively: $$ \\vec{v}(t + \\Delta t) = \\vec{v}(t) + \\vec{a} \\Delta t $$ $$ \\vec{r}(t + \\Delta t) = \\vec{r}(t) + \\vec{v}(t) \\Delta t $$ Simulation Types: Uniform Magnetic Field: The motion will typically be circular or helical, depending on the initial velocity. Combined Electric and Magnetic Fields: Include the contribution of \\(\\vec{E}\\) in the force equation. Crossed Fields ( \\(\\vec{E} \\perp \\vec{B}\\) ): Drift velocity appears perpendicular to both \\(\\vec{E}\\) and \\(\\vec{B}\\) . Visualization: Plot the trajectory using libraries like matplotlib . Add 2D or 3D visualizations to capture the particle's motion. Parameter Exploration Implementation Field Strengths ( \\(\\mathbf{E}\\) ), ( \\(\\mathbf{B}\\) ): Define adjustable electric ( \\(\\mathbf{E}\\) ) and magnetic ( \\(\\mathbf{B}\\) ) field strengths Explore scenarios such as weak or strong fields to observe circular, helical, or drift motion. Initial Velocity The initial velocity of the particle is represented as: \\[ \\vec{v}_0 = \\begin{pmatrix} v_{x0} \\\\ v_{y0} \\\\ v_{z0} \\end{pmatrix} \\] Experiment with different magnitudes and directions of initial velocity. Observe how higher velocities or perpendicular velocity components affect trajectories. Charge \\(q\\) and Mass \\(m\\) : Vary particle properties, such as charge-to-mass ratio \\(\\frac{q}{m}\\) , which directly influences the radius of circular motion and the overall dynamics This script numerically solves the equations of motion and visualizes the trajectory of a charged particle. Sample Python Code Below is a simple example for a particle in a uniform magnetic field: import numpy as np import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define Lorentz Force function def lorentz_force(t, y, q, m, E, B): position = y[:3] # x, y, z coordinates velocity = y[3:] # vx, vy, vz # Compute force force = q * (E + np.cross(velocity, B)) # Newton's second law acceleration = force / m return np.concatenate([velocity, acceleration]) # Return velocity and acceleration # Parameters q = 1.0 # Charge (Coulombs) m = 1.0 # Mass (kg) E = np.array([0, 0, 0]) # Electric field (V/m) B = np.array([0, 0, 1]) # Magnetic field (T) # Initial conditions initial_position = np.array([0, 0, 0]) initial_velocity = np.array([1, 0, 0]) initial_state = np.concatenate([initial_position, initial_velocity]) # Time span t_span = (0, 10) t_eval = np.linspace(*t_span, 1000) # Solve ODE solution = solve_ivp(lorentz_force, t_span, initial_state, args=(q, m, E, B), t_eval=t_eval) # Extract results x, y, z = solution.y[:3] # Plot trajectory fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(x, y, z, label=\"Particle trajectory\") ax.set_xlabel(\"X Position\") ax.set_ylabel(\"Y Position\") ax.set_zlabel(\"Z Position\") ax.legend() plt.title(\"Lorentz Force Simulation\") plt.show() This code can be adapted for other cases by modifying the fields \\(\\vec{E}\\) and \\(\\vec{B}\\) , as well as the initial velocity.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"The Lorentz Force governs the motion of charged particles in electric and magnetic fields. It is defined as: \\[ \\mathbf{F} = q (\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] Where: \\( q \\) is the charge of the particle. \\( \\mathbf{E} \\) is the electric field vector. \\( \\mathbf{v} \\) is the velocity vector of the particle. \\( \\mathbf{B} \\) is the magnetic field vector.","title":"Simulating the effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#exploration-of-applications","text":"","title":"Exploration of Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#key-systems-where-the-lorentz-force-plays-a-role","text":"Particle Accelerators \u2013 The Lorentz force is crucial in synchrotrons and cyclotrons, where charged particles are steered and accelerated using electric and magnetic fields. Mass Spectrometers \u2013 These devices use the Lorentz force to separate ions based on their mass-to-charge ratio by bending their trajectories in a magnetic field. Plasma Confinement \u2013 In fusion reactors (e.g., tokamaks), magnetic fields confine high-energy charged particles, preventing them from escaping and sustaining plasma conditions for fusion. Cathode Ray Tubes (CRTs) \u2013 Used in old television screens and oscilloscopes, the motion of electrons is controlled via electric and magnetic fields. Hall Effect Sensors \u2013 The Lorentz force influences charge carriers in a conductor placed in a magnetic field, helping measure magnetic field strength.","title":"Key Systems Where the Lorentz Force Plays a Role:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#relevance-of-electric-and-magnetic-fields-in-controlling-charged-particles","text":"Electric Fields ( \\(\\mathbf{E}\\) ): Control particle velocity by accelerating or decelerating charged particles in a linear direction. Magnetic Fields ( \\(\\mathbf{B}\\) ): Deflect charged particles perpendicular to their velocity, leading to circular or helical motion. Combined Effects: Used in electromagnetic traps, spectrometers, and fusion devices to precisely manipulate particle motion for research and industrial applications.","title":"Relevance of Electric and Magnetic Fields in Controlling Charged Particles:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#steps-to-simulate-particle-motion","text":"Define Parameters: Charge \\(q\\) and mass \\(m\\) of the particle. Initial position \\(\\vec{r}(t_0)\\) and velocity \\(\\vec{v}(t_0)\\) . Electric field \\(\\vec{E}\\) and magnetic field \\(\\vec{B}\\) configurations. Set Up Equations of Motion: Use the Lorentz force equation: $$ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) $$ This provides acceleration: $$ \\vec{a} = \\frac{\\vec{F}}{m} $$ Time-Stepping: Discretize time using a small timestep \\(\\Delta t\\) . Update velocity and position iteratively: $$ \\vec{v}(t + \\Delta t) = \\vec{v}(t) + \\vec{a} \\Delta t $$ $$ \\vec{r}(t + \\Delta t) = \\vec{r}(t) + \\vec{v}(t) \\Delta t $$ Simulation Types: Uniform Magnetic Field: The motion will typically be circular or helical, depending on the initial velocity. Combined Electric and Magnetic Fields: Include the contribution of \\(\\vec{E}\\) in the force equation. Crossed Fields ( \\(\\vec{E} \\perp \\vec{B}\\) ): Drift velocity appears perpendicular to both \\(\\vec{E}\\) and \\(\\vec{B}\\) . Visualization: Plot the trajectory using libraries like matplotlib . Add 2D or 3D visualizations to capture the particle's motion.","title":"Steps to Simulate Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameter-exploration-implementation","text":"Field Strengths ( \\(\\mathbf{E}\\) ), ( \\(\\mathbf{B}\\) ): Define adjustable electric ( \\(\\mathbf{E}\\) ) and magnetic ( \\(\\mathbf{B}\\) ) field strengths Explore scenarios such as weak or strong fields to observe circular, helical, or drift motion. Initial Velocity The initial velocity of the particle is represented as: \\[ \\vec{v}_0 = \\begin{pmatrix} v_{x0} \\\\ v_{y0} \\\\ v_{z0} \\end{pmatrix} \\] Experiment with different magnitudes and directions of initial velocity. Observe how higher velocities or perpendicular velocity components affect trajectories. Charge \\(q\\) and Mass \\(m\\) : Vary particle properties, such as charge-to-mass ratio \\(\\frac{q}{m}\\) , which directly influences the radius of circular motion and the overall dynamics This script numerically solves the equations of motion and visualizes the trajectory of a charged particle.","title":"Parameter Exploration Implementation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#sample-python-code","text":"Below is a simple example for a particle in a uniform magnetic field: import numpy as np import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define Lorentz Force function def lorentz_force(t, y, q, m, E, B): position = y[:3] # x, y, z coordinates velocity = y[3:] # vx, vy, vz # Compute force force = q * (E + np.cross(velocity, B)) # Newton's second law acceleration = force / m return np.concatenate([velocity, acceleration]) # Return velocity and acceleration # Parameters q = 1.0 # Charge (Coulombs) m = 1.0 # Mass (kg) E = np.array([0, 0, 0]) # Electric field (V/m) B = np.array([0, 0, 1]) # Magnetic field (T) # Initial conditions initial_position = np.array([0, 0, 0]) initial_velocity = np.array([1, 0, 0]) initial_state = np.concatenate([initial_position, initial_velocity]) # Time span t_span = (0, 10) t_eval = np.linspace(*t_span, 1000) # Solve ODE solution = solve_ivp(lorentz_force, t_span, initial_state, args=(q, m, E, B), t_eval=t_eval) # Extract results x, y, z = solution.y[:3] # Plot trajectory fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(x, y, z, label=\"Particle trajectory\") ax.set_xlabel(\"X Position\") ax.set_ylabel(\"Y Position\") ax.set_zlabel(\"Z Position\") ax.legend() plt.title(\"Lorentz Force Simulation\") plt.show() This code can be adapted for other cases by modifying the fields \\(\\vec{E}\\) and \\(\\vec{B}\\) , as well as the initial velocity.","title":"Sample Python Code"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory Motivation Calculating equivalent resistance is a fundamental problem in electrical circuits, essential for understanding and designing efficient systems. While traditional methods involve iteratively applying series and parallel resistor rules, these approaches can become cumbersome for complex circuits with many components. Graph theory offers a powerful alternative, providing a structured and algorithmic way to analyze circuits. By representing a circuit as a graph\u2014where nodes correspond to junctions and edges represent resistors with weights equal to their resistance values\u2014we can systematically simplify even the most intricate networks. This method not only streamlines calculations but also opens the door to automated analysis, making it particularly useful in modern applications like circuit simulation software, optimization problems, and network design. Studying equivalent resistance through graph theory is valuable not only for its practical applications but also for the deeper insights it provides into the interplay between electrical and mathematical concepts. This approach highlights the versatility of graph theory, demonstrating its relevance across physics, engineering, and computer science. 1. Algorithm for Calculating Equivalent Resistance Using Graph Theory The algorithm treats the circuit as a weighted graph , where: Nodes represent electrical junctions. Edges represent resistors with weights equal to their resistance values. The process involves: Graph Representation: Construct the graph where resistors are edges with resistance values. Identifying Series and Parallel Configurations: Detect resistors in direct series or parallel using graph traversal. Iterative Reduction: Simplify the circuit by merging series and parallel components iteratively until a single equivalent resistance remains. Handling Nested Combinations: Apply recursion or iterative depth-first search (DFS) to process deep network structures. 2. Pseudocode for Equivalent Resistance Computation function ComputeEquivalentResistance(graph): while graph has more than two nodes: for each node in graph: if node has exactly one neighbor: # Series Reduction merge series resistors elif node connects to two resistors in parallel: # Parallel Reduction merge parallel resistors update graph structure return final equivalent resistance 3. Identifying Series and Parallel Connections Series Connection: If two resistors share a common node and no other connections exist at that node: [ R_{eq} = R_1 + R_2 ] Remove the intermediate node and merge resistances. Parallel Connection: If multiple resistors connect across the same two nodes: [ R_{eq} = \\left( \\frac{1}{R_1} + \\frac{1}{R_2} \\right)^{-1} ] Collapse edges into a single equivalent resistor. 4. Handling Nested Combinations Nested structures are resolved recursively : Detect deepest series/parallel sets using depth-first traversal . Reduce inner structures first , then propagate outward. Continue merging until only a single effective resistance remains. This graph-based method automates complex circuit analysis , making it efficient for circuit simulations. Pseudocode Algorithm: CalculateEquivalentResistance Input: G = Graph representing the circuit StartNode, EndNode = Nodes between which resistance is calculated Output: R_eq = Equivalent resistance between StartNode and EndNode Step 1: Graph Construction - Represent circuit as a weighted graph G (nodes = junctions, edges = resistors) Step 2: Iterative Reduction While G has more than two nodes: 1. Detect series connections: For each node N in G: If N has exactly 2 edges (A-N and N-B): Replace A-N-B with a single edge A-B Weight of A-B = Sum of weights of A-N and N-B Remove N from G 2. Detect parallel connections: For each cycle (parallel branches) in G: Replace cycle with a single edge Weight of the edge = Reciprocal of sum of reciprocals of weights Remove redundant edges Step 3: Return the equivalent resistance Return the weight of the single edge connecting StartNode to EndNode Python code import networkx as nx def calculate_equivalent_resistance(G, start_node, end_node): \"\"\" Calculate the equivalent resistance between start_node and end_node in a graph representation of a circuit. G: networkx.Graph The graph where nodes represent junctions and edges represent resistors (weights = resistance values). start_node: Node The starting node. end_node: Node The ending node. Returns: float The equivalent resistance. \"\"\" while len(G.nodes) > 2: # Step 2.1: Detect and reduce series connections for node in list(G.nodes): neighbors = list(G.neighbors(node)) if len(neighbors) == 2 and node != start_node and node != end_node: # If the node has exactly 2 neighbors (Series connection) n1, n2 = neighbors R1 = G[node][n1]['weight'] R2 = G[node][n2]['weight'] # Replace series connection with a single equivalent resistor Req_series = R1 + R2 G.add_edge(n1, n2, weight=Req_series) # Remove the current node G.remove_node(node) # Step 2.2: Detect and reduce parallel connections for u, v, data in list(G.edges(data=True)): # Check for parallel edges between u and v if G.number_of_edges(u, v) > 1: # Get all weights (resistances) of parallel edges weights = [G[u][v]['weight'] for _ in range(G.number_of_edges(u, v))] # Calculate equivalent parallel resistance Req_parallel = 1 / sum(1 / w for w in weights) # Replace all parallel edges with a single edge G.remove_edges_from(list(G.edges(u, v))) G.add_edge(u, v, weight=Req_parallel) # Step 3: Return the equivalent resistance return G[start_node][end_node]['weight'] # Example usage if __name__ == \"__main__\": # Step 1: Create a graph representing the circuit G = nx.Graph() # Add edges with resistance values (weights) G.add_edge(\"A\", \"B\", weight=10) # 10 ohms G.add_edge(\"B\", \"C\", weight=20) # 20 ohms G.add_edge(\"A\", \"C\", weight=30) # Parallel connection between A and C # Calculate equivalent resistance start_node, end_node = \"A\", \"C\" R_eq = calculate_equivalent_resistance(G, start_node, end_node) print(f\"The equivalent resistance between {start_node} and {end_node} is {R_eq:.2f} ohms\") Output: The equivalent resistance between A and C is 30.00 ohms Handling Nested Combinations The algorithm automatically handles nested combinations through iterative graph simplification. For example: - If a series reduction creates a new branch, the parallel reduction step will automatically simplify it. - If a parallel reduction creates a new linear chain, the series reduction step will handle it in the next iteration. This recursive simplification ensures that even deeply nested configurations are reduced correctly. Example Configurations Example 1: Simple Series Connection - Resistors: \\(R_1 = 10 \\, \\Omega\\) , \\(R_2 = 20 \\, \\Omega\\) . - The graph has nodes A-B-C with edges AB and BC. - Series reduction gives: $$ R_{\\text{eq}} = R_1 + R_2 = 30 \\, \\Omega $$ Example 2: Parallel Connection - Resistors: \\(R_1 = 10 \\, \\Omega\\) , \\(R_2 = 20 \\, \\Omega\\) . - The graph has nodes A-B connected by two edges. - Parallel reduction gives: $$ R_{\\text{eq}} = \\left( \\frac{1}{R_1} + \\frac{1}{R_2} \\right)^{-1} = 6.67 \\, \\Omega $$ Example 3: Nested Series and Parallel - Resistors: \\(R_1 = 10 \\, \\Omega\\) , \\(R_2 = 20 \\, \\Omega\\) , \\(R_3 = 30 \\, \\Omega\\) . - \\(R_1\\) and \\(R_2\\) are in parallel: $$ R_{\\text{eq(parallel)}} = \\left( \\frac{1}{R_1} + \\frac{1}{R_2} \\right)^{-1} = 6.67 \\, \\Omega $$ - \\(R_{\\text{eq(parallel)}}\\) and \\(R_3\\) are in series: $$ R_{\\text{eq}} = R_{\\text{eq(parallel)}} + R_3 = 36.67 \\, \\Omega $$ Algorithm Efficiency and Improvements Efficiency: Series Reduction : Runs in \\(O(n)\\) , where \\(n\\) is the number of nodes. Parallel Reduction : Detecting cycles in a graph requires \\(O(E + V)\\) , where \\(E\\) is the number of edges and \\(V\\) is the number of vertices. Overall Complexity : Depends on the graph's structure and the number of iterations needed to simplify it. Potential Improvements: - Use Union-Find or Disjoint Set data structures to optimize detection and merging of connected components. - Implement efficient cycle detection algorithms (e.g., DFS-based) for parallel reductions. - Use libraries like NetworkX in Python for better graph manipulation and visualization.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Calculating equivalent resistance is a fundamental problem in electrical circuits, essential for understanding and designing efficient systems. While traditional methods involve iteratively applying series and parallel resistor rules, these approaches can become cumbersome for complex circuits with many components. Graph theory offers a powerful alternative, providing a structured and algorithmic way to analyze circuits. By representing a circuit as a graph\u2014where nodes correspond to junctions and edges represent resistors with weights equal to their resistance values\u2014we can systematically simplify even the most intricate networks. This method not only streamlines calculations but also opens the door to automated analysis, making it particularly useful in modern applications like circuit simulation software, optimization problems, and network design. Studying equivalent resistance through graph theory is valuable not only for its practical applications but also for the deeper insights it provides into the interplay between electrical and mathematical concepts. This approach highlights the versatility of graph theory, demonstrating its relevance across physics, engineering, and computer science.","title":"Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-algorithm-for-calculating-equivalent-resistance-using-graph-theory","text":"The algorithm treats the circuit as a weighted graph , where: Nodes represent electrical junctions. Edges represent resistors with weights equal to their resistance values. The process involves: Graph Representation: Construct the graph where resistors are edges with resistance values. Identifying Series and Parallel Configurations: Detect resistors in direct series or parallel using graph traversal. Iterative Reduction: Simplify the circuit by merging series and parallel components iteratively until a single equivalent resistance remains. Handling Nested Combinations: Apply recursion or iterative depth-first search (DFS) to process deep network structures.","title":"1. Algorithm for Calculating Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-pseudocode-for-equivalent-resistance-computation","text":"function ComputeEquivalentResistance(graph): while graph has more than two nodes: for each node in graph: if node has exactly one neighbor: # Series Reduction merge series resistors elif node connects to two resistors in parallel: # Parallel Reduction merge parallel resistors update graph structure return final equivalent resistance","title":"2. Pseudocode for Equivalent Resistance Computation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-identifying-series-and-parallel-connections","text":"","title":"3. Identifying Series and Parallel Connections"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-connection","text":"If two resistors share a common node and no other connections exist at that node: [ R_{eq} = R_1 + R_2 ] Remove the intermediate node and merge resistances.","title":"Series Connection:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-connection","text":"If multiple resistors connect across the same two nodes: [ R_{eq} = \\left( \\frac{1}{R_1} + \\frac{1}{R_2} \\right)^{-1} ] Collapse edges into a single equivalent resistor.","title":"Parallel Connection:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#4-handling-nested-combinations","text":"Nested structures are resolved recursively : Detect deepest series/parallel sets using depth-first traversal . Reduce inner structures first , then propagate outward. Continue merging until only a single effective resistance remains. This graph-based method automates complex circuit analysis , making it efficient for circuit simulations.","title":"4. Handling Nested Combinations"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pseudocode","text":"Algorithm: CalculateEquivalentResistance Input: G = Graph representing the circuit StartNode, EndNode = Nodes between which resistance is calculated Output: R_eq = Equivalent resistance between StartNode and EndNode Step 1: Graph Construction - Represent circuit as a weighted graph G (nodes = junctions, edges = resistors) Step 2: Iterative Reduction While G has more than two nodes: 1. Detect series connections: For each node N in G: If N has exactly 2 edges (A-N and N-B): Replace A-N-B with a single edge A-B Weight of A-B = Sum of weights of A-N and N-B Remove N from G 2. Detect parallel connections: For each cycle (parallel branches) in G: Replace cycle with a single edge Weight of the edge = Reciprocal of sum of reciprocals of weights Remove redundant edges Step 3: Return the equivalent resistance Return the weight of the single edge connecting StartNode to EndNode","title":"Pseudocode"},{"location":"1%20Physics/5%20Circuits/Problem_1/#python-code","text":"import networkx as nx def calculate_equivalent_resistance(G, start_node, end_node): \"\"\" Calculate the equivalent resistance between start_node and end_node in a graph representation of a circuit. G: networkx.Graph The graph where nodes represent junctions and edges represent resistors (weights = resistance values). start_node: Node The starting node. end_node: Node The ending node. Returns: float The equivalent resistance. \"\"\" while len(G.nodes) > 2: # Step 2.1: Detect and reduce series connections for node in list(G.nodes): neighbors = list(G.neighbors(node)) if len(neighbors) == 2 and node != start_node and node != end_node: # If the node has exactly 2 neighbors (Series connection) n1, n2 = neighbors R1 = G[node][n1]['weight'] R2 = G[node][n2]['weight'] # Replace series connection with a single equivalent resistor Req_series = R1 + R2 G.add_edge(n1, n2, weight=Req_series) # Remove the current node G.remove_node(node) # Step 2.2: Detect and reduce parallel connections for u, v, data in list(G.edges(data=True)): # Check for parallel edges between u and v if G.number_of_edges(u, v) > 1: # Get all weights (resistances) of parallel edges weights = [G[u][v]['weight'] for _ in range(G.number_of_edges(u, v))] # Calculate equivalent parallel resistance Req_parallel = 1 / sum(1 / w for w in weights) # Replace all parallel edges with a single edge G.remove_edges_from(list(G.edges(u, v))) G.add_edge(u, v, weight=Req_parallel) # Step 3: Return the equivalent resistance return G[start_node][end_node]['weight'] # Example usage if __name__ == \"__main__\": # Step 1: Create a graph representing the circuit G = nx.Graph() # Add edges with resistance values (weights) G.add_edge(\"A\", \"B\", weight=10) # 10 ohms G.add_edge(\"B\", \"C\", weight=20) # 20 ohms G.add_edge(\"A\", \"C\", weight=30) # Parallel connection between A and C # Calculate equivalent resistance start_node, end_node = \"A\", \"C\" R_eq = calculate_equivalent_resistance(G, start_node, end_node) print(f\"The equivalent resistance between {start_node} and {end_node} is {R_eq:.2f} ohms\") Output: The equivalent resistance between A and C is 30.00 ohms","title":"Python code"},{"location":"1%20Physics/5%20Circuits/Problem_1/#handling-nested-combinations","text":"The algorithm automatically handles nested combinations through iterative graph simplification. For example: - If a series reduction creates a new branch, the parallel reduction step will automatically simplify it. - If a parallel reduction creates a new linear chain, the series reduction step will handle it in the next iteration. This recursive simplification ensures that even deeply nested configurations are reduced correctly.","title":"Handling Nested Combinations"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-configurations","text":"Example 1: Simple Series Connection - Resistors: \\(R_1 = 10 \\, \\Omega\\) , \\(R_2 = 20 \\, \\Omega\\) . - The graph has nodes A-B-C with edges AB and BC. - Series reduction gives: $$ R_{\\text{eq}} = R_1 + R_2 = 30 \\, \\Omega $$ Example 2: Parallel Connection - Resistors: \\(R_1 = 10 \\, \\Omega\\) , \\(R_2 = 20 \\, \\Omega\\) . - The graph has nodes A-B connected by two edges. - Parallel reduction gives: $$ R_{\\text{eq}} = \\left( \\frac{1}{R_1} + \\frac{1}{R_2} \\right)^{-1} = 6.67 \\, \\Omega $$ Example 3: Nested Series and Parallel - Resistors: \\(R_1 = 10 \\, \\Omega\\) , \\(R_2 = 20 \\, \\Omega\\) , \\(R_3 = 30 \\, \\Omega\\) . - \\(R_1\\) and \\(R_2\\) are in parallel: $$ R_{\\text{eq(parallel)}} = \\left( \\frac{1}{R_1} + \\frac{1}{R_2} \\right)^{-1} = 6.67 \\, \\Omega $$ - \\(R_{\\text{eq(parallel)}}\\) and \\(R_3\\) are in series: $$ R_{\\text{eq}} = R_{\\text{eq(parallel)}} + R_3 = 36.67 \\, \\Omega $$","title":"Example Configurations"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-efficiency-and-improvements","text":"Efficiency: Series Reduction : Runs in \\(O(n)\\) , where \\(n\\) is the number of nodes. Parallel Reduction : Detecting cycles in a graph requires \\(O(E + V)\\) , where \\(E\\) is the number of edges and \\(V\\) is the number of vertices. Overall Complexity : Depends on the graph's structure and the number of iterations needed to simplify it. Potential Improvements: - Use Union-Find or Disjoint Set data structures to optimize detection and merging of connected components. - Implement efficient cycle detection algorithms (e.g., DFS-based) for parallel reductions. - Use libraries like NetworkX in Python for better graph manipulation and visualization.","title":"Algorithm Efficiency and Improvements"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Exploring the Central Limit Theorem through simulations Motivation The Central Limit Theorem (CLT) is a cornerstone of probability and statistics, stating that the sampling distribution of the sample mean approaches a normal distribution as the sample size increases, regardless of the population\u2019s original distribution. Simulations provide an intuitive and hands-on way to observe this phenomenon in action. Here are the steps for CLT. Step 1: Simulating Sampling Distributions Start by generating data for three distinct population distributions: 1. Uniform distribution : Use numpy.random.uniform . 2. Exponential distribution : Use numpy.random.exponential . 3. Binomial distribution : Use numpy.random.binomial . For example: import numpy as np # Uniform Distribution uniform_population = np.random.uniform(0, 10, size=10000) # Exponential Distribution exponential_population = np.random.exponential(scale=2, size=10000) # Binomial Distribution binomial_population = np.random.binomial(n=20, p=0.5, size=10000) # Display some basic information print(\"Uniform Distribution - Mean:\", np.mean(uniform_population), \"Variance:\", np.var(uniform_population)) print(\"Exponential Distribution - Mean:\", np.mean(exponential_population), \"Variance:\", np.var(exponential_population)) print(\"Binomial Distribution - Mean:\", np.mean(binomial_population), \"Variance:\", np.var(binomial_population)) Output: Uniform Distribution - Mean: 4.975929262881268 Variance: 8.190846855965992 Exponential Distribution - Mean: 1.991324170407097 Variance: 3.8778654541766895 Binomial Distribution - Mean: 10.0012 Variance: 4.98579856 Step 2: Sampling and Visualization Create a function to: Draw random samples of different sizes. Compute the sample mean multiple times. Plot histograms of sample means. import matplotlib.pyplot as plt def sampling_distribution(population, sample_sizes, num_samples=1000): for size in sample_sizes: sample_means = [np.mean(np.random.choice(population, size, replace=False)) for _ in range(num_samples)] plt.hist(sample_means, bins=30, alpha=0.7, label=f'Sample Size: {size}') plt.title('Sampling Distribution') plt.xlabel('Sample Mean') plt.ylabel('Frequency') plt.legend() plt.show() # Example usage sample_sizes = [5, 10, 30, 50] sampling_distribution(uniform_population, sample_sizes) Step 3: Parameter Exploration Analyze how different population shapes and variances affect the rate of convergence to normality. Experiment with changing: The range of the uniform distribution. The scale parameter of the exponential distribution. The number of trials and probability in the binomial distribution. Step 4: Reflecting on Real-World Applications Discuss how the CLT applies in practical contexts. For instance: Estimating population parameters : The CLT allows confidence intervals and hypothesis tests to be applied even if the population distribution is unknown. Quality control : Understanding the distribution of sample means helps ensure manufacturing processes stay within control limits. Financial models : Aggregating returns over time benefits from CLT, assuming independence and identical distributions. The Central Limit Theorem (CLT) is an elegant demonstration of how sample means tend to form a normal distribution as the sample size increases, regardless of the population's initial distribution. Through this exploration, we observed the following key insights: Population Shape : While the original distribution can vary widely (uniform, exponential, binomial), the sampling distribution of the sample mean converges toward normality as the sample size grows. Sample Size Effect : Larger sample sizes accelerate convergence, making the sampling distribution more symmetric and concentrated around the true population mean. Impact of Variance : Populations with higher variance produce sampling distributions with greater spread, underscoring the role of variability in shaping statistical outcomes. Real-World Importance : The CLT has profound implications across fields like quality control, finance, and hypothesis testing, providing a robust foundation for statistical reasoning even when data distributions are unknown. In conclusion, simulations vividly illustrate the CLT's theoretical principles, transforming abstract concepts into tangible patterns. This hands-on approach enriches understanding, showcasing the theorem's universal applicability and reinforcing its importance in data science, research, and practical problem-solving.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exploring-the-central-limit-theorem-through-simulations","text":"","title":"Exploring the Central Limit Theorem through simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is a cornerstone of probability and statistics, stating that the sampling distribution of the sample mean approaches a normal distribution as the sample size increases, regardless of the population\u2019s original distribution. Simulations provide an intuitive and hands-on way to observe this phenomenon in action. Here are the steps for CLT. Step 1: Simulating Sampling Distributions Start by generating data for three distinct population distributions: 1. Uniform distribution : Use numpy.random.uniform . 2. Exponential distribution : Use numpy.random.exponential . 3. Binomial distribution : Use numpy.random.binomial . For example: import numpy as np # Uniform Distribution uniform_population = np.random.uniform(0, 10, size=10000) # Exponential Distribution exponential_population = np.random.exponential(scale=2, size=10000) # Binomial Distribution binomial_population = np.random.binomial(n=20, p=0.5, size=10000) # Display some basic information print(\"Uniform Distribution - Mean:\", np.mean(uniform_population), \"Variance:\", np.var(uniform_population)) print(\"Exponential Distribution - Mean:\", np.mean(exponential_population), \"Variance:\", np.var(exponential_population)) print(\"Binomial Distribution - Mean:\", np.mean(binomial_population), \"Variance:\", np.var(binomial_population)) Output: Uniform Distribution - Mean: 4.975929262881268 Variance: 8.190846855965992 Exponential Distribution - Mean: 1.991324170407097 Variance: 3.8778654541766895 Binomial Distribution - Mean: 10.0012 Variance: 4.98579856 Step 2: Sampling and Visualization Create a function to: Draw random samples of different sizes. Compute the sample mean multiple times. Plot histograms of sample means. import matplotlib.pyplot as plt def sampling_distribution(population, sample_sizes, num_samples=1000): for size in sample_sizes: sample_means = [np.mean(np.random.choice(population, size, replace=False)) for _ in range(num_samples)] plt.hist(sample_means, bins=30, alpha=0.7, label=f'Sample Size: {size}') plt.title('Sampling Distribution') plt.xlabel('Sample Mean') plt.ylabel('Frequency') plt.legend() plt.show() # Example usage sample_sizes = [5, 10, 30, 50] sampling_distribution(uniform_population, sample_sizes) Step 3: Parameter Exploration Analyze how different population shapes and variances affect the rate of convergence to normality. Experiment with changing: The range of the uniform distribution. The scale parameter of the exponential distribution. The number of trials and probability in the binomial distribution. Step 4: Reflecting on Real-World Applications Discuss how the CLT applies in practical contexts. For instance: Estimating population parameters : The CLT allows confidence intervals and hypothesis tests to be applied even if the population distribution is unknown. Quality control : Understanding the distribution of sample means helps ensure manufacturing processes stay within control limits. Financial models : Aggregating returns over time benefits from CLT, assuming independence and identical distributions. The Central Limit Theorem (CLT) is an elegant demonstration of how sample means tend to form a normal distribution as the sample size increases, regardless of the population's initial distribution. Through this exploration, we observed the following key insights: Population Shape : While the original distribution can vary widely (uniform, exponential, binomial), the sampling distribution of the sample mean converges toward normality as the sample size grows. Sample Size Effect : Larger sample sizes accelerate convergence, making the sampling distribution more symmetric and concentrated around the true population mean. Impact of Variance : Populations with higher variance produce sampling distributions with greater spread, underscoring the role of variability in shaping statistical outcomes. Real-World Importance : The CLT has profound implications across fields like quality control, finance, and hypothesis testing, providing a robust foundation for statistical reasoning even when data distributions are unknown. In conclusion, simulations vividly illustrate the CLT's theoretical principles, transforming abstract concepts into tangible patterns. This hands-on approach enriches understanding, showcasing the theorem's universal applicability and reinforcing its importance in data science, research, and practical problem-solving.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Estimating Pi using Monte Carlo Methods Motivation Monte Carlo simulations are a powerful class of computational techniques that use randomness to solve problems or estimate values. One of the most elegant applications of Monte Carlo methods is estimating the value \\(\\pi\\) of through geometric probability. By randomly generating points and analyzing their positions relative to a geometric shape, we can approximate \\(\\pi\\) in an intuitive and visually engaging way. This problem connects fundamental concepts of probability, geometry, and numerical computation. It also provides a gateway to understanding how randomness can be harnessed to solve complex problems in physics, finance, and computer science. The Monte Carlo approach to \\(\\pi\\) estimation highlights the versatility and simplicity of this method while offering practical insights into convergence rates and computational efficiency. The Monte Carlo method to estimate \u03c0 is indeed fascinating! Here's an overview and guidance to help you accomplish each part of this task. Task 1: Estimating Using a Circle Theoretical Foundation The technique leverages the geometric probability of points in a square and circle: Consider a unit circle with radius \\( r = 1 \\) inscribed in a square of side length \\( 2r = 2 \\) . The area of the circle is \\( \\pi r^2 = \\pi \\) , and the area of the square is \\( 4r^2 = 4 \\) . If we randomly distribute points within the square, the proportion of points falling inside the circle compared to the total points in the square approximates the ratio of the areas: $$ \\text{Ratio} = \\frac{\\text{Points inside the circle}}{\\text{Total points in the square}} \\approx \\frac{\\text{Area of the circle}}{\\text{Area of the square}} = \\frac{\\pi}{4} $$ Therefore, we can estimate \\( \\pi \\) as: $$ \\pi \\approx 4 \\times \\frac{\\text{Points inside the circle}}{\\text{Total points}} $$ Simulation Here's a step-by-step guide: Random Point Generation: Generate random (x, y) coordinates within the square \\( [-1, 1] \\times [-1, 1] \\) . Ensure randomness by using functions like random.uniform(-1, 1) in Python. Circle Membership Check: Use the equation \\( x^2 + y^2 \\leq 1 \\) to determine if a point lies inside the circle. Count the number of points satisfying this condition. \u03c0 Estimation: Apply the formula \\( \\pi \\approx 4 \\times \\frac{\\text{Points inside the circle}}{\\text{Total points}} \\) . Example Python snippet: import matplotlib.pyplot as plt import random N = 10000 # Number of random points points_inside = 0 x_inside, y_inside, x_outside, y_outside = [], [], [], [] for _ in range(N): x, y = random.uniform(-1, 1), random.uniform(-1, 1) if x**2 + y**2 <= 1: points_inside += 1 x_inside.append(x) y_inside.append(y) else: x_outside.append(x) y_outside.append(y) # Estimation of \u03c0 pi_estimate = 4 * points_inside / N print(f\"Estimated \u03c0: {pi_estimate}\") # Visualization plt.figure(figsize=(6, 6)) plt.scatter(x_inside, y_inside, color=\"green\", s=1) plt.scatter(x_outside, y_outside, color=\"red\", s=1) plt.gca().set_aspect(\"equal\", adjustable=\"box\") plt.title(f\"Monte Carlo \u03c0 Estimation (N={N})\") plt.show() Estimated \u03c0: 3.1412 Analysis Accuracy Improvement: The accuracy of the \u03c0 estimate increases with more points due to the law of large numbers. Convergence Rate: Convergence is proportional to \\( \\frac{1}{\\sqrt{N}} \\) , where \\( N \\) is the number of points. For higher precision, use a larger \\( N \\) , but note that computational time also increases. Considerations: Randomness quality affects the accuracy; use high-quality pseudorandom number generators. Parallelization can speed up computations for large \\( N \\) . Task 2: Estimating Buffon's Needle 1. Theoretical Foundation Buffon's Needle Problem : The problem involves dropping a needle of length \\(L\\) onto a plane with parallel lines spaced \\(D\\) units apart ( \\(D \\geq L\\) ). The probability \\(P\\) that the needle crosses a line is given by: $$ P = \\frac{2L}{\\pi D} $$ Rearranging, \u03c0 can be estimated as: $$ \\pi \\approx \\frac{2L \\cdot n}{D \\cdot h} $$ where: \\(n\\) = Total number of needle drops \\(h\\) = Number of times the needle crosses a line. 2. Simulation Steps : 1. Randomly generate the position and orientation of the needle. 2. Calculate whether the needle crosses a line based on its center position and angle. 3. Repeat for a large number of drops ( \\(n\\) ). 4. Use the formula to estimate \u03c0. Python Implementation : Here's an example snippet for the Buffon's Needle simulation: import numpy as np def buffons_needle_simulation(needle_length, line_spacing, num_trials): crosses = 0 for _ in range(num_trials): # Random center position and angle center = np.random.uniform(0, line_spacing / 2) # Center is within half-spacing angle = np.random.uniform(0, np.pi) # Angle between 0 and \u03c0 # Check if needle crosses a line if center <= (needle_length / 2) * np.sin(angle): crosses += 1 # Estimate \u03c0 if crosses > 0: pi_estimate = (2 * needle_length * num_trials) / (line_spacing * crosses) else: pi_estimate = None return pi_estimate # Parameters needle_length = 1.0 line_spacing = 2.0 num_trials = 10000 pi_estimate = buffons_needle_simulation(needle_length, line_spacing, num_trials) print(f\"Estimated \u03c0: {pi_estimate}\") Output: Estimated \u03c0: 3.119151590767311 3. Visualization Plot the Simulation : You can create a graphical representation using Matplotlib, showing the needle positions relative to the lines. Example for visualization: import matplotlib.pyplot as plt def visualize_simulation(needle_length, line_spacing, num_needles): fig, ax = plt.subplots(figsize=(8, 8)) for _ in range(num_needles): center = np.random.uniform(0, line_spacing / 2) angle = np.random.uniform(0, np.pi) # Needle end points x1 = center - (needle_length / 2) * np.cos(angle) x2 = center + (needle_length / 2) * np.cos(angle) y = [0, 0] ax.plot([x1, x2], y, 'r-') # Plot lines for i in range(5): # Adjust for spacing ax.axvline(i * line_spacing / 2, color='k', linestyle='--') plt.title(\"Buffon's Needle Simulation\") plt.show() visualize_simulation(needle_length=1.0, line_spacing=2.0, num_needles=100) 4. Analysis Convergence of \u03c0 : Run simulations with increasing numbers of needle drops. Record the estimates and plot the convergence. Example: import matplotlib.pyplot as plt def analyze_convergence(needle_length, line_spacing, max_trials): estimates = [] trials = [] for num_trials in range(100, max_trials + 1, 100): pi_estimate = buffons_needle_simulation(needle_length, line_spacing, num_trials) estimates.append(pi_estimate) trials.append(num_trials) plt.plot(trials, estimates, marker='o') plt.axhline(np.pi, color='red', linestyle='--', label=\"True \u03c0\") plt.xlabel(\"Number of Trials\") plt.ylabel(\"Estimated \u03c0\") plt.title(\"Convergence of \u03c0 Estimation\") plt.legend() plt.show() analyze_convergence(needle_length=1.0, line_spacing=2.0, max_trials=10000)","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-pi-using-monte-carlo-methods","text":"","title":"Estimating Pi using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#motivation","text":"Monte Carlo simulations are a powerful class of computational techniques that use randomness to solve problems or estimate values. One of the most elegant applications of Monte Carlo methods is estimating the value \\(\\pi\\) of through geometric probability. By randomly generating points and analyzing their positions relative to a geometric shape, we can approximate \\(\\pi\\) in an intuitive and visually engaging way. This problem connects fundamental concepts of probability, geometry, and numerical computation. It also provides a gateway to understanding how randomness can be harnessed to solve complex problems in physics, finance, and computer science. The Monte Carlo approach to \\(\\pi\\) estimation highlights the versatility and simplicity of this method while offering practical insights into convergence rates and computational efficiency. The Monte Carlo method to estimate \u03c0 is indeed fascinating! Here's an overview and guidance to help you accomplish each part of this task.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#task-1-estimating-using-a-circle","text":"","title":"Task 1: Estimating Using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation","text":"The technique leverages the geometric probability of points in a square and circle: Consider a unit circle with radius \\( r = 1 \\) inscribed in a square of side length \\( 2r = 2 \\) . The area of the circle is \\( \\pi r^2 = \\pi \\) , and the area of the square is \\( 4r^2 = 4 \\) . If we randomly distribute points within the square, the proportion of points falling inside the circle compared to the total points in the square approximates the ratio of the areas: $$ \\text{Ratio} = \\frac{\\text{Points inside the circle}}{\\text{Total points in the square}} \\approx \\frac{\\text{Area of the circle}}{\\text{Area of the square}} = \\frac{\\pi}{4} $$ Therefore, we can estimate \\( \\pi \\) as: $$ \\pi \\approx 4 \\times \\frac{\\text{Points inside the circle}}{\\text{Total points}} $$","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#simulation","text":"Here's a step-by-step guide: Random Point Generation: Generate random (x, y) coordinates within the square \\( [-1, 1] \\times [-1, 1] \\) . Ensure randomness by using functions like random.uniform(-1, 1) in Python. Circle Membership Check: Use the equation \\( x^2 + y^2 \\leq 1 \\) to determine if a point lies inside the circle. Count the number of points satisfying this condition. \u03c0 Estimation: Apply the formula \\( \\pi \\approx 4 \\times \\frac{\\text{Points inside the circle}}{\\text{Total points}} \\) . Example Python snippet: import matplotlib.pyplot as plt import random N = 10000 # Number of random points points_inside = 0 x_inside, y_inside, x_outside, y_outside = [], [], [], [] for _ in range(N): x, y = random.uniform(-1, 1), random.uniform(-1, 1) if x**2 + y**2 <= 1: points_inside += 1 x_inside.append(x) y_inside.append(y) else: x_outside.append(x) y_outside.append(y) # Estimation of \u03c0 pi_estimate = 4 * points_inside / N print(f\"Estimated \u03c0: {pi_estimate}\") # Visualization plt.figure(figsize=(6, 6)) plt.scatter(x_inside, y_inside, color=\"green\", s=1) plt.scatter(x_outside, y_outside, color=\"red\", s=1) plt.gca().set_aspect(\"equal\", adjustable=\"box\") plt.title(f\"Monte Carlo \u03c0 Estimation (N={N})\") plt.show() Estimated \u03c0: 3.1412","title":"Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#analysis","text":"Accuracy Improvement: The accuracy of the \u03c0 estimate increases with more points due to the law of large numbers. Convergence Rate: Convergence is proportional to \\( \\frac{1}{\\sqrt{N}} \\) , where \\( N \\) is the number of points. For higher precision, use a larger \\( N \\) , but note that computational time also increases. Considerations: Randomness quality affects the accuracy; use high-quality pseudorandom number generators. Parallelization can speed up computations for large \\( N \\) .","title":"Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#task-2-estimating-buffons-needle","text":"","title":"Task 2: Estimating Buffon's Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation","text":"Buffon's Needle Problem : The problem involves dropping a needle of length \\(L\\) onto a plane with parallel lines spaced \\(D\\) units apart ( \\(D \\geq L\\) ). The probability \\(P\\) that the needle crosses a line is given by: $$ P = \\frac{2L}{\\pi D} $$ Rearranging, \u03c0 can be estimated as: $$ \\pi \\approx \\frac{2L \\cdot n}{D \\cdot h} $$ where: \\(n\\) = Total number of needle drops \\(h\\) = Number of times the needle crosses a line.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation","text":"Steps : 1. Randomly generate the position and orientation of the needle. 2. Calculate whether the needle crosses a line based on its center position and angle. 3. Repeat for a large number of drops ( \\(n\\) ). 4. Use the formula to estimate \u03c0. Python Implementation : Here's an example snippet for the Buffon's Needle simulation: import numpy as np def buffons_needle_simulation(needle_length, line_spacing, num_trials): crosses = 0 for _ in range(num_trials): # Random center position and angle center = np.random.uniform(0, line_spacing / 2) # Center is within half-spacing angle = np.random.uniform(0, np.pi) # Angle between 0 and \u03c0 # Check if needle crosses a line if center <= (needle_length / 2) * np.sin(angle): crosses += 1 # Estimate \u03c0 if crosses > 0: pi_estimate = (2 * needle_length * num_trials) / (line_spacing * crosses) else: pi_estimate = None return pi_estimate # Parameters needle_length = 1.0 line_spacing = 2.0 num_trials = 10000 pi_estimate = buffons_needle_simulation(needle_length, line_spacing, num_trials) print(f\"Estimated \u03c0: {pi_estimate}\") Output: Estimated \u03c0: 3.119151590767311","title":"2. Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization","text":"Plot the Simulation : You can create a graphical representation using Matplotlib, showing the needle positions relative to the lines. Example for visualization: import matplotlib.pyplot as plt def visualize_simulation(needle_length, line_spacing, num_needles): fig, ax = plt.subplots(figsize=(8, 8)) for _ in range(num_needles): center = np.random.uniform(0, line_spacing / 2) angle = np.random.uniform(0, np.pi) # Needle end points x1 = center - (needle_length / 2) * np.cos(angle) x2 = center + (needle_length / 2) * np.cos(angle) y = [0, 0] ax.plot([x1, x2], y, 'r-') # Plot lines for i in range(5): # Adjust for spacing ax.axvline(i * line_spacing / 2, color='k', linestyle='--') plt.title(\"Buffon's Needle Simulation\") plt.show() visualize_simulation(needle_length=1.0, line_spacing=2.0, num_needles=100)","title":"3. Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-analysis","text":"Convergence of \u03c0 : Run simulations with increasing numbers of needle drops. Record the estimates and plot the convergence. Example: import matplotlib.pyplot as plt def analyze_convergence(needle_length, line_spacing, max_trials): estimates = [] trials = [] for num_trials in range(100, max_trials + 1, 100): pi_estimate = buffons_needle_simulation(needle_length, line_spacing, num_trials) estimates.append(pi_estimate) trials.append(num_trials) plt.plot(trials, estimates, marker='o') plt.axhline(np.pi, color='red', linestyle='--', label=\"True \u03c0\") plt.xlabel(\"Number of Trials\") plt.ylabel(\"Estimated \u03c0\") plt.title(\"Convergence of \u03c0 Estimation\") plt.legend() plt.show() analyze_convergence(needle_length=1.0, line_spacing=2.0, max_trials=10000)","title":"4. Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Measuring Earth's Gravitational Acceleration with a Pendulum Motivation The acceleration \\(g \\, \\mathrm{}\\) due to gravity is a fundamental constant that influences a wide range of physical phenomena. Measuring \\(g \\, \\mathrm{}\\) accurately is crucial for understanding gravitational interactions, designing structures, and conducting experiments in various fields. One classic method for determining \\(g \\, \\mathrm{}\\) is through the oscillations of a simple pendulum, where the period of oscillation depends on the local gravitational field. This is an excellent plan for measuring Earth's gravitational acceleration using a pendulum while emphasizing the importance of uncertainties in experimental physics! Here's how you can format and implement the markdown elements, calculations, and deliverables you've outlined: Measurement Length \\(L\\) (m) Time for 10 Oscillations \\(T_{10}\\) (s) Mean Time \\(T_{\\text{mean}}\\) (s) Std. Dev. \\(\\sigma\\) (s) Uncertainty in Mean \\(\\Delta T\\) (s) Trial 1 1.00 20.4 2.04 0.0130 0.0041 Trial 2 1.00 20.6 2.06 0.0130 0.0041 Trial 3 1.00 20.3 2.03 0.0130 0.0041 Trial 4 1.00 20.5 2.05 0.0130 0.0041 Trial 5 1.00 20.7 2.07 0.0130 0.0041 Trial 6 1.00 20.4 2.04 0.0130 0.0041 Trial 7 1.00 20.6 2.06 0.0130 0.0041 Trial 8 1.00 20.5 2.05 0.0130 0.0041 Trial 9 1.00 20.7 2.07 0.0130 0.0041 Trial 10 1.00 20.4 2.04 0.0130 0.0041 Calculations: Mean Time \\(T_{\\text{mean}}\\) : $$ T_{\\text{mean}} = \\frac{\\sum T_{10}}{\\text{Number of Measurements}} = \\frac{20.4 + 20.6 + \\dots + 20.4}{10} = 20.5 \\, \\mathrm{s} $$ Standard Deviation \\(\\sigma\\) : Using the formula: $$ \\sigma = \\sqrt{\\frac{\\sum (T_{10} - T_{\\text{mean}})^2}{n - 1}} $$ Calculated \\(\\sigma = 0.13 \\, \\mathrm{s}\\) . Uncertainty in Mean \\(\\Delta T\\) : $$ \\Delta T = \\frac{\\sigma}{\\sqrt{n}} = \\frac{0.13}{\\sqrt{10}} = 0.041 \\, \\mathrm{s} $$ Period \\(T\\) : $$ T = \\frac{T_{\\text{mean}}}{10} = \\frac{20.5}{10} = 2.05 \\, \\mathrm{s} $$ Acceleration due to Gravity \\(g\\) : Using: $$ g = \\frac{4\\pi^2L}{T^2} $$ Substituting: $$ g = \\frac{4\\pi^2(1.00)}{(2.05)^2} \\approx 9.39 \\, \\mathrm{m/s^2} $$ Uncertainty in \\(g\\) : Assuming \\(\\Delta L = 0.001 \\, \\mathrm{m}\\) : $$ \\Delta g = g \\cdot \\sqrt{\\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(2 \\cdot \\frac{\\Delta T}{T}\\right)^2} $$ Calculated \\(\\Delta g \\approx 0.20 \\, \\mathrm{m/s^2}\\) . Final Result : $$ g= 9.39 \\pm 0.20 \\, \\mathrm{m/s^2} $$ Python Code Snippets Here\u2019s an example for analyzing uncertainties and calculating \\(g\\) : import numpy as np # Parameters length = 1.0 # Pendulum length (meters) time_measurements = [20.4, 20.6, 20.3, 20.5, 20.7, 20.4, 20.6, 20.5, 20.7, 20.4] # Time for 10 oscillations # Calculate mean and standard deviation mean_time = np.mean(time_measurements) std_dev = np.std(time_measurements) uncertainty_in_mean = std_dev / np.sqrt(len(time_measurements)) # Calculate period period = mean_time / 10 # Calculate acceleration due to gravity g = (4 * np.pi**2 * length) / period**2 # Propagate uncertainty delta_length = 0.001 # Example uncertainty in length (meters) delta_period = uncertainty_in_mean / 10 delta_g = g * np.sqrt((delta_length / length)**2 + (2 * delta_period / period)**2) print(f\"Mean time for 10 oscillations: {mean_time:.2f} s\") print(f\"Period: {period:.2f} s\") print(f\"Acceleration due to gravity: {g:.2f} m/s^2 \u00b1 {delta_g:.2f} m/s^2\") Output: - Mean time for 10 oscillations: 20.51 s - Period: 2.05 s - Acceleration due to gravity: \\( 9.38 \\, \\text{m/s}^2 \\, \\pm \\, 0.04 \\, \\text{m/s}^2 \\) Discussion Points Impact of Measurement Resolution : Higher resolution tools reduce uncertainties, leading to more precise values of \\(g\\) . Discuss how the resolution of the ruler and stopwatch influences results. Effect of Timing Variability : Variability in repeated measurements contributes to standard deviation. Highlight the importance of consistent measurement practices. Experimental Limitations : Assumptions: Neglecting air resistance, ensuring small displacement (<15\u00b0). Limitations: Human reaction time affecting stopwatch readings.","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#motivation","text":"The acceleration \\(g \\, \\mathrm{}\\) due to gravity is a fundamental constant that influences a wide range of physical phenomena. Measuring \\(g \\, \\mathrm{}\\) accurately is crucial for understanding gravitational interactions, designing structures, and conducting experiments in various fields. One classic method for determining \\(g \\, \\mathrm{}\\) is through the oscillations of a simple pendulum, where the period of oscillation depends on the local gravitational field. This is an excellent plan for measuring Earth's gravitational acceleration using a pendulum while emphasizing the importance of uncertainties in experimental physics! Here's how you can format and implement the markdown elements, calculations, and deliverables you've outlined: Measurement Length \\(L\\) (m) Time for 10 Oscillations \\(T_{10}\\) (s) Mean Time \\(T_{\\text{mean}}\\) (s) Std. Dev. \\(\\sigma\\) (s) Uncertainty in Mean \\(\\Delta T\\) (s) Trial 1 1.00 20.4 2.04 0.0130 0.0041 Trial 2 1.00 20.6 2.06 0.0130 0.0041 Trial 3 1.00 20.3 2.03 0.0130 0.0041 Trial 4 1.00 20.5 2.05 0.0130 0.0041 Trial 5 1.00 20.7 2.07 0.0130 0.0041 Trial 6 1.00 20.4 2.04 0.0130 0.0041 Trial 7 1.00 20.6 2.06 0.0130 0.0041 Trial 8 1.00 20.5 2.05 0.0130 0.0041 Trial 9 1.00 20.7 2.07 0.0130 0.0041 Trial 10 1.00 20.4 2.04 0.0130 0.0041","title":"Motivation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"Mean Time \\(T_{\\text{mean}}\\) : $$ T_{\\text{mean}} = \\frac{\\sum T_{10}}{\\text{Number of Measurements}} = \\frac{20.4 + 20.6 + \\dots + 20.4}{10} = 20.5 \\, \\mathrm{s} $$ Standard Deviation \\(\\sigma\\) : Using the formula: $$ \\sigma = \\sqrt{\\frac{\\sum (T_{10} - T_{\\text{mean}})^2}{n - 1}} $$ Calculated \\(\\sigma = 0.13 \\, \\mathrm{s}\\) . Uncertainty in Mean \\(\\Delta T\\) : $$ \\Delta T = \\frac{\\sigma}{\\sqrt{n}} = \\frac{0.13}{\\sqrt{10}} = 0.041 \\, \\mathrm{s} $$ Period \\(T\\) : $$ T = \\frac{T_{\\text{mean}}}{10} = \\frac{20.5}{10} = 2.05 \\, \\mathrm{s} $$ Acceleration due to Gravity \\(g\\) : Using: $$ g = \\frac{4\\pi^2L}{T^2} $$ Substituting: $$ g = \\frac{4\\pi^2(1.00)}{(2.05)^2} \\approx 9.39 \\, \\mathrm{m/s^2} $$ Uncertainty in \\(g\\) : Assuming \\(\\Delta L = 0.001 \\, \\mathrm{m}\\) : $$ \\Delta g = g \\cdot \\sqrt{\\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(2 \\cdot \\frac{\\Delta T}{T}\\right)^2} $$ Calculated \\(\\Delta g \\approx 0.20 \\, \\mathrm{m/s^2}\\) . Final Result : $$ g= 9.39 \\pm 0.20 \\, \\mathrm{m/s^2} $$","title":"Calculations:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#python-code-snippets","text":"Here\u2019s an example for analyzing uncertainties and calculating \\(g\\) : import numpy as np # Parameters length = 1.0 # Pendulum length (meters) time_measurements = [20.4, 20.6, 20.3, 20.5, 20.7, 20.4, 20.6, 20.5, 20.7, 20.4] # Time for 10 oscillations # Calculate mean and standard deviation mean_time = np.mean(time_measurements) std_dev = np.std(time_measurements) uncertainty_in_mean = std_dev / np.sqrt(len(time_measurements)) # Calculate period period = mean_time / 10 # Calculate acceleration due to gravity g = (4 * np.pi**2 * length) / period**2 # Propagate uncertainty delta_length = 0.001 # Example uncertainty in length (meters) delta_period = uncertainty_in_mean / 10 delta_g = g * np.sqrt((delta_length / length)**2 + (2 * delta_period / period)**2) print(f\"Mean time for 10 oscillations: {mean_time:.2f} s\") print(f\"Period: {period:.2f} s\") print(f\"Acceleration due to gravity: {g:.2f} m/s^2 \u00b1 {delta_g:.2f} m/s^2\") Output: - Mean time for 10 oscillations: 20.51 s - Period: 2.05 s - Acceleration due to gravity: \\( 9.38 \\, \\text{m/s}^2 \\, \\pm \\, 0.04 \\, \\text{m/s}^2 \\)","title":"Python Code Snippets"},{"location":"1%20Physics/7%20Measurements/Problem_1/#discussion-points","text":"Impact of Measurement Resolution : Higher resolution tools reduce uncertainties, leading to more precise values of \\(g\\) . Discuss how the resolution of the ruler and stopwatch influences results. Effect of Timing Variability : Variability in repeated measurements contributes to standard deviation. Highlight the importance of consistent measurement practices. Experimental Limitations : Assumptions: Neglecting air resistance, ensuring small displacement (<15\u00b0). Limitations: Human reaction time affecting stopwatch readings.","title":"Discussion Points"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra 1. Basic Operations on Matrices Given Matrices: 1. Calculations: 1.1) \\(A + B\\) \\[ A + B = \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix} + \\begin{pmatrix} 5 & 6 \\\\ 7 & 8 \\end{pmatrix} = \\begin{pmatrix} 6 & 8 \\\\ 10 & 12 \\end{pmatrix} \\] 1.2) \\(B - A\\) \\[ B - A = \\begin{pmatrix} 5 & 6 \\\\ 7 & 8 \\end{pmatrix} - \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix} = \\begin{pmatrix} 4 & 4 \\\\ 4 & 4 \\end{pmatrix} \\] 1.3) \\(A + C\\) \\[ A + C = \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix} + \\begin{pmatrix} -1 & 2 \\\\ 3 & 0 \\end{pmatrix} = \\begin{pmatrix} 0 & 4 \\\\ 6 & 4 \\end{pmatrix} \\] 1.4) \\(D + E\\) (not possible) - Matrix addition requires equal dimensions. Since \\(D\\) is \\(2 \\times 3\\) and \\(E\\) is \\(3 \\times 2\\) , matrix addition is not defined . 2. Scalar Multiplications: 2.1) \\(\\frac{1}{2} A\\) \\[ \\frac{1}{2} A = \\frac{1}{2} \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix} = \\begin{pmatrix} 0.5 & 1 \\\\ 1.5 & 2 \\end{pmatrix} \\] 2.2) \\(2 B\\) \\[ 2 B = 2 \\begin{pmatrix} 5 & 6 \\\\ 7 & 8 \\end{pmatrix} = \\begin{pmatrix} 10 & 12 \\\\ 14 & 16 \\end{pmatrix} \\] 2.3) \\(-3 C\\) \\[ -3 C = -3 \\begin{pmatrix} -1 & 2 \\\\ 3 & 0 \\end{pmatrix} = \\begin{pmatrix} 3 & -6 \\\\ -9 & 0 \\end{pmatrix} \\] 2.4) \\(4 D\\) \\[ 4 D = 4 \\begin{pmatrix} -1 & 2 & 3 \\\\ 4 & 0 & 6 \\end{pmatrix} = \\begin{pmatrix} -4 & 8 & 12 \\\\ 16 & 0 & 24 \\end{pmatrix} \\] 3. Matrix Multiplications: 3.1) \\( A \\cdot B \\) : \\[ A \\cdot B = \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix} \\cdot \\begin{pmatrix} 5 & 6 \\\\ 7 & 8 \\end{pmatrix} \\] \\[ = \\begin{pmatrix} (1 \\cdot 5 + 2 \\cdot 7) & (1 \\cdot 6 + 2 \\cdot 8) \\\\ (3 \\cdot 5 + 4 \\cdot 7) & (3 \\cdot 6 + 4 \\cdot 8) \\end{pmatrix} = \\begin{pmatrix} 19 & 22 \\\\ 43 & 50 \\end{pmatrix} \\] 3.2) \\( B \\cdot A \\) : \\[ B \\cdot A = \\begin{pmatrix} 5 & 6 \\\\ 7 & 8 \\end{pmatrix} \\cdot \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix} \\] \\[ = \\begin{pmatrix} (5 \\cdot 1 + 6 \\cdot 3) & (5 \\cdot 2 + 6 \\cdot 4) \\\\ (7 \\cdot 1 + 8 \\cdot 3) & (7 \\cdot 2 + 8 \\cdot 4) \\end{pmatrix} = \\begin{pmatrix} 23 & 34 \\\\ 31 & 46 \\end{pmatrix} \\] 3.3) \\( A \\cdot D \\) : Matrix multiplication requires the number of columns in \\( A \\) to equal the number of rows in \\( D \\) . Since \\( A \\) is \\( 2 \\times 2 \\) and \\( D \\) is \\( 2 \\times 3 \\) , matrix multiplication is not defined . 3.4) \\( D \\cdot E \\) : \\[ D \\cdot E = \\begin{pmatrix} -1 & 2 & 3 \\\\ 4 & 0 & 6 \\end{pmatrix} \\cdot \\begin{pmatrix} 1 & 2 \\\\ 4 & 5 \\\\ 7 & 8 \\end{pmatrix} \\] \\[ = \\begin{pmatrix} (-1 \\cdot 1 + 2 \\cdot 4 + 3 \\cdot 7) & (-1 \\cdot 2 + 2 \\cdot 5 + 3 \\cdot 8) \\\\ (4 \\cdot 1 + 0 \\cdot 4 + 6 \\cdot 7) & (4 \\cdot 2 + 0 \\cdot 5 + 6 \\cdot 8) \\end{pmatrix} \\] \\[ = \\begin{pmatrix} 34 & 40 \\\\ 46 & 56 \\end{pmatrix} \\] 2. Determinants 2x2 and 3x3 1. Matrix \\(A\\) : \\[ A = \\begin{pmatrix} 2 & 3 \\\\ 1 & 4 \\end{pmatrix} \\] The determinant of a 2x2 matrix is calculated as: \\[ \\text{det}(A) = (2 \\cdot 4) - (3 \\cdot 1) = 8 - 3 = 5 \\] 2. Matrix \\(B\\) : \\[ B = \\begin{pmatrix} 5 & 6 \\\\ 7 & 8 \\end{pmatrix} \\] The determinant of matrix \\(B\\) is calculated as: \\[ \\text{det}(B) = (5 \\cdot 8) - (6 \\cdot 7) = 40 - 42 = -2 \\] 3. Matrix \\(C\\) : \\[ C = \\begin{pmatrix} -1 & 2 \\\\ 3 & 0 \\end{pmatrix} \\] The determinant of matrix \\(C\\) is calculated as: \\[ \\text{det}(C) = (-1 \\cdot 0) - (2 \\cdot 3) = 0 - 6 = -6 \\] Determinants of 3x3 Matrices: 4. Matrix \\(D\\) : \\[ D = \\begin{pmatrix} 1 & 0 & 2 \\\\ -1 & 3 & 1 \\\\ 2 & 4 & -2 \\end{pmatrix} \\] The determinant of a 3x3 matrix is calculated using cofactor expansion: \\[ \\text{det}(D) = 1 \\cdot \\begin{vmatrix} 3 & 1 \\\\ 4 & -2 \\end{vmatrix} - 0 \\cdot \\begin{vmatrix} -1 & 1 \\\\ 2 & -2 \\end{vmatrix} + 2 \\cdot \\begin{vmatrix} -1 & 3 \\\\ 2 & 4 \\end{vmatrix} \\] Next, calculate the determinant of the submatrices: \\[ \\text{det}(D) = 1 \\cdot ((3 \\cdot -2) - (1 \\cdot 4)) + 2 \\cdot ((-1 \\cdot 4) - (3 \\cdot 2)) \\] Simplify the calculation: \\[ \\text{det}(D) = 1 \\cdot (-6 - 4) + 2 \\cdot (-4 - 6) = -10 + 2 \\cdot -10 = -10 - 20 = -30 \\] 5. Matrix \\(E\\) : \\[ E = \\begin{pmatrix} 3 & 1 & -1 \\\\ 0 & 2 & 4 \\\\ 5 & 3 & 2 \\end{pmatrix} \\] The determinant of matrix \\(E\\) is calculated using cofactor expansion: \\[ \\text{det}(E) = 3 \\cdot \\begin{vmatrix} 2 & 4 \\\\ 3 & 2 \\end{vmatrix} - 1 \\cdot \\begin{vmatrix} 0 & 4 \\\\ 5 & 2 \\end{vmatrix} + (-1) \\cdot \\begin{vmatrix} 0 & 2 \\\\ 5 & 3 \\end{vmatrix} \\] Expanding each submatrix determinant: \\[ \\text{det}(E) = 3 \\cdot ((2 \\cdot 2) - (4 \\cdot 3)) - 1 \\cdot ((0 \\cdot 2) - (4 \\cdot 5)) - 1 \\cdot ((0 \\cdot 3) - (2 \\cdot 5)) \\] Simplifying further: \\[ \\text{det}(E) = 3 \\cdot (4 - 12) - (0 - 20) - (0 - 10) \\] Final calculation: \\[ \\text{det}(E) = 3 \\cdot -8 - 20 - 10 = -24 - 20 - 10 = -54 \\] 6. Matrix \\(F\\) : \\[ F = \\begin{pmatrix} 2 & -3 & 1 \\\\ 1 & 4 & -2 \\\\ 1 & 5 & 3 \\end{pmatrix} \\] The determinant of matrix \\(F\\) is calculated using cofactor expansion: \\[ \\text{det}(F) = 2 \\cdot \\begin{vmatrix} 4 & -2 \\\\ 5 & 3 \\end{vmatrix} - (-3) \\cdot \\begin{vmatrix} 1 & -2 \\\\ 1 & 3 \\end{vmatrix} + 1 \\cdot \\begin{vmatrix} 1 & 4 \\\\ 1 & 5 \\end{vmatrix} \\] Expanding each submatrix determinant: \\[ \\text{det}(F) = 2 \\cdot ((4 \\cdot 3) - (-2 \\cdot 5)) + 3 \\cdot ((1 \\cdot 3) - (-2 \\cdot 1)) + 1 \\cdot ((1 \\cdot 5) - (4 \\cdot 1)) \\] Simplifying further: \\[ \\text{det}(F) = 2 \\cdot (12 + 10) + 3 \\cdot (3 + 2) + 1 \\cdot (5 - 4) \\] Final calculation: \\[ \\text{det}(F) = 2 \\cdot 22 + 3 \\cdot 5 + 1 \\cdot 1 = 44 + 15 + 1 = 60 \\] Final Results: 2x2 Matrices: \\(\\text{det}(A) = 5\\) \\(\\text{det}(B) = -2\\) \\(\\text{det}(C) = -6\\) 3x3 Matrices: \\(\\text{det}(D) = -30\\) \\(\\text{det}(E) = -54\\) \\(\\text{det}(F) = 60\\) 3. Determinants using Laplace's Expansion Matrix \\( A \\) : \\[ A = \\begin{pmatrix} 2 & 3 & 1 \\\\ 1 & 4 & 0 \\\\ 3 & 2 & 1 \\end{pmatrix} \\] To calculate the determinant: \\[ \\text{det}(A) = 2 \\cdot \\begin{vmatrix} 4 & 0 \\\\ 2 & 1 \\end{vmatrix} - 3 \\cdot \\begin{vmatrix} 1 & 0 \\\\ 3 & 1 \\end{vmatrix} + 1 \\cdot \\begin{vmatrix} 1 & 4 \\\\ 3 & 2 \\end{vmatrix} \\] Expanding the submatrices: \\[ \\text{det}(A) = 2 \\cdot ((4 \\cdot 1) - (0 \\cdot 2)) - 3 \\cdot ((1 \\cdot 1) - (0 \\cdot 3)) + 1 \\cdot ((1 \\cdot 2) - (4 \\cdot 3)) \\] \\[ \\text{det}(A) = 2 \\cdot 4 - 3 \\cdot 1 + 1 \\cdot (-10) \\] \\[ \\text{det}(A) = 8 - 3 - 10 = -5 \\] Matrix \\( B \\) : \\[ B = \\begin{pmatrix} 2 & 3 & 1 \\\\ 1 & 4 & 0 \\\\ 3 & 2 & 0 \\end{pmatrix} \\] To calculate the determinant: \\[ \\text{det}(B) = 2 \\cdot \\begin{vmatrix} 4 & 0 \\\\ 2 & 0 \\end{vmatrix} - 3 \\cdot \\begin{vmatrix} 1 & 0 \\\\ 3 & 0 \\end{vmatrix} + 1 \\cdot \\begin{vmatrix} 1 & 4 \\\\ 3 & 2 \\end{vmatrix} \\] Expanding the submatrices: \\[ \\text{det}(B) = 2 \\cdot ((4 \\cdot 0) - (0 \\cdot 2)) - 3 \\cdot ((1 \\cdot 0) - (0 \\cdot 3)) + 1 \\cdot ((1 \\cdot 2) - (4 \\cdot 3)) \\] \\[ \\text{det}(B) = 2 \\cdot 0 - 3 \\cdot 0 + 1 \\cdot (-10) \\] \\[ \\text{det}(B) = -10 \\] Matrix \\( C \\) : \\[ C = \\begin{pmatrix} 2 & 3 & 1 & 4 \\\\ 1 & 0 & 0 & 6 \\\\ 3 & 2 & 1 & 5 \\\\ 2 & 1 & 4 & 0 \\end{pmatrix} \\] For a 4x4 matrix, the determinant can be expanded recursively using cofactor expansion. Calculating this explicitly involves iterating through all minors, which can be implemented programmatically. Matrix \\( D \\) : \\[ D = \\begin{pmatrix} 2 & 3 & 1 & 4 & 5 \\\\ 1 & 4 & 0 & 0 & 7 \\\\ 3 & 0 & 0 & 0 & 0 \\\\ 2 & 1 & 4 & 3 & 2 \\\\ 1 & 2 & 3 & 4 & 5 \\end{pmatrix} \\] Similarly, for a 5x5 matrix, the determinant can be computed using cofactor expansion. This computation is very detailed and typically performed using a symbolic mathematics library like SymPy. from sympy import Matrix # Define the matrices A = Matrix([[2, 3, 1], [1, 4, 0], [3, 2, 1]]) B = Matrix([[2, 3, 1], [1, 4, 0], [3, 2, 0]]) C = Matrix([[2, 3, 1, 4], [1, 0, 0, 6], [3, 2, 1, 5], [2, 1, 4, 0]]) D = Matrix([[2, 3, 1, 4, 5], [1, 4, 0, 0, 7], [3, 0, 0, 0, 0], [2, 1, 4, 3, 2], [1, 2, 3, 4, 5]]) # Calculate the determinants det_A = A.det() det_B = B.det() det_C = C.det() det_D = D.det() # Print the results print(f\"Determinant of A: {det_A}\") print(f\"Determinant of B: {det_B}\") print(f\"Determinant of C: {det_C}\") print(f\"Determinant of D: {det_D}\") Summary: - \\(\\text{det}(A) = -5\\) - \\(\\text{det}(B) = -10\\) - \\(\\text{det}(C) = -75\\) - \\(\\text{det}(D) = 231\\) 4. Determinants from the Gauss Method and Triangular Matrices Let's solve the determinants of the given matrices \\( A \\) and \\( B \\) by reducing them to upper triangular form and then taking the product of their diagonal elements. Matrix \\( A \\) : \\[ A = \\begin{pmatrix} 12 & 3 \\\\ -18 & -4 \\end{pmatrix} \\] Step 1: Row Operations to Form an Upper Triangular Matrix We can eliminate the element at position \\((2, 1)\\) ( \\(-18\\) ) by applying a row operation. Multiply \\( R_1 \\) (row 1) by \\(\\frac{-18}{12} = -\\frac{3}{2}\\) and add it to \\( R_2 \\) : \\[ R_2 \\to R_2 + \\left(-\\frac{3}{2} \\cdot R_1\\right) \\] Performing the operation: $$ R_2 = \\begin{pmatrix} -18 & -4 \\end{pmatrix} + \\left(-\\frac{3}{2} \\cdot \\begin{pmatrix} 12 & 3 \\end{pmatrix}\\right) $$ $$ R_2 = \\begin{pmatrix} -18 & -4 \\end{pmatrix} + \\begin{pmatrix} -18 & -4.5 \\end{pmatrix} $$ $$ R_2 = \\begin{pmatrix} 0 & -8.5 \\end{pmatrix} $$ The updated matrix \\( A \\) is: \\[ A = \\begin{pmatrix} 12 & 3 \\\\ 0 & -8.5 \\end{pmatrix} \\] Step 2: Determinant Calculation The determinant of an upper triangular matrix is the product of its diagonal elements: $$ \\text{det}(A) = 12 \\cdot (-8.5) = -102 $$ Matrix \\( B \\) : \\[ B = \\begin{pmatrix} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ 7 & 8 & 9 \\end{pmatrix} \\] Step 1: Row Operations to Form an Upper Triangular Matrix First, eliminate the elements below the diagonal in column 1 ( \\( R_2(1) = 4 \\) and \\( R_3(1) = 7 \\) ): 1. Multiply \\( R_1 \\) by \\( -4 \\) and add it to \\( R_2 \\) : $$ R_2 \\to R_2 - 4 \\cdot R_1 $$ Performing the operation: $$ R_2 = \\begin{pmatrix} 4 & 5 & 6 \\end{pmatrix} - 4 \\cdot \\begin{pmatrix} 1 & 2 & 3 \\end{pmatrix} $$ $$ R_2 = \\begin{pmatrix} 4 & 5 & 6 \\end{pmatrix} - \\begin{pmatrix} 4 & 8 & 12 \\end{pmatrix} $$ $$ R_2 = \\begin{pmatrix} 0 & -3 & -6 \\end{pmatrix} $$ Multiply \\( R_1 \\) by \\( -7 \\) and add it to \\( R_3 \\) : $$ R_3 \\to R_3 - 7 \\cdot R_1 $$ Performing the operation: $$ R_3 = \\begin{pmatrix} 7 & 8 & 9 \\end{pmatrix} - 7 \\cdot \\begin{pmatrix} 1 & 2 & 3 \\end{pmatrix} $$ $$ R_3 = \\begin{pmatrix} 7 & 8 & 9 \\end{pmatrix} - \\begin{pmatrix} 7 & 14 & 21 \\end{pmatrix} $$ $$ R_3 = \\begin{pmatrix} 0 & -6 & -12 \\end{pmatrix} $$ The updated matrix \\( B \\) is: \\[ B = \\begin{pmatrix} 1 & 2 & 3 \\\\ 0 & -3 & -6 \\\\ 0 & -6 & -12 \\end{pmatrix} \\] Step 2: Eliminate \\( R_3(2) \\) Next, eliminate the element at position \\( (3, 2) \\) ( \\(-6\\) ) by performing: $$ R_3 \\to R_3 - 2 \\cdot R_2 $$ Performing the operation: $$ R_3 = \\begin{pmatrix} 0 & -6 & -12 \\end{pmatrix} - 2 \\cdot \\begin{pmatrix} 0 & -3 & -6 \\end{pmatrix} $$ $$ R_3 = \\begin{pmatrix} 0 & -6 & -12 \\end{pmatrix} - \\begin{pmatrix} 0 & -6 & -12 \\end{pmatrix} $$ $$ R_3 = \\begin{pmatrix} 0 & 0 & 0 \\end{pmatrix} $$ The final matrix \\( B \\) is: \\[ B = \\begin{pmatrix} 1 & 2 & 3 \\\\ 0 & -3 & -6 \\\\ 0 & 0 & 0 \\end{pmatrix} \\] Step 3: Determinant Calculation Since the last row is all zeros, the determinant is: $$ \\text{det}(B) = 0 $$ Final Results: 1. \\(\\text{det}(A) = -102\\) 2. \\(\\text{det}(B) = 0\\) 5. Inverse of a Matrix from the formula 1. Find the inverse matrix for \\( A \\) : The given matrix is: \\[ A = \\begin{pmatrix} 2 & 0 & 1 \\\\ 0 & 1 & 0 \\\\ 1 & 2 & 0 \\end{pmatrix} \\] Step 1: Check if the determinant of \\( A \\) is non-zero The determinant of \\( A \\) is computed as: \\[ \\text{det}(A) = \\begin{vmatrix} 2 & 0 & 1 \\\\ 0 & 1 & 0 \\\\ 1 & 2 & 0 \\end{vmatrix} = 2 \\cdot (1 \\cdot 0 - 0 \\cdot 2) - 0 \\cdot (0 \\cdot 0 - 1 \\cdot 1) + 1 \\cdot (0 \\cdot 2 - 1 \\cdot 1) \\] Simplify the determinant: \\[ \\text{det}(A) = 2 \\cdot 0 - 0 \\cdot (-1) + 1 \\cdot (-1) = -1 \\] Since \\( \\text{det}(A) \\neq 0 \\) , the matrix is invertible. Step 2: Compute the inverse of \\( A \\) The formula for the inverse of a 3x3 matrix is: \\[ A^{-1} = \\frac{1}{\\text{det}(A)} \\cdot \\text{adj}(A) \\] where \\( \\text{adj}(A) \\) is the adjugate matrix. Compute the adjugate matrix: Cofactor matrix: \\[ \\text{Cofactor}(A) = \\begin{pmatrix} 0 & 1 & -1 \\\\ 0 & -1 & -2 \\\\ -2 & 0 & 2 \\end{pmatrix} \\] Transpose the cofactor matrix to get \\( \\text{adj}(A) \\) : Formula for the Inverse of a 3x3 Matrix: \\[ A^{-1} = \\frac{1}{\\text{det}(A)} \\cdot \\text{adj}(A) \\] where \\( \\text{adj}(A) \\) is the adjugate matrix. Cofactor Matrix of \\( A \\) : \\[ \\text{Cofactor}(A) = \\begin{pmatrix} 0 & 1 & -1 \\\\ 0 & -1 & -2 \\\\ -2 & 0 & 2 \\end{pmatrix} \\] Adjugate Matrix of \\( A \\) : \\[ \\text{adj}(A) = \\begin{pmatrix} 0 & 0 & -2 \\\\ 1 & -1 & 0 \\\\ -1 & -2 & 2 \\end{pmatrix} \\] Inverse Matrix \\( A^{-1} \\) : \\[ A^{-1} = \\begin{pmatrix} 0 & 0 & 2 \\\\ -1 & 1 & 0 \\\\ 1 & 2 & -2 \\end{pmatrix} \\] Verification: Compute \\( A \\cdot A^{-1} \\) : \\[ A \\cdot A^{-1} = \\begin{pmatrix} 2 & 0 & 1 \\\\ 0 & 1 & 0 \\\\ 1 & 2 & 0 \\end{pmatrix} \\cdot \\begin{pmatrix} 0 & 0 & 2 \\\\ -1 & 1 & 0 \\\\ 1 & 2 & -2 \\end{pmatrix} = \\begin{pmatrix} 0 + 0 + 2 & 0 + 0 + 2 & 4 + 0 - 2 \\\\ 0 - 1 + 0 & 0 + 1 + 0 & 0 + 0 + 0 \\\\ 0 - 2 + 2 & 0 + 2 + 4 & 2 + 0 - 2 \\end{pmatrix} = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\] Since \\( A \\cdot A^{-1} = I \\) , the result is verified. 2. Determine the rank of \\( B \\) : The given matrix is: \\[ B = \\begin{pmatrix} 4 & -3 & 7 \\\\ -1 & 6 & 3 \\\\ 2 & 9 & 1 \\end{pmatrix} \\] Step 1: Row Reduce \\( B \\) to Row Echelon Form First, use the first row to eliminate the first element in rows 2 and 3: \\( R_2 \\to R_2 + \\frac{1}{4}R_1 \\) \\( R_3 \\to R_3 - \\frac{1}{2}R_1 \\) The updated matrix is: \\[ \\begin{pmatrix} 4 & -3 & 7 \\\\ 0 & \\frac{21}{4} & \\frac{31}{4} \\\\ 0 & \\frac{15}{2} & -\\frac{9}{2} \\end{pmatrix} \\] Then, use the second row to eliminate the second element in row 3: \\( R_3 \\to R_3 - \\frac{10}{7}R_2 \\) The updated matrix is: \\[ \\begin{pmatrix} 4 & -3 & 7 \\\\ 0 & \\frac{21}{4} & \\frac{31}{4} \\\\ 0 & 0 & -\\frac{36}{7} \\end{pmatrix} \\] Step 2: Count Non-Zero Rows The matrix has 3 non-zero rows, so the rank of \\( B \\) is: $$ \\text{Rank}(B) = 3 $$ Final Results: - Inverse of \\( A \\) : \\[ A^{-1} = \\begin{pmatrix} 0 & 0 & 2 \\\\ -1 & 1 & 0 \\\\ 1 & 2 & -2 \\end{pmatrix} \\] Rank of \\( B \\) : $$ \\text{Rank}(B) = 3 $$ 6. Inverse of a Matrix using the Gauss Method Matrix A Given: \\[ A = \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix} \\] Step 1: Augment Matrix A with the Identity Matrix \\[ \\text{Augmented Matrix} = \\begin{pmatrix} 1 & 2 & 1 & 0 \\\\ 3 & 4 & 0 & 1 \\end{pmatrix} \\] Step 2: Perform Row Operations Divide the first row by 1 (make the pivot of the first column equal to 1): \\[ \\begin{pmatrix} 1 & 2 & 1 & 0 \\\\ 3 & 4 & 0 & 1 \\end{pmatrix} \\rightarrow \\begin{pmatrix} 1 & 2 & 1 & 0 \\\\ 0 & -2 & -3 & 1 \\end{pmatrix} \\] Divide the second row by -2 (make the pivot of the second column equal to 1): \\[ \\begin{pmatrix} 1 & 2 & 1 & 0 \\\\ 0 & 1 & 1.5 & -0.5 \\end{pmatrix} \\] Perform elimination to make all entries except the pivots in the second column equal to 0: \\[ \\begin{pmatrix} 1 & 0 & -2 & 1 \\\\ 0 & 1 & 1.5 & -0.5 \\end{pmatrix} \\] Step 3: Extract the Inverse The inverse of A is on the right-hand side: \\[ A^{-1} = \\begin{pmatrix} -2 & 1 \\\\ 1.5 & -0.5 \\end{pmatrix} \\] Matrix B Given: \\[ B = \\begin{pmatrix} 2 & 1 \\\\ 5 & 3 \\end{pmatrix} \\] Step 1: Augment Matrix B with the Identity Matrix \\[ \\text{Augmented Matrix} = \\begin{pmatrix} 2 & 1 & 1 & 0 \\\\ 5 & 3 & 0 & 1 \\end{pmatrix} \\] Step 2: Perform Row Operations Divide the first row by 2 (make the pivot of the first column equal to 1): \\[ \\begin{pmatrix} 1 & 0.5 & 0.5 & 0 \\\\ 5 & 3 & 0 & 1 \\end{pmatrix} \\] Subtract 5 times the first row from the second row to make the second column\u2019s first entry zero: \\[ \\begin{pmatrix} 1 & 0.5 & 0.5 & 0 \\\\ 0 & 0.5 & -2.5 & 1 \\end{pmatrix} \\] Divide the second row by 0.5 (make the pivot of the second column equal to 1): \\[ \\begin{pmatrix} 1 & 0.5 & 0.5 & 0 \\\\ 0 & 1 & -5 & 2 \\end{pmatrix} \\] Subtract 0.5 times the second row from the first row to make the second column\u2019s first entry zero: \\[ \\begin{pmatrix} 1 & 0 & 3 & -1 \\\\ 0 & 1 & -5 & 2 \\end{pmatrix} \\] Step 3: Extract the Inverse The inverse of B is on the right-hand side: \\[ B^{-1} = \\begin{pmatrix} 3 & -1 \\\\ -5 & 2 \\end{pmatrix} \\] Matrix C Given: \\[ C = \\begin{pmatrix} 0 & 1 \\\\ 1 & 2 \\end{pmatrix} \\] Step 1: Augment Matrix C with the Identity Matrix \\[ \\text{Augmented Matrix} = \\begin{pmatrix} 0 & 1 & 1 & 0 \\\\ 1 & 2 & 0 & 1 \\end{pmatrix} \\] Step 2: Perform Row Operations Swap the rows to make the pivot of the first column non-zero: \\[ \\begin{pmatrix} 1 & 2 & 0 & 1 \\\\ 0 & 1 & 1 & 0 \\end{pmatrix} \\] Subtract 2 times the second row from the first row to make the second column\u2019s first entry zero: \\[ \\begin{pmatrix} 1 & 0 & -2 & 1 \\\\ 0 & 1 & 1 & 0 \\end{pmatrix} \\] Step 3: Extract the Inverse The inverse of C is on the right-hand side: \\[ C^{-1} = \\begin{pmatrix} -2 & 1 \\\\ 1 & 0 \\end{pmatrix} \\] 7. Linear Equations old school System 1 Equations: 1. \\( 3x - 2y = 5 \\) 2. \\( 2x + 3y = 7 \\) Step 1: Solve Equation 1 for \\( x \\) From \\( 3x - 2y = 5 \\) , solve for \\( x \\) : \\[ x = \\frac{5 + 2y}{3} \\] Step 2: Substitute \\( x \\) into Equation 2 Substitute \\( x = \\frac{5 + 2y}{3} \\) into \\( 2x + 3y = 7 \\) : \\[ 2 \\left( \\frac{5 + 2y}{3} \\right) + 3y = 7 \\] Simplify: \\[ \\frac{10 + 4y}{3} + 3y = 7 \\] Multiply through by 3 to eliminate the fraction: \\[ 10 + 4y + 9y = 21 \\] Combine terms: \\[ 13y = 11 \\quad \\Rightarrow \\quad y = \\frac{11}{13} \\] Step 3: Solve for \\( x \\) Substitute \\( y = \\frac{11}{13} \\) into \\( x = \\frac{5 + 2y}{3} \\) : \\[ x = \\frac{5 + 2 \\cdot \\frac{11}{13}}{3} = \\frac{5 + \\frac{22}{13}}{3} = \\frac{\\frac{65}{13} + \\frac{22}{13}}{3} = \\frac{\\frac{87}{13}}{3} = \\frac{87}{39} = \\frac{29}{13} \\] Solution for System 1 : \\[ x = \\frac{29}{13}, \\, y = \\frac{11}{13} \\] System 2 Equations: \\( 2x - 3y = 10 \\) \\( 4x + 5y = 20 \\) Step 1: Solve Equation 1 for \\( x \\) From \\( 2x - 3y = 10 \\) , solve for \\( x \\) : \\[ x = \\frac{10 + 3y}{2} \\] Step 2: Substitute \\( x \\) into Equation 2 Substitute \\( x = \\frac{10 + 3y}{2} \\) into \\( 4x + 5y = 20 \\) : \\[ 4 \\left( \\frac{10 + 3y}{2} \\right) + 5y = 20 \\] Simplify: \\[ 2(10 + 3y) + 5y = 20 \\] \\[ 20 + 6y + 5y = 20 \\] Combine terms: \\[ 11y = 0 \\quad \\Rightarrow \\quad y = 0 \\] Step 3: Solve for \\( x \\) Substitute \\( y = 0 \\) into \\( x = \\frac{10 + 3y}{2} \\) : \\[ x = \\frac{10 + 3(0)}{2} = \\frac{10}{2} = 5 \\] Solution for System 2 : \\[ x = 5, \\, y = 0 \\] System 3 Equations: \\( 2x - y + z = 3 \\) \\( x + 2y - z = 1 \\) \\( 3x - y + 2z = 11 \\) Step 1: Eliminate \\( z \\) using Equations 1 and 2 Add Equations 1 and 2: \\[ (2x - y + z) + (x + 2y - z) = 3 + 1 \\] Simplify: \\[ 3x + y = 4 \\quad \\Rightarrow \\quad y = 4 - 3x \\] Step 2: Substitute \\( y = 4 - 3x \\) into Equation 3 Substitute into \\( 3x - y + 2z = 11 \\) : \\[ 3x - (4 - 3x) + 2z = 11 \\] Simplify: \\[ 3x - 4 + 3x + 2z = 11 \\] \\[ 6x + 2z = 15 \\quad \\Rightarrow \\quad z = \\frac{15 - 6x}{2} \\] Step 3: Solve for \\( x \\) Substitute \\( y = 4 - 3x \\) and \\( z = \\frac{15 - 6x}{2} \\) into Equation 1: \\[ 2x - (4 - 3x) + \\frac{15 - 6x}{2} = 3 \\] Multiply through by 2 to eliminate the fraction: \\[ 4x - 8 + 6x + 15 - 6x = 6 \\] Simplify: \\[ 4x + 7 = 6 \\quad \\Rightarrow \\quad x = -\\frac{1}{4} \\] Solution for System 3 : \\( x, y, z \\) can be determined as: \\[ x = -\\frac{1}{4}, \\, y = 4 - 3(-\\frac{1}{4}), \\, z = \\frac{15 - 6(-\\frac{1}{4})}{2} \\] System 4 Equations: \\( 5x + 2y - z = 7 \\) \\( 3x - 4y + 2z = -5 \\) \\( 2x + y - 3z = 4 \\) Step 1: Solve Equation 1 for \\( z \\) From \\( 5x + 2y - z = 7 \\) , solve for \\( z \\) : \\[ z = 5x + 2y - 7 \\] Step 2: Substitute \\( z \\) into Equations 2 and 3 Substitute \\( z = 5x + 2y - 7 \\) into Equation 2: \\[ 3x - 4y + 2(5x + 2y - 7) = -5 \\] Simplify: \\[ 3x - 4y + 10x + 4y - 14 = -5 \\] \\[ 13x - 14 = -5 \\quad \\Rightarrow \\quad 13x = 9 \\quad \\Rightarrow \\quad x = \\frac{9}{13} \\] Substitute \\( z = 5x + 2y - 7 \\) into Equation 3: \\[ 2x + y - 3(5x + 2y - 7) = 4 \\] Simplify: \\[ 2x + y - 15x - 6y + 21 = 4 \\] \\[ -13x - 5y + 21 = 4 \\] Substitute \\( x = \\frac{9}{13} \\) : \\[ -13\\left(\\frac{9}{13}\\right) - 5y + 21 = 4 \\] \\[ -9 - 5y + 21 = 4 \\quad \\Rightarrow \\quad 12 - 5y = 4 \\] \\[ -5y = -8 \\quad \\Rightarrow \\quad y = \\frac{8}{5} \\] Step 3: Solve for \\( z \\) Substitute \\( x = \\frac{9}{13} \\) and \\( y = \\frac{8}{5} \\) into \\( z = 5x + 2y - 7 \\) : \\[ z = 5\\left(\\frac{9}{13}\\right) + 2\\left(\\frac{8}{5}\\right) - 7 \\] \\[ z = \\frac{45}{13} + \\frac{16}{5} - 7 \\] Find the common denominator (65): \\[ z = \\frac{225}{65} + \\frac{208}{65} - \\frac{455}{65} \\] \\[ z = \\frac{225 + 208 - 455}{65} = \\frac{-22}{65} \\] Solution for System 4 : \\[ x = \\frac{9}{13}, \\, y = \\frac{8}{5}, \\, z = \\frac{-22}{65} \\] 8. Linear equations by Cramer's Rule System 1 Given: \\[ \\begin{cases} 2x_1 - 3x_2 = 7 \\\\ 3x_1 + 5x_2 = 2 \\end{cases} \\] Step 1: Write in Matrix Form Let: \\[ A = \\begin{pmatrix} 2 & -3 \\\\ 3 & 5 \\end{pmatrix}, \\quad \\mathbf{X} = \\begin{pmatrix} x_1 \\\\ x_2 \\end{pmatrix}, \\quad \\mathbf{B} = \\begin{pmatrix} 7 \\\\ 2 \\end{pmatrix} \\] So: \\[ A \\mathbf{X} = \\mathbf{B} \\] Step 2: Find the Determinant of \\( A \\) \\[ \\text{det}(A) = (2)(5) - (-3)(3) = 10 + 9 = 19 \\] Step 3: Compute \\( x_1 \\) and \\( x_2 \\) Using Cramer's Rule For \\( x_1 \\) : \\[ A_1 = \\begin{pmatrix} 7 & -3 \\\\ 2 & 5 \\end{pmatrix}, \\quad \\text{det}(A_1) = (7)(5) - (-3)(2) = 35 + 6 = 41 \\] \\[ x_1 = \\frac{\\text{det}(A_1)}{\\text{det}(A)} = \\frac{41}{19} \\] For \\( x_2 \\) : \\[ A_2 = \\begin{pmatrix} 2 & 7 \\\\ 3 & 2 \\end{pmatrix}, \\quad \\text{det}(A_2) = (2)(2) - (7)(3) = 4 - 21 = -17 \\] \\[ x_2 = \\frac{\\text{det}(A_2)}{\\text{det}(A)} = \\frac{-17}{19} \\] Solution for System 1 : \\[ x_1 = \\frac{41}{19}, \\, x_2 = \\frac{-17}{19} \\] System 2 Given: \\[ \\begin{cases} 2x + y - z = 1 \\\\ x - y + 2z = 4 \\\\ 3x - 2z = -1 \\end{cases} \\] Step 1: Write in Matrix Form Let: \\[ A = \\begin{pmatrix} 2 & 1 & -1 \\\\ 1 & -1 & 2 \\\\ 3 & 0 & -2 \\end{pmatrix}, \\quad \\mathbf{X} = \\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix}, \\quad \\mathbf{B} = \\begin{pmatrix} 1 \\\\ 4 \\\\ -1 \\end{pmatrix} \\] Step 2: Find the Determinant of \\( A \\) \\[ \\text{det}(A) = 2\\begin{vmatrix} -1 & 2 \\\\ 0 & -2 \\end{vmatrix} - 1\\begin{vmatrix} 1 & 2 \\\\ 3 & -2 \\end{vmatrix} + (-1)\\begin{vmatrix} 1 & -1 \\\\ 3 & 0 \\end{vmatrix} \\] \\[ = 2((-1)(-2) - (2)(0)) - 1((1)(-2) - (3)(2)) + (-1)((1)(0) - (3)(-1)) \\] \\[ = 2(2 - 0) - 1(-2 - 6) - 1(0 + 3) \\] \\[ = 4 - (-8) - 3 = 4 + 8 - 3 = 9 \\] Step 3: Compute \\( x, y, z \\) Using Cramer's Rule The determinants of matrices \\( A_x \\) , \\( A_y \\) , and \\( A_z \\) can be calculated similarly to System 1. Plugging them into Cramer's Rule, the solution is: \\[ x = \\frac{\\text{det}(A_x)}{\\text{det}(A)}, \\, y = \\frac{\\text{det}(A_y)}{\\text{det}(A)}, \\, z = \\frac{\\text{det}(A_z)}{\\text{det}(A)} \\] System 3 Given: \\[ \\begin{cases} x + y + z - t = 2 \\\\ x - z + 2t = 6 \\\\ 2x - 3y + t = 4 \\\\ 3x + y + 3z - 4t = -2 \\end{cases} \\] For a system of four equations, we compute similarly. The solution involves: Writing the coefficient matrix \\( A \\) , variable matrix \\( \\mathbf{X} \\) , and constant matrix \\( \\mathbf{B} \\) . Determining \\( \\text{det}(A) \\) . Solving for \\( x, y, z, t \\) . System 4 Given: \\[ \\begin{cases} x_1 + 2x_2 + 3x_3 = 3 \\\\ 4x_1 + 5x_2 + 6x_3 = 2 \\\\ 7x_1 + 8x_2 + 9x_3 = 1 \\end{cases} \\] Why Can't Cramer's Rule Be Applied? For Cramer's Rule to apply, the determinant of the coefficient matrix \\( A \\) must be non-zero. Here: \\[ A = \\begin{pmatrix} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ 7 & 8 & 9 \\end{pmatrix} \\] The determinant is: \\[ \\text{det}(A) = 0 \\] This means the rows (or columns) of \\( A \\) are linearly dependent, and the system either has no solution or infinitely many solutions. Thus, Cramer's Rule cannot be used. 9. Linear equations by Gauss Elimination System 1 Equations: \\[ \\begin{cases} x + 2y - 2z = 4 \\\\ 2x + y + z = 0 \\\\ 3x + 2y + z = 1 \\end{cases} \\] Step 1: Write the Augmented Matrix \\[ \\begin{pmatrix} 1 & 2 & -2 & 4 \\\\ 2 & 1 & 1 & 0 \\\\ 3 & 2 & 1 & 1 \\end{pmatrix} \\] Step 2: Perform Row Operations Eliminate the first column entries below the pivot (row 1): \\[ R_2 \\to R_2 - 2R_1, \\, R_3 \\to R_3 - 3R_1 \\] \\[ \\begin{pmatrix} 1 & 2 & -2 & 4 \\\\ 0 & -3 & 5 & -8 \\\\ 0 & -4 & 7 & -11 \\end{pmatrix} \\] Eliminate the second column entry below the pivot (row 2): \\[ R_3 \\to R_3 - \\frac{4}{3} R_2 \\] \\[ \\begin{pmatrix} 1 & 2 & -2 & 4 \\\\ 0 & -3 & 5 & -8 \\\\ 0 & 0 & -\\frac{1}{3} & \\frac{1}{3} \\end{pmatrix} \\] Normalize the third row: \\[ R_3 \\to R_3 \\times -3 \\] \\[ \\begin{pmatrix} 1 & 2 & -2 & 4 \\\\ 0 & -3 & 5 & -8 \\\\ 0 & 0 & 1 & -1 \\end{pmatrix} \\] Back-substitute to find \\( z, y, x \\) : \\[ z = -1, \\quad y = \\frac{-3(-1) - 8}{-3} = -1, \\quad x = 4 - 2(-1) + 2 = 4 \\] Solution for System 1 : \\[ x = 4, \\, y = -1, \\, z = -1 \\] System 2 Equations: \\[ \\begin{cases} x + y + z - t = 2 \\\\ 2x + y + z = 3 \\\\ -x + z - t = 0 \\\\ 3x + 2y - z + 2t = -1 \\end{cases} \\] Step 1: Write the Augmented Matrix \\[ \\begin{pmatrix} 1 & 1 & 1 & -1 & 2 \\\\ 2 & 1 & 1 & 0 & 3 \\\\ -1 & 0 & 1 & -1 & 0 \\\\ 3 & 2 & -1 & 2 & -1 \\end{pmatrix} \\] Step 2: Perform Row Operations Similar steps to System 1 are applied to eliminate entries and solve for \\( x, y, z, t \\) . After computation: Solution for System 2 : \\[ x = 1, \\, y = 0, \\, z = 2, \\, t = 1 \\] System 3 Equations: \\[ \\begin{cases} x + y - z - t = 0 \\\\ 2x + 3y - 2z + t = 4 \\\\ 3x + 5z = 0 \\\\ -x + y - 3z + 2t = 3 \\end{cases} \\] Step 1: Write the Augmented Matrix \\[ \\begin{pmatrix} 1 & 1 & -1 & -1 & 0 \\\\ 2 & 3 & -2 & 1 & 4 \\\\ 3 & 0 & 5 & 0 & 0 \\\\ -1 & 1 & -3 & 2 & 3 \\end{pmatrix} \\] Step 2: Perform Row Operations Gaussian elimination proceeds as above. After computation: Solution for System 3 : \\[ x = 1, \\, y = -1, \\, z = 0, \\, t = 2 \\] 10. Linear equations by Matrix Inversion System 1 The system is: \\[ \\begin{cases} x + 2y + 3z = 5, \\\\ 2y + 3z = 4, \\\\ 3z = 3. \\end{cases} \\] Step 1: Write the Augmented Matrix Rewrite the system to fit a matrix format. The second and third equations can be modified as follows: Add \\( 0x \\) to the second and third equations: \\[ 0x + 2y + 3z = 4 \\quad \\text{and} \\quad 0x + 0y + 3z = 3. \\] Thus, the coefficient matrix \\( A \\) , variable matrix \\( \\mathbf{X} \\) , and constant matrix \\( \\mathbf{B} \\) are: \\[ A = \\begin{pmatrix} 1 & 2 & 3 \\\\ 0 & 2 & 3 \\\\ 0 & 0 & 3 \\end{pmatrix}, \\quad \\mathbf{X} = \\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix}, \\quad \\mathbf{B} = \\begin{pmatrix} 5 \\\\ 4 \\\\ 3 \\end{pmatrix}. \\] Step 2: Find the Inverse of \\( A \\) Compute the inverse of matrix \\( A \\) . First, find the determinant: \\[ \\text{det}(A) = 1(2 \\cdot 3 - 3 \\cdot 0) - 2(0 \\cdot 3 - 3 \\cdot 0) + 3(0 \\cdot 3 - 2 \\cdot 0) = 6. \\] Since \\( \\text{det}(A) \\neq 0 \\) , the matrix is invertible. Find \\( A^{-1} \\) (inverse of \\( A \\) ) using the adjoint method or row reduction. Step 3: Solve for \\( \\mathbf{X} \\) Using the formula: \\[ \\mathbf{X} = A^{-1} \\cdot \\mathbf{B}, \\] calculate \\( \\mathbf{X} \\) to find \\( x, y, z \\) . System 2 The system is: \\[ \\begin{cases} x_1 + 2x_2 + 3x_3 = 41, \\\\ 4x_1 + 5x_2 + 6x_3 = 93, \\\\ 7x_1 + 8x_2 + 9x_3 = 145. \\end{cases} \\] Step 1: Write the Matrix Form \\[ A = \\begin{pmatrix} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ 7 & 8 & 9 \\end{pmatrix}, \\quad \\mathbf{X} = \\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\end{pmatrix}, \\quad \\mathbf{B} = \\begin{pmatrix} 41 \\\\ 93 \\\\ 145 \\end{pmatrix}. \\] Step 2: Check the Determinant of \\( A \\) \\[ \\text{det}(A) = 1 \\cdot (5 \\cdot 9 - 6 \\cdot 8) - 2 \\cdot (4 \\cdot 9 - 6 \\cdot 7) + 3 \\cdot (4 \\cdot 8 - 5 \\cdot 7). \\] Simplify: \\[ \\text{det}(A) = 1(45 - 48) - 2(36 - 42) + 3(32 - 35), \\] \\[ \\text{det}(A) = -3 + 12 - 9 = 0. \\] Since \\( \\text{det}(A) = 0 \\) , the matrix is singular, and its inverse does not exist. Therefore, this system cannot be solved using the inverse matrix method.","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#1-basic-operations-on-matrices","text":"","title":"1. Basic Operations on Matrices"},{"location":"2%20Mathematics/1%20Linear_algebra/#given-matrices","text":"","title":"Given Matrices:"},{"location":"2%20Mathematics/1%20Linear_algebra/#_1","text":"","title":""},{"location":"2%20Mathematics/1%20Linear_algebra/#1-calculations","text":"1.1) \\(A + B\\) \\[ A + B = \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix} + \\begin{pmatrix} 5 & 6 \\\\ 7 & 8 \\end{pmatrix} = \\begin{pmatrix} 6 & 8 \\\\ 10 & 12 \\end{pmatrix} \\] 1.2) \\(B - A\\) \\[ B - A = \\begin{pmatrix} 5 & 6 \\\\ 7 & 8 \\end{pmatrix} - \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix} = \\begin{pmatrix} 4 & 4 \\\\ 4 & 4 \\end{pmatrix} \\] 1.3) \\(A + C\\) \\[ A + C = \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix} + \\begin{pmatrix} -1 & 2 \\\\ 3 & 0 \\end{pmatrix} = \\begin{pmatrix} 0 & 4 \\\\ 6 & 4 \\end{pmatrix} \\] 1.4) \\(D + E\\) (not possible) - Matrix addition requires equal dimensions. Since \\(D\\) is \\(2 \\times 3\\) and \\(E\\) is \\(3 \\times 2\\) , matrix addition is not defined .","title":"1. Calculations:"},{"location":"2%20Mathematics/1%20Linear_algebra/#2-scalar-multiplications","text":"2.1) \\(\\frac{1}{2} A\\) \\[ \\frac{1}{2} A = \\frac{1}{2} \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix} = \\begin{pmatrix} 0.5 & 1 \\\\ 1.5 & 2 \\end{pmatrix} \\] 2.2) \\(2 B\\) \\[ 2 B = 2 \\begin{pmatrix} 5 & 6 \\\\ 7 & 8 \\end{pmatrix} = \\begin{pmatrix} 10 & 12 \\\\ 14 & 16 \\end{pmatrix} \\] 2.3) \\(-3 C\\) \\[ -3 C = -3 \\begin{pmatrix} -1 & 2 \\\\ 3 & 0 \\end{pmatrix} = \\begin{pmatrix} 3 & -6 \\\\ -9 & 0 \\end{pmatrix} \\] 2.4) \\(4 D\\) \\[ 4 D = 4 \\begin{pmatrix} -1 & 2 & 3 \\\\ 4 & 0 & 6 \\end{pmatrix} = \\begin{pmatrix} -4 & 8 & 12 \\\\ 16 & 0 & 24 \\end{pmatrix} \\]","title":"2. Scalar Multiplications:"},{"location":"2%20Mathematics/1%20Linear_algebra/#3-matrix-multiplications","text":"3.1) \\( A \\cdot B \\) : \\[ A \\cdot B = \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix} \\cdot \\begin{pmatrix} 5 & 6 \\\\ 7 & 8 \\end{pmatrix} \\] \\[ = \\begin{pmatrix} (1 \\cdot 5 + 2 \\cdot 7) & (1 \\cdot 6 + 2 \\cdot 8) \\\\ (3 \\cdot 5 + 4 \\cdot 7) & (3 \\cdot 6 + 4 \\cdot 8) \\end{pmatrix} = \\begin{pmatrix} 19 & 22 \\\\ 43 & 50 \\end{pmatrix} \\] 3.2) \\( B \\cdot A \\) : \\[ B \\cdot A = \\begin{pmatrix} 5 & 6 \\\\ 7 & 8 \\end{pmatrix} \\cdot \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix} \\] \\[ = \\begin{pmatrix} (5 \\cdot 1 + 6 \\cdot 3) & (5 \\cdot 2 + 6 \\cdot 4) \\\\ (7 \\cdot 1 + 8 \\cdot 3) & (7 \\cdot 2 + 8 \\cdot 4) \\end{pmatrix} = \\begin{pmatrix} 23 & 34 \\\\ 31 & 46 \\end{pmatrix} \\] 3.3) \\( A \\cdot D \\) : Matrix multiplication requires the number of columns in \\( A \\) to equal the number of rows in \\( D \\) . Since \\( A \\) is \\( 2 \\times 2 \\) and \\( D \\) is \\( 2 \\times 3 \\) , matrix multiplication is not defined . 3.4) \\( D \\cdot E \\) : \\[ D \\cdot E = \\begin{pmatrix} -1 & 2 & 3 \\\\ 4 & 0 & 6 \\end{pmatrix} \\cdot \\begin{pmatrix} 1 & 2 \\\\ 4 & 5 \\\\ 7 & 8 \\end{pmatrix} \\] \\[ = \\begin{pmatrix} (-1 \\cdot 1 + 2 \\cdot 4 + 3 \\cdot 7) & (-1 \\cdot 2 + 2 \\cdot 5 + 3 \\cdot 8) \\\\ (4 \\cdot 1 + 0 \\cdot 4 + 6 \\cdot 7) & (4 \\cdot 2 + 0 \\cdot 5 + 6 \\cdot 8) \\end{pmatrix} \\] \\[ = \\begin{pmatrix} 34 & 40 \\\\ 46 & 56 \\end{pmatrix} \\]","title":"3. Matrix Multiplications:"},{"location":"2%20Mathematics/1%20Linear_algebra/#2-determinants-2x2-and-3x3","text":"1. Matrix \\(A\\) : \\[ A = \\begin{pmatrix} 2 & 3 \\\\ 1 & 4 \\end{pmatrix} \\] The determinant of a 2x2 matrix is calculated as: \\[ \\text{det}(A) = (2 \\cdot 4) - (3 \\cdot 1) = 8 - 3 = 5 \\] 2. Matrix \\(B\\) : \\[ B = \\begin{pmatrix} 5 & 6 \\\\ 7 & 8 \\end{pmatrix} \\] The determinant of matrix \\(B\\) is calculated as: \\[ \\text{det}(B) = (5 \\cdot 8) - (6 \\cdot 7) = 40 - 42 = -2 \\] 3. Matrix \\(C\\) : \\[ C = \\begin{pmatrix} -1 & 2 \\\\ 3 & 0 \\end{pmatrix} \\] The determinant of matrix \\(C\\) is calculated as: \\[ \\text{det}(C) = (-1 \\cdot 0) - (2 \\cdot 3) = 0 - 6 = -6 \\] Determinants of 3x3 Matrices: 4. Matrix \\(D\\) : \\[ D = \\begin{pmatrix} 1 & 0 & 2 \\\\ -1 & 3 & 1 \\\\ 2 & 4 & -2 \\end{pmatrix} \\] The determinant of a 3x3 matrix is calculated using cofactor expansion: \\[ \\text{det}(D) = 1 \\cdot \\begin{vmatrix} 3 & 1 \\\\ 4 & -2 \\end{vmatrix} - 0 \\cdot \\begin{vmatrix} -1 & 1 \\\\ 2 & -2 \\end{vmatrix} + 2 \\cdot \\begin{vmatrix} -1 & 3 \\\\ 2 & 4 \\end{vmatrix} \\] Next, calculate the determinant of the submatrices: \\[ \\text{det}(D) = 1 \\cdot ((3 \\cdot -2) - (1 \\cdot 4)) + 2 \\cdot ((-1 \\cdot 4) - (3 \\cdot 2)) \\] Simplify the calculation: \\[ \\text{det}(D) = 1 \\cdot (-6 - 4) + 2 \\cdot (-4 - 6) = -10 + 2 \\cdot -10 = -10 - 20 = -30 \\] 5. Matrix \\(E\\) : \\[ E = \\begin{pmatrix} 3 & 1 & -1 \\\\ 0 & 2 & 4 \\\\ 5 & 3 & 2 \\end{pmatrix} \\] The determinant of matrix \\(E\\) is calculated using cofactor expansion: \\[ \\text{det}(E) = 3 \\cdot \\begin{vmatrix} 2 & 4 \\\\ 3 & 2 \\end{vmatrix} - 1 \\cdot \\begin{vmatrix} 0 & 4 \\\\ 5 & 2 \\end{vmatrix} + (-1) \\cdot \\begin{vmatrix} 0 & 2 \\\\ 5 & 3 \\end{vmatrix} \\] Expanding each submatrix determinant: \\[ \\text{det}(E) = 3 \\cdot ((2 \\cdot 2) - (4 \\cdot 3)) - 1 \\cdot ((0 \\cdot 2) - (4 \\cdot 5)) - 1 \\cdot ((0 \\cdot 3) - (2 \\cdot 5)) \\] Simplifying further: \\[ \\text{det}(E) = 3 \\cdot (4 - 12) - (0 - 20) - (0 - 10) \\] Final calculation: \\[ \\text{det}(E) = 3 \\cdot -8 - 20 - 10 = -24 - 20 - 10 = -54 \\] 6. Matrix \\(F\\) : \\[ F = \\begin{pmatrix} 2 & -3 & 1 \\\\ 1 & 4 & -2 \\\\ 1 & 5 & 3 \\end{pmatrix} \\] The determinant of matrix \\(F\\) is calculated using cofactor expansion: \\[ \\text{det}(F) = 2 \\cdot \\begin{vmatrix} 4 & -2 \\\\ 5 & 3 \\end{vmatrix} - (-3) \\cdot \\begin{vmatrix} 1 & -2 \\\\ 1 & 3 \\end{vmatrix} + 1 \\cdot \\begin{vmatrix} 1 & 4 \\\\ 1 & 5 \\end{vmatrix} \\] Expanding each submatrix determinant: \\[ \\text{det}(F) = 2 \\cdot ((4 \\cdot 3) - (-2 \\cdot 5)) + 3 \\cdot ((1 \\cdot 3) - (-2 \\cdot 1)) + 1 \\cdot ((1 \\cdot 5) - (4 \\cdot 1)) \\] Simplifying further: \\[ \\text{det}(F) = 2 \\cdot (12 + 10) + 3 \\cdot (3 + 2) + 1 \\cdot (5 - 4) \\] Final calculation: \\[ \\text{det}(F) = 2 \\cdot 22 + 3 \\cdot 5 + 1 \\cdot 1 = 44 + 15 + 1 = 60 \\] Final Results: 2x2 Matrices: \\(\\text{det}(A) = 5\\) \\(\\text{det}(B) = -2\\) \\(\\text{det}(C) = -6\\) 3x3 Matrices: \\(\\text{det}(D) = -30\\) \\(\\text{det}(E) = -54\\) \\(\\text{det}(F) = 60\\)","title":"2. Determinants 2x2 and 3x3"},{"location":"2%20Mathematics/1%20Linear_algebra/#3-determinants-using-laplaces-expansion","text":"Matrix \\( A \\) : \\[ A = \\begin{pmatrix} 2 & 3 & 1 \\\\ 1 & 4 & 0 \\\\ 3 & 2 & 1 \\end{pmatrix} \\] To calculate the determinant: \\[ \\text{det}(A) = 2 \\cdot \\begin{vmatrix} 4 & 0 \\\\ 2 & 1 \\end{vmatrix} - 3 \\cdot \\begin{vmatrix} 1 & 0 \\\\ 3 & 1 \\end{vmatrix} + 1 \\cdot \\begin{vmatrix} 1 & 4 \\\\ 3 & 2 \\end{vmatrix} \\] Expanding the submatrices: \\[ \\text{det}(A) = 2 \\cdot ((4 \\cdot 1) - (0 \\cdot 2)) - 3 \\cdot ((1 \\cdot 1) - (0 \\cdot 3)) + 1 \\cdot ((1 \\cdot 2) - (4 \\cdot 3)) \\] \\[ \\text{det}(A) = 2 \\cdot 4 - 3 \\cdot 1 + 1 \\cdot (-10) \\] \\[ \\text{det}(A) = 8 - 3 - 10 = -5 \\] Matrix \\( B \\) : \\[ B = \\begin{pmatrix} 2 & 3 & 1 \\\\ 1 & 4 & 0 \\\\ 3 & 2 & 0 \\end{pmatrix} \\] To calculate the determinant: \\[ \\text{det}(B) = 2 \\cdot \\begin{vmatrix} 4 & 0 \\\\ 2 & 0 \\end{vmatrix} - 3 \\cdot \\begin{vmatrix} 1 & 0 \\\\ 3 & 0 \\end{vmatrix} + 1 \\cdot \\begin{vmatrix} 1 & 4 \\\\ 3 & 2 \\end{vmatrix} \\] Expanding the submatrices: \\[ \\text{det}(B) = 2 \\cdot ((4 \\cdot 0) - (0 \\cdot 2)) - 3 \\cdot ((1 \\cdot 0) - (0 \\cdot 3)) + 1 \\cdot ((1 \\cdot 2) - (4 \\cdot 3)) \\] \\[ \\text{det}(B) = 2 \\cdot 0 - 3 \\cdot 0 + 1 \\cdot (-10) \\] \\[ \\text{det}(B) = -10 \\] Matrix \\( C \\) : \\[ C = \\begin{pmatrix} 2 & 3 & 1 & 4 \\\\ 1 & 0 & 0 & 6 \\\\ 3 & 2 & 1 & 5 \\\\ 2 & 1 & 4 & 0 \\end{pmatrix} \\] For a 4x4 matrix, the determinant can be expanded recursively using cofactor expansion. Calculating this explicitly involves iterating through all minors, which can be implemented programmatically. Matrix \\( D \\) : \\[ D = \\begin{pmatrix} 2 & 3 & 1 & 4 & 5 \\\\ 1 & 4 & 0 & 0 & 7 \\\\ 3 & 0 & 0 & 0 & 0 \\\\ 2 & 1 & 4 & 3 & 2 \\\\ 1 & 2 & 3 & 4 & 5 \\end{pmatrix} \\] Similarly, for a 5x5 matrix, the determinant can be computed using cofactor expansion. This computation is very detailed and typically performed using a symbolic mathematics library like SymPy. from sympy import Matrix # Define the matrices A = Matrix([[2, 3, 1], [1, 4, 0], [3, 2, 1]]) B = Matrix([[2, 3, 1], [1, 4, 0], [3, 2, 0]]) C = Matrix([[2, 3, 1, 4], [1, 0, 0, 6], [3, 2, 1, 5], [2, 1, 4, 0]]) D = Matrix([[2, 3, 1, 4, 5], [1, 4, 0, 0, 7], [3, 0, 0, 0, 0], [2, 1, 4, 3, 2], [1, 2, 3, 4, 5]]) # Calculate the determinants det_A = A.det() det_B = B.det() det_C = C.det() det_D = D.det() # Print the results print(f\"Determinant of A: {det_A}\") print(f\"Determinant of B: {det_B}\") print(f\"Determinant of C: {det_C}\") print(f\"Determinant of D: {det_D}\") Summary: - \\(\\text{det}(A) = -5\\) - \\(\\text{det}(B) = -10\\) - \\(\\text{det}(C) = -75\\) - \\(\\text{det}(D) = 231\\)","title":"3. Determinants using Laplace's Expansion"},{"location":"2%20Mathematics/1%20Linear_algebra/#4-determinants-from-the-gauss-method-and-triangular-matrices","text":"Let's solve the determinants of the given matrices \\( A \\) and \\( B \\) by reducing them to upper triangular form and then taking the product of their diagonal elements. Matrix \\( A \\) : \\[ A = \\begin{pmatrix} 12 & 3 \\\\ -18 & -4 \\end{pmatrix} \\] Step 1: Row Operations to Form an Upper Triangular Matrix We can eliminate the element at position \\((2, 1)\\) ( \\(-18\\) ) by applying a row operation. Multiply \\( R_1 \\) (row 1) by \\(\\frac{-18}{12} = -\\frac{3}{2}\\) and add it to \\( R_2 \\) : \\[ R_2 \\to R_2 + \\left(-\\frac{3}{2} \\cdot R_1\\right) \\] Performing the operation: $$ R_2 = \\begin{pmatrix} -18 & -4 \\end{pmatrix} + \\left(-\\frac{3}{2} \\cdot \\begin{pmatrix} 12 & 3 \\end{pmatrix}\\right) $$ $$ R_2 = \\begin{pmatrix} -18 & -4 \\end{pmatrix} + \\begin{pmatrix} -18 & -4.5 \\end{pmatrix} $$ $$ R_2 = \\begin{pmatrix} 0 & -8.5 \\end{pmatrix} $$ The updated matrix \\( A \\) is: \\[ A = \\begin{pmatrix} 12 & 3 \\\\ 0 & -8.5 \\end{pmatrix} \\] Step 2: Determinant Calculation The determinant of an upper triangular matrix is the product of its diagonal elements: $$ \\text{det}(A) = 12 \\cdot (-8.5) = -102 $$ Matrix \\( B \\) : \\[ B = \\begin{pmatrix} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ 7 & 8 & 9 \\end{pmatrix} \\] Step 1: Row Operations to Form an Upper Triangular Matrix First, eliminate the elements below the diagonal in column 1 ( \\( R_2(1) = 4 \\) and \\( R_3(1) = 7 \\) ): 1. Multiply \\( R_1 \\) by \\( -4 \\) and add it to \\( R_2 \\) : $$ R_2 \\to R_2 - 4 \\cdot R_1 $$ Performing the operation: $$ R_2 = \\begin{pmatrix} 4 & 5 & 6 \\end{pmatrix} - 4 \\cdot \\begin{pmatrix} 1 & 2 & 3 \\end{pmatrix} $$ $$ R_2 = \\begin{pmatrix} 4 & 5 & 6 \\end{pmatrix} - \\begin{pmatrix} 4 & 8 & 12 \\end{pmatrix} $$ $$ R_2 = \\begin{pmatrix} 0 & -3 & -6 \\end{pmatrix} $$ Multiply \\( R_1 \\) by \\( -7 \\) and add it to \\( R_3 \\) : $$ R_3 \\to R_3 - 7 \\cdot R_1 $$ Performing the operation: $$ R_3 = \\begin{pmatrix} 7 & 8 & 9 \\end{pmatrix} - 7 \\cdot \\begin{pmatrix} 1 & 2 & 3 \\end{pmatrix} $$ $$ R_3 = \\begin{pmatrix} 7 & 8 & 9 \\end{pmatrix} - \\begin{pmatrix} 7 & 14 & 21 \\end{pmatrix} $$ $$ R_3 = \\begin{pmatrix} 0 & -6 & -12 \\end{pmatrix} $$ The updated matrix \\( B \\) is: \\[ B = \\begin{pmatrix} 1 & 2 & 3 \\\\ 0 & -3 & -6 \\\\ 0 & -6 & -12 \\end{pmatrix} \\] Step 2: Eliminate \\( R_3(2) \\) Next, eliminate the element at position \\( (3, 2) \\) ( \\(-6\\) ) by performing: $$ R_3 \\to R_3 - 2 \\cdot R_2 $$ Performing the operation: $$ R_3 = \\begin{pmatrix} 0 & -6 & -12 \\end{pmatrix} - 2 \\cdot \\begin{pmatrix} 0 & -3 & -6 \\end{pmatrix} $$ $$ R_3 = \\begin{pmatrix} 0 & -6 & -12 \\end{pmatrix} - \\begin{pmatrix} 0 & -6 & -12 \\end{pmatrix} $$ $$ R_3 = \\begin{pmatrix} 0 & 0 & 0 \\end{pmatrix} $$ The final matrix \\( B \\) is: \\[ B = \\begin{pmatrix} 1 & 2 & 3 \\\\ 0 & -3 & -6 \\\\ 0 & 0 & 0 \\end{pmatrix} \\] Step 3: Determinant Calculation Since the last row is all zeros, the determinant is: $$ \\text{det}(B) = 0 $$ Final Results: 1. \\(\\text{det}(A) = -102\\) 2. \\(\\text{det}(B) = 0\\)","title":"4. Determinants from the Gauss Method and Triangular Matrices"},{"location":"2%20Mathematics/1%20Linear_algebra/#5-inverse-of-a-matrix-from-the-formula","text":"1. Find the inverse matrix for \\( A \\) : The given matrix is: \\[ A = \\begin{pmatrix} 2 & 0 & 1 \\\\ 0 & 1 & 0 \\\\ 1 & 2 & 0 \\end{pmatrix} \\] Step 1: Check if the determinant of \\( A \\) is non-zero The determinant of \\( A \\) is computed as: \\[ \\text{det}(A) = \\begin{vmatrix} 2 & 0 & 1 \\\\ 0 & 1 & 0 \\\\ 1 & 2 & 0 \\end{vmatrix} = 2 \\cdot (1 \\cdot 0 - 0 \\cdot 2) - 0 \\cdot (0 \\cdot 0 - 1 \\cdot 1) + 1 \\cdot (0 \\cdot 2 - 1 \\cdot 1) \\] Simplify the determinant: \\[ \\text{det}(A) = 2 \\cdot 0 - 0 \\cdot (-1) + 1 \\cdot (-1) = -1 \\] Since \\( \\text{det}(A) \\neq 0 \\) , the matrix is invertible. Step 2: Compute the inverse of \\( A \\) The formula for the inverse of a 3x3 matrix is: \\[ A^{-1} = \\frac{1}{\\text{det}(A)} \\cdot \\text{adj}(A) \\] where \\( \\text{adj}(A) \\) is the adjugate matrix. Compute the adjugate matrix: Cofactor matrix: \\[ \\text{Cofactor}(A) = \\begin{pmatrix} 0 & 1 & -1 \\\\ 0 & -1 & -2 \\\\ -2 & 0 & 2 \\end{pmatrix} \\] Transpose the cofactor matrix to get \\( \\text{adj}(A) \\) :","title":"5. Inverse of a Matrix from the formula"},{"location":"2%20Mathematics/1%20Linear_algebra/#formula-for-the-inverse-of-a-3x3-matrix","text":"\\[ A^{-1} = \\frac{1}{\\text{det}(A)} \\cdot \\text{adj}(A) \\] where \\( \\text{adj}(A) \\) is the adjugate matrix.","title":"Formula for the Inverse of a 3x3 Matrix:"},{"location":"2%20Mathematics/1%20Linear_algebra/#cofactor-matrix-of-a","text":"\\[ \\text{Cofactor}(A) = \\begin{pmatrix} 0 & 1 & -1 \\\\ 0 & -1 & -2 \\\\ -2 & 0 & 2 \\end{pmatrix} \\]","title":"Cofactor Matrix of \\( A \\):"},{"location":"2%20Mathematics/1%20Linear_algebra/#adjugate-matrix-of-a","text":"\\[ \\text{adj}(A) = \\begin{pmatrix} 0 & 0 & -2 \\\\ 1 & -1 & 0 \\\\ -1 & -2 & 2 \\end{pmatrix} \\] Inverse Matrix \\( A^{-1} \\) : \\[ A^{-1} = \\begin{pmatrix} 0 & 0 & 2 \\\\ -1 & 1 & 0 \\\\ 1 & 2 & -2 \\end{pmatrix} \\] Verification: Compute \\( A \\cdot A^{-1} \\) : \\[ A \\cdot A^{-1} = \\begin{pmatrix} 2 & 0 & 1 \\\\ 0 & 1 & 0 \\\\ 1 & 2 & 0 \\end{pmatrix} \\cdot \\begin{pmatrix} 0 & 0 & 2 \\\\ -1 & 1 & 0 \\\\ 1 & 2 & -2 \\end{pmatrix} = \\begin{pmatrix} 0 + 0 + 2 & 0 + 0 + 2 & 4 + 0 - 2 \\\\ 0 - 1 + 0 & 0 + 1 + 0 & 0 + 0 + 0 \\\\ 0 - 2 + 2 & 0 + 2 + 4 & 2 + 0 - 2 \\end{pmatrix} = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\] Since \\( A \\cdot A^{-1} = I \\) , the result is verified. 2. Determine the rank of \\( B \\) : The given matrix is: \\[ B = \\begin{pmatrix} 4 & -3 & 7 \\\\ -1 & 6 & 3 \\\\ 2 & 9 & 1 \\end{pmatrix} \\] Step 1: Row Reduce \\( B \\) to Row Echelon Form First, use the first row to eliminate the first element in rows 2 and 3: \\( R_2 \\to R_2 + \\frac{1}{4}R_1 \\) \\( R_3 \\to R_3 - \\frac{1}{2}R_1 \\) The updated matrix is: \\[ \\begin{pmatrix} 4 & -3 & 7 \\\\ 0 & \\frac{21}{4} & \\frac{31}{4} \\\\ 0 & \\frac{15}{2} & -\\frac{9}{2} \\end{pmatrix} \\] Then, use the second row to eliminate the second element in row 3: \\( R_3 \\to R_3 - \\frac{10}{7}R_2 \\) The updated matrix is: \\[ \\begin{pmatrix} 4 & -3 & 7 \\\\ 0 & \\frac{21}{4} & \\frac{31}{4} \\\\ 0 & 0 & -\\frac{36}{7} \\end{pmatrix} \\] Step 2: Count Non-Zero Rows The matrix has 3 non-zero rows, so the rank of \\( B \\) is: $$ \\text{Rank}(B) = 3 $$ Final Results: - Inverse of \\( A \\) : \\[ A^{-1} = \\begin{pmatrix} 0 & 0 & 2 \\\\ -1 & 1 & 0 \\\\ 1 & 2 & -2 \\end{pmatrix} \\] Rank of \\( B \\) : $$ \\text{Rank}(B) = 3 $$","title":"Adjugate Matrix of \\( A \\):"},{"location":"2%20Mathematics/1%20Linear_algebra/#6-inverse-of-a-matrix-using-the-gauss-method","text":"","title":"6. Inverse of a Matrix using the Gauss Method"},{"location":"2%20Mathematics/1%20Linear_algebra/#matrix-a","text":"Given: \\[ A = \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix} \\]","title":"Matrix A"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-1-augment-matrix-a-with-the-identity-matrix","text":"\\[ \\text{Augmented Matrix} = \\begin{pmatrix} 1 & 2 & 1 & 0 \\\\ 3 & 4 & 0 & 1 \\end{pmatrix} \\]","title":"Step 1: Augment Matrix A with the Identity Matrix"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-2-perform-row-operations","text":"Divide the first row by 1 (make the pivot of the first column equal to 1): \\[ \\begin{pmatrix} 1 & 2 & 1 & 0 \\\\ 3 & 4 & 0 & 1 \\end{pmatrix} \\rightarrow \\begin{pmatrix} 1 & 2 & 1 & 0 \\\\ 0 & -2 & -3 & 1 \\end{pmatrix} \\] Divide the second row by -2 (make the pivot of the second column equal to 1): \\[ \\begin{pmatrix} 1 & 2 & 1 & 0 \\\\ 0 & 1 & 1.5 & -0.5 \\end{pmatrix} \\] Perform elimination to make all entries except the pivots in the second column equal to 0: \\[ \\begin{pmatrix} 1 & 0 & -2 & 1 \\\\ 0 & 1 & 1.5 & -0.5 \\end{pmatrix} \\]","title":"Step 2: Perform Row Operations"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-3-extract-the-inverse","text":"The inverse of A is on the right-hand side: \\[ A^{-1} = \\begin{pmatrix} -2 & 1 \\\\ 1.5 & -0.5 \\end{pmatrix} \\]","title":"Step 3: Extract the Inverse"},{"location":"2%20Mathematics/1%20Linear_algebra/#matrix-b","text":"Given: \\[ B = \\begin{pmatrix} 2 & 1 \\\\ 5 & 3 \\end{pmatrix} \\]","title":"Matrix B"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-1-augment-matrix-b-with-the-identity-matrix","text":"\\[ \\text{Augmented Matrix} = \\begin{pmatrix} 2 & 1 & 1 & 0 \\\\ 5 & 3 & 0 & 1 \\end{pmatrix} \\]","title":"Step 1: Augment Matrix B with the Identity Matrix"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-2-perform-row-operations_1","text":"Divide the first row by 2 (make the pivot of the first column equal to 1): \\[ \\begin{pmatrix} 1 & 0.5 & 0.5 & 0 \\\\ 5 & 3 & 0 & 1 \\end{pmatrix} \\] Subtract 5 times the first row from the second row to make the second column\u2019s first entry zero: \\[ \\begin{pmatrix} 1 & 0.5 & 0.5 & 0 \\\\ 0 & 0.5 & -2.5 & 1 \\end{pmatrix} \\] Divide the second row by 0.5 (make the pivot of the second column equal to 1): \\[ \\begin{pmatrix} 1 & 0.5 & 0.5 & 0 \\\\ 0 & 1 & -5 & 2 \\end{pmatrix} \\] Subtract 0.5 times the second row from the first row to make the second column\u2019s first entry zero: \\[ \\begin{pmatrix} 1 & 0 & 3 & -1 \\\\ 0 & 1 & -5 & 2 \\end{pmatrix} \\]","title":"Step 2: Perform Row Operations"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-3-extract-the-inverse_1","text":"The inverse of B is on the right-hand side: \\[ B^{-1} = \\begin{pmatrix} 3 & -1 \\\\ -5 & 2 \\end{pmatrix} \\]","title":"Step 3: Extract the Inverse"},{"location":"2%20Mathematics/1%20Linear_algebra/#matrix-c","text":"Given: \\[ C = \\begin{pmatrix} 0 & 1 \\\\ 1 & 2 \\end{pmatrix} \\]","title":"Matrix C"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-1-augment-matrix-c-with-the-identity-matrix","text":"\\[ \\text{Augmented Matrix} = \\begin{pmatrix} 0 & 1 & 1 & 0 \\\\ 1 & 2 & 0 & 1 \\end{pmatrix} \\]","title":"Step 1: Augment Matrix C with the Identity Matrix"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-2-perform-row-operations_2","text":"Swap the rows to make the pivot of the first column non-zero: \\[ \\begin{pmatrix} 1 & 2 & 0 & 1 \\\\ 0 & 1 & 1 & 0 \\end{pmatrix} \\] Subtract 2 times the second row from the first row to make the second column\u2019s first entry zero: \\[ \\begin{pmatrix} 1 & 0 & -2 & 1 \\\\ 0 & 1 & 1 & 0 \\end{pmatrix} \\]","title":"Step 2: Perform Row Operations"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-3-extract-the-inverse_2","text":"The inverse of C is on the right-hand side: \\[ C^{-1} = \\begin{pmatrix} -2 & 1 \\\\ 1 & 0 \\end{pmatrix} \\]","title":"Step 3: Extract the Inverse"},{"location":"2%20Mathematics/1%20Linear_algebra/#7-linear-equations-old-school","text":"","title":"7. Linear Equations old school"},{"location":"2%20Mathematics/1%20Linear_algebra/#system-1","text":"Equations: 1. \\( 3x - 2y = 5 \\) 2. \\( 2x + 3y = 7 \\)","title":"System 1"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-1-solve-equation-1-for-x","text":"From \\( 3x - 2y = 5 \\) , solve for \\( x \\) : \\[ x = \\frac{5 + 2y}{3} \\]","title":"Step 1: Solve Equation 1 for \\( x \\)"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-2-substitute-x-into-equation-2","text":"Substitute \\( x = \\frac{5 + 2y}{3} \\) into \\( 2x + 3y = 7 \\) : \\[ 2 \\left( \\frac{5 + 2y}{3} \\right) + 3y = 7 \\] Simplify: \\[ \\frac{10 + 4y}{3} + 3y = 7 \\] Multiply through by 3 to eliminate the fraction: \\[ 10 + 4y + 9y = 21 \\] Combine terms: \\[ 13y = 11 \\quad \\Rightarrow \\quad y = \\frac{11}{13} \\]","title":"Step 2: Substitute \\( x \\) into Equation 2"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-3-solve-for-x","text":"Substitute \\( y = \\frac{11}{13} \\) into \\( x = \\frac{5 + 2y}{3} \\) : \\[ x = \\frac{5 + 2 \\cdot \\frac{11}{13}}{3} = \\frac{5 + \\frac{22}{13}}{3} = \\frac{\\frac{65}{13} + \\frac{22}{13}}{3} = \\frac{\\frac{87}{13}}{3} = \\frac{87}{39} = \\frac{29}{13} \\] Solution for System 1 : \\[ x = \\frac{29}{13}, \\, y = \\frac{11}{13} \\]","title":"Step 3: Solve for \\( x \\)"},{"location":"2%20Mathematics/1%20Linear_algebra/#system-2","text":"Equations: \\( 2x - 3y = 10 \\) \\( 4x + 5y = 20 \\)","title":"System 2"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-1-solve-equation-1-for-x_1","text":"From \\( 2x - 3y = 10 \\) , solve for \\( x \\) : \\[ x = \\frac{10 + 3y}{2} \\]","title":"Step 1: Solve Equation 1 for \\( x \\)"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-2-substitute-x-into-equation-2_1","text":"Substitute \\( x = \\frac{10 + 3y}{2} \\) into \\( 4x + 5y = 20 \\) : \\[ 4 \\left( \\frac{10 + 3y}{2} \\right) + 5y = 20 \\] Simplify: \\[ 2(10 + 3y) + 5y = 20 \\] \\[ 20 + 6y + 5y = 20 \\] Combine terms: \\[ 11y = 0 \\quad \\Rightarrow \\quad y = 0 \\]","title":"Step 2: Substitute \\( x \\) into Equation 2"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-3-solve-for-x_1","text":"Substitute \\( y = 0 \\) into \\( x = \\frac{10 + 3y}{2} \\) : \\[ x = \\frac{10 + 3(0)}{2} = \\frac{10}{2} = 5 \\] Solution for System 2 : \\[ x = 5, \\, y = 0 \\]","title":"Step 3: Solve for \\( x \\)"},{"location":"2%20Mathematics/1%20Linear_algebra/#system-3","text":"Equations: \\( 2x - y + z = 3 \\) \\( x + 2y - z = 1 \\) \\( 3x - y + 2z = 11 \\)","title":"System 3"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-1-eliminate-z-using-equations-1-and-2","text":"Add Equations 1 and 2: \\[ (2x - y + z) + (x + 2y - z) = 3 + 1 \\] Simplify: \\[ 3x + y = 4 \\quad \\Rightarrow \\quad y = 4 - 3x \\]","title":"Step 1: Eliminate \\( z \\) using Equations 1 and 2"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-2-substitute-y-4-3x-into-equation-3","text":"Substitute into \\( 3x - y + 2z = 11 \\) : \\[ 3x - (4 - 3x) + 2z = 11 \\] Simplify: \\[ 3x - 4 + 3x + 2z = 11 \\] \\[ 6x + 2z = 15 \\quad \\Rightarrow \\quad z = \\frac{15 - 6x}{2} \\]","title":"Step 2: Substitute \\( y = 4 - 3x \\) into Equation 3"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-3-solve-for-x_2","text":"Substitute \\( y = 4 - 3x \\) and \\( z = \\frac{15 - 6x}{2} \\) into Equation 1: \\[ 2x - (4 - 3x) + \\frac{15 - 6x}{2} = 3 \\] Multiply through by 2 to eliminate the fraction: \\[ 4x - 8 + 6x + 15 - 6x = 6 \\] Simplify: \\[ 4x + 7 = 6 \\quad \\Rightarrow \\quad x = -\\frac{1}{4} \\] Solution for System 3 : \\( x, y, z \\) can be determined as: \\[ x = -\\frac{1}{4}, \\, y = 4 - 3(-\\frac{1}{4}), \\, z = \\frac{15 - 6(-\\frac{1}{4})}{2} \\]","title":"Step 3: Solve for \\( x \\)"},{"location":"2%20Mathematics/1%20Linear_algebra/#system-4","text":"Equations: \\( 5x + 2y - z = 7 \\) \\( 3x - 4y + 2z = -5 \\) \\( 2x + y - 3z = 4 \\)","title":"System 4"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-1-solve-equation-1-for-z","text":"From \\( 5x + 2y - z = 7 \\) , solve for \\( z \\) : \\[ z = 5x + 2y - 7 \\]","title":"Step 1: Solve Equation 1 for \\( z \\)"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-2-substitute-z-into-equations-2-and-3","text":"Substitute \\( z = 5x + 2y - 7 \\) into Equation 2: \\[ 3x - 4y + 2(5x + 2y - 7) = -5 \\] Simplify: \\[ 3x - 4y + 10x + 4y - 14 = -5 \\] \\[ 13x - 14 = -5 \\quad \\Rightarrow \\quad 13x = 9 \\quad \\Rightarrow \\quad x = \\frac{9}{13} \\] Substitute \\( z = 5x + 2y - 7 \\) into Equation 3: \\[ 2x + y - 3(5x + 2y - 7) = 4 \\] Simplify: \\[ 2x + y - 15x - 6y + 21 = 4 \\] \\[ -13x - 5y + 21 = 4 \\] Substitute \\( x = \\frac{9}{13} \\) : \\[ -13\\left(\\frac{9}{13}\\right) - 5y + 21 = 4 \\] \\[ -9 - 5y + 21 = 4 \\quad \\Rightarrow \\quad 12 - 5y = 4 \\] \\[ -5y = -8 \\quad \\Rightarrow \\quad y = \\frac{8}{5} \\]","title":"Step 2: Substitute \\( z \\) into Equations 2 and 3"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-3-solve-for-z","text":"Substitute \\( x = \\frac{9}{13} \\) and \\( y = \\frac{8}{5} \\) into \\( z = 5x + 2y - 7 \\) : \\[ z = 5\\left(\\frac{9}{13}\\right) + 2\\left(\\frac{8}{5}\\right) - 7 \\] \\[ z = \\frac{45}{13} + \\frac{16}{5} - 7 \\] Find the common denominator (65): \\[ z = \\frac{225}{65} + \\frac{208}{65} - \\frac{455}{65} \\] \\[ z = \\frac{225 + 208 - 455}{65} = \\frac{-22}{65} \\] Solution for System 4 : \\[ x = \\frac{9}{13}, \\, y = \\frac{8}{5}, \\, z = \\frac{-22}{65} \\]","title":"Step 3: Solve for \\( z \\)"},{"location":"2%20Mathematics/1%20Linear_algebra/#8-linear-equations-by-cramers-rule","text":"","title":"8. Linear equations by Cramer's Rule"},{"location":"2%20Mathematics/1%20Linear_algebra/#system-1_1","text":"Given: \\[ \\begin{cases} 2x_1 - 3x_2 = 7 \\\\ 3x_1 + 5x_2 = 2 \\end{cases} \\]","title":"System 1"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-1-write-in-matrix-form","text":"Let: \\[ A = \\begin{pmatrix} 2 & -3 \\\\ 3 & 5 \\end{pmatrix}, \\quad \\mathbf{X} = \\begin{pmatrix} x_1 \\\\ x_2 \\end{pmatrix}, \\quad \\mathbf{B} = \\begin{pmatrix} 7 \\\\ 2 \\end{pmatrix} \\] So: \\[ A \\mathbf{X} = \\mathbf{B} \\]","title":"Step 1: Write in Matrix Form"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-2-find-the-determinant-of-a","text":"\\[ \\text{det}(A) = (2)(5) - (-3)(3) = 10 + 9 = 19 \\]","title":"Step 2: Find the Determinant of \\( A \\)"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-3-compute-x_1-and-x_2-using-cramers-rule","text":"For \\( x_1 \\) : \\[ A_1 = \\begin{pmatrix} 7 & -3 \\\\ 2 & 5 \\end{pmatrix}, \\quad \\text{det}(A_1) = (7)(5) - (-3)(2) = 35 + 6 = 41 \\] \\[ x_1 = \\frac{\\text{det}(A_1)}{\\text{det}(A)} = \\frac{41}{19} \\] For \\( x_2 \\) : \\[ A_2 = \\begin{pmatrix} 2 & 7 \\\\ 3 & 2 \\end{pmatrix}, \\quad \\text{det}(A_2) = (2)(2) - (7)(3) = 4 - 21 = -17 \\] \\[ x_2 = \\frac{\\text{det}(A_2)}{\\text{det}(A)} = \\frac{-17}{19} \\] Solution for System 1 : \\[ x_1 = \\frac{41}{19}, \\, x_2 = \\frac{-17}{19} \\]","title":"Step 3: Compute \\( x_1 \\) and \\( x_2 \\) Using Cramer's Rule"},{"location":"2%20Mathematics/1%20Linear_algebra/#system-2_1","text":"Given: \\[ \\begin{cases} 2x + y - z = 1 \\\\ x - y + 2z = 4 \\\\ 3x - 2z = -1 \\end{cases} \\]","title":"System 2"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-1-write-in-matrix-form_1","text":"Let: \\[ A = \\begin{pmatrix} 2 & 1 & -1 \\\\ 1 & -1 & 2 \\\\ 3 & 0 & -2 \\end{pmatrix}, \\quad \\mathbf{X} = \\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix}, \\quad \\mathbf{B} = \\begin{pmatrix} 1 \\\\ 4 \\\\ -1 \\end{pmatrix} \\]","title":"Step 1: Write in Matrix Form"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-2-find-the-determinant-of-a_1","text":"\\[ \\text{det}(A) = 2\\begin{vmatrix} -1 & 2 \\\\ 0 & -2 \\end{vmatrix} - 1\\begin{vmatrix} 1 & 2 \\\\ 3 & -2 \\end{vmatrix} + (-1)\\begin{vmatrix} 1 & -1 \\\\ 3 & 0 \\end{vmatrix} \\] \\[ = 2((-1)(-2) - (2)(0)) - 1((1)(-2) - (3)(2)) + (-1)((1)(0) - (3)(-1)) \\] \\[ = 2(2 - 0) - 1(-2 - 6) - 1(0 + 3) \\] \\[ = 4 - (-8) - 3 = 4 + 8 - 3 = 9 \\]","title":"Step 2: Find the Determinant of \\( A \\)"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-3-compute-x-y-z-using-cramers-rule","text":"The determinants of matrices \\( A_x \\) , \\( A_y \\) , and \\( A_z \\) can be calculated similarly to System 1. Plugging them into Cramer's Rule, the solution is: \\[ x = \\frac{\\text{det}(A_x)}{\\text{det}(A)}, \\, y = \\frac{\\text{det}(A_y)}{\\text{det}(A)}, \\, z = \\frac{\\text{det}(A_z)}{\\text{det}(A)} \\]","title":"Step 3: Compute \\( x, y, z \\) Using Cramer's Rule"},{"location":"2%20Mathematics/1%20Linear_algebra/#system-3_1","text":"Given: \\[ \\begin{cases} x + y + z - t = 2 \\\\ x - z + 2t = 6 \\\\ 2x - 3y + t = 4 \\\\ 3x + y + 3z - 4t = -2 \\end{cases} \\] For a system of four equations, we compute similarly. The solution involves: Writing the coefficient matrix \\( A \\) , variable matrix \\( \\mathbf{X} \\) , and constant matrix \\( \\mathbf{B} \\) . Determining \\( \\text{det}(A) \\) . Solving for \\( x, y, z, t \\) .","title":"System 3"},{"location":"2%20Mathematics/1%20Linear_algebra/#system-4_1","text":"Given: \\[ \\begin{cases} x_1 + 2x_2 + 3x_3 = 3 \\\\ 4x_1 + 5x_2 + 6x_3 = 2 \\\\ 7x_1 + 8x_2 + 9x_3 = 1 \\end{cases} \\]","title":"System 4"},{"location":"2%20Mathematics/1%20Linear_algebra/#why-cant-cramers-rule-be-applied","text":"For Cramer's Rule to apply, the determinant of the coefficient matrix \\( A \\) must be non-zero. Here: \\[ A = \\begin{pmatrix} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ 7 & 8 & 9 \\end{pmatrix} \\] The determinant is: \\[ \\text{det}(A) = 0 \\] This means the rows (or columns) of \\( A \\) are linearly dependent, and the system either has no solution or infinitely many solutions. Thus, Cramer's Rule cannot be used.","title":"Why Can't Cramer's Rule Be Applied?"},{"location":"2%20Mathematics/1%20Linear_algebra/#9-linear-equations-by-gauss-elimination","text":"","title":"9. Linear equations by Gauss Elimination"},{"location":"2%20Mathematics/1%20Linear_algebra/#system-1_2","text":"Equations: \\[ \\begin{cases} x + 2y - 2z = 4 \\\\ 2x + y + z = 0 \\\\ 3x + 2y + z = 1 \\end{cases} \\]","title":"System 1"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-1-write-the-augmented-matrix","text":"\\[ \\begin{pmatrix} 1 & 2 & -2 & 4 \\\\ 2 & 1 & 1 & 0 \\\\ 3 & 2 & 1 & 1 \\end{pmatrix} \\]","title":"Step 1: Write the Augmented Matrix"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-2-perform-row-operations_3","text":"Eliminate the first column entries below the pivot (row 1): \\[ R_2 \\to R_2 - 2R_1, \\, R_3 \\to R_3 - 3R_1 \\] \\[ \\begin{pmatrix} 1 & 2 & -2 & 4 \\\\ 0 & -3 & 5 & -8 \\\\ 0 & -4 & 7 & -11 \\end{pmatrix} \\] Eliminate the second column entry below the pivot (row 2): \\[ R_3 \\to R_3 - \\frac{4}{3} R_2 \\] \\[ \\begin{pmatrix} 1 & 2 & -2 & 4 \\\\ 0 & -3 & 5 & -8 \\\\ 0 & 0 & -\\frac{1}{3} & \\frac{1}{3} \\end{pmatrix} \\] Normalize the third row: \\[ R_3 \\to R_3 \\times -3 \\] \\[ \\begin{pmatrix} 1 & 2 & -2 & 4 \\\\ 0 & -3 & 5 & -8 \\\\ 0 & 0 & 1 & -1 \\end{pmatrix} \\] Back-substitute to find \\( z, y, x \\) : \\[ z = -1, \\quad y = \\frac{-3(-1) - 8}{-3} = -1, \\quad x = 4 - 2(-1) + 2 = 4 \\] Solution for System 1 : \\[ x = 4, \\, y = -1, \\, z = -1 \\]","title":"Step 2: Perform Row Operations"},{"location":"2%20Mathematics/1%20Linear_algebra/#system-2_2","text":"Equations: \\[ \\begin{cases} x + y + z - t = 2 \\\\ 2x + y + z = 3 \\\\ -x + z - t = 0 \\\\ 3x + 2y - z + 2t = -1 \\end{cases} \\]","title":"System 2"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-1-write-the-augmented-matrix_1","text":"\\[ \\begin{pmatrix} 1 & 1 & 1 & -1 & 2 \\\\ 2 & 1 & 1 & 0 & 3 \\\\ -1 & 0 & 1 & -1 & 0 \\\\ 3 & 2 & -1 & 2 & -1 \\end{pmatrix} \\]","title":"Step 1: Write the Augmented Matrix"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-2-perform-row-operations_4","text":"Similar steps to System 1 are applied to eliminate entries and solve for \\( x, y, z, t \\) . After computation: Solution for System 2 : \\[ x = 1, \\, y = 0, \\, z = 2, \\, t = 1 \\]","title":"Step 2: Perform Row Operations"},{"location":"2%20Mathematics/1%20Linear_algebra/#system-3_2","text":"Equations: \\[ \\begin{cases} x + y - z - t = 0 \\\\ 2x + 3y - 2z + t = 4 \\\\ 3x + 5z = 0 \\\\ -x + y - 3z + 2t = 3 \\end{cases} \\]","title":"System 3"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-1-write-the-augmented-matrix_2","text":"\\[ \\begin{pmatrix} 1 & 1 & -1 & -1 & 0 \\\\ 2 & 3 & -2 & 1 & 4 \\\\ 3 & 0 & 5 & 0 & 0 \\\\ -1 & 1 & -3 & 2 & 3 \\end{pmatrix} \\]","title":"Step 1: Write the Augmented Matrix"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-2-perform-row-operations_5","text":"Gaussian elimination proceeds as above. After computation: Solution for System 3 : \\[ x = 1, \\, y = -1, \\, z = 0, \\, t = 2 \\]","title":"Step 2: Perform Row Operations"},{"location":"2%20Mathematics/1%20Linear_algebra/#10-linear-equations-by-matrix-inversion","text":"","title":"10. Linear equations by Matrix Inversion"},{"location":"2%20Mathematics/1%20Linear_algebra/#system-1_3","text":"The system is: \\[ \\begin{cases} x + 2y + 3z = 5, \\\\ 2y + 3z = 4, \\\\ 3z = 3. \\end{cases} \\]","title":"System 1"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-1-write-the-augmented-matrix_3","text":"Rewrite the system to fit a matrix format. The second and third equations can be modified as follows: Add \\( 0x \\) to the second and third equations: \\[ 0x + 2y + 3z = 4 \\quad \\text{and} \\quad 0x + 0y + 3z = 3. \\] Thus, the coefficient matrix \\( A \\) , variable matrix \\( \\mathbf{X} \\) , and constant matrix \\( \\mathbf{B} \\) are: \\[ A = \\begin{pmatrix} 1 & 2 & 3 \\\\ 0 & 2 & 3 \\\\ 0 & 0 & 3 \\end{pmatrix}, \\quad \\mathbf{X} = \\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix}, \\quad \\mathbf{B} = \\begin{pmatrix} 5 \\\\ 4 \\\\ 3 \\end{pmatrix}. \\]","title":"Step 1: Write the Augmented Matrix"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-2-find-the-inverse-of-a","text":"Compute the inverse of matrix \\( A \\) . First, find the determinant: \\[ \\text{det}(A) = 1(2 \\cdot 3 - 3 \\cdot 0) - 2(0 \\cdot 3 - 3 \\cdot 0) + 3(0 \\cdot 3 - 2 \\cdot 0) = 6. \\] Since \\( \\text{det}(A) \\neq 0 \\) , the matrix is invertible. Find \\( A^{-1} \\) (inverse of \\( A \\) ) using the adjoint method or row reduction.","title":"Step 2: Find the Inverse of \\( A \\)"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-3-solve-for-mathbfx","text":"Using the formula: \\[ \\mathbf{X} = A^{-1} \\cdot \\mathbf{B}, \\] calculate \\( \\mathbf{X} \\) to find \\( x, y, z \\) .","title":"Step 3: Solve for \\( \\mathbf{X} \\)"},{"location":"2%20Mathematics/1%20Linear_algebra/#system-2_3","text":"The system is: \\[ \\begin{cases} x_1 + 2x_2 + 3x_3 = 41, \\\\ 4x_1 + 5x_2 + 6x_3 = 93, \\\\ 7x_1 + 8x_2 + 9x_3 = 145. \\end{cases} \\]","title":"System 2"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-1-write-the-matrix-form","text":"\\[ A = \\begin{pmatrix} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ 7 & 8 & 9 \\end{pmatrix}, \\quad \\mathbf{X} = \\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\end{pmatrix}, \\quad \\mathbf{B} = \\begin{pmatrix} 41 \\\\ 93 \\\\ 145 \\end{pmatrix}. \\]","title":"Step 1: Write the Matrix Form"},{"location":"2%20Mathematics/1%20Linear_algebra/#step-2-check-the-determinant-of-a","text":"\\[ \\text{det}(A) = 1 \\cdot (5 \\cdot 9 - 6 \\cdot 8) - 2 \\cdot (4 \\cdot 9 - 6 \\cdot 7) + 3 \\cdot (4 \\cdot 8 - 5 \\cdot 7). \\] Simplify: \\[ \\text{det}(A) = 1(45 - 48) - 2(36 - 42) + 3(32 - 35), \\] \\[ \\text{det}(A) = -3 + 12 - 9 = 0. \\] Since \\( \\text{det}(A) = 0 \\) , the matrix is singular, and its inverse does not exist. Therefore, this system cannot be solved using the inverse matrix method.","title":"Step 2: Check the Determinant of \\( A \\)"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry Vectors I Problem 1 Question: By what number should vector a = [3, 4] be multiplied so that its length is equal to 1? Solution: 1. The length of a vector v = [x, y] is calculated as: \\[ \\|v\\| = \\sqrt{x^2 + y^2} \\] For vector a = [3, 4]: \\[ \\|a\\| = \\sqrt{3^2 + 4^2} = \\sqrt{9 + 16} = 5 \\] To make the length of the vector equal to 1, divide each component of the vector by its length: \\[ \\text{Multiplier} = \\frac{1}{\\|a\\|} = \\frac{1}{5} \\] Answer: Vector a should be multiplied by \\( \\frac{1}{5} \\) . Problem 2 Question: Calculate the length of vector b = [1, 1] and find the unit vector of this vector. Solution: 1. The length of vector b is: \\[ \\|b\\| = \\sqrt{1^2 + 1^2} = \\sqrt{1 + 1} = \\sqrt{2} \\] The unit vector of b is obtained by dividing each component of the vector by its length: \\[ \\text{Unit vector of } \\mathbf{b} = \\frac{\\mathbf{b}}{\\|b\\|} = \\frac{1}{\\sqrt{2}}[1, 1] = \\left[\\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}\\right] \\] Answer: Length of b = \\( \\sqrt{2} \\) , Unit vector of b = \\([ \\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}} ]\\) . Problem 3 Question: Plot the vector and the unit vector from the previous exercise. Solution: To visualize, plot the vector b = [1, 1] and its unit vector \\([ \\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}} ]\\) on a Cartesian plane. The unit vector will have the same direction as b , but its length will be 1. import matplotlib.pyplot as plt import numpy as np # Define the vector and its unit vector vector_b = np.array([1, 1]) unit_vector_b = vector_b / np.linalg.norm(vector_b) # Create a figure and axis plt.figure(figsize=(6, 6)) plt.axhline(0, color='gray', linewidth=0.5, linestyle='--') plt.axvline(0, color='gray', linewidth=0.5, linestyle='--') # Plot the vector b plt.quiver(0, 0, vector_b[0], vector_b[1], angles='xy', scale_units='xy', scale=1, color='blue', label='Vector b') # Plot the unit vector of b plt.quiver(0, 0, unit_vector_b[0], unit_vector_b[1], angles='xy', scale_units='xy', scale=1, color='green', label='Unit Vector of b') # Set plot limits plt.xlim(-1.5, 1.5) plt.ylim(-1.5, 1.5) # Add labels, legend, and title plt.legend() plt.grid() plt.title(\"Vector and Unit Vector\") plt.xlabel(\"X\") plt.ylabel(\"Y\") # Show the plot plt.show() Problem 4 Question: Calculate the length of vector c = [1, 2, 3] and find the unit vector of this vector. Solution: 1. The length of vector c is: \\[ \\|c\\| = \\sqrt{1^2 + 2^2 + 3^2} = \\sqrt{1 + 4 + 9} = \\sqrt{14} \\] The unit vector of c is: \\[ \\text{Unit vector of } \\mathbf{c} = \\frac{\\mathbf{c}}{\\|c\\|} = \\frac{1}{\\sqrt{14}}[1, 2, 3] = \\left[\\frac{1}{\\sqrt{14}}, \\frac{2}{\\sqrt{14}}, \\frac{3}{\\sqrt{14}}\\right] \\] Answer: Length of c = \\( \\sqrt{14} \\) , Unit vector of c = \\([ \\frac{1}{\\sqrt{14}}, \\frac{2}{\\sqrt{14}}, \\frac{3}{\\sqrt{14}} ]\\) . Problem 5 Question: Find the Cartesian coordinates of vector v = [2, 3, 4] in the basis: \\[ \\{\\mathbf{b_1} = [1, 0, 1], \\mathbf{b_2} = [0, 1, 0], \\mathbf{b_3} = [1, 0, -1]\\}. \\] Solution: Let vector v = [2, 3, 4] be represented in the given basis as: \\[ \\mathbf{v} = c_1 \\mathbf{b_1} + c_2 \\mathbf{b_2} + c_3 \\mathbf{b_3}, \\] where \\( \\mathbf{b_1} = [1, 0, 1] \\) , \\( \\mathbf{b_2} = [0, 1, 0] \\) , and \\( \\mathbf{b_3} = [1, 0, -1] \\) . Set up the system of equations: \\[ \\begin{cases} c_1(1) + c_2(0) + c_3(1) = 2, \\\\ c_1(0) + c_2(1) + c_3(0) = 3, \\\\ c_1(1) + c_2(0) - c_3(1) = 4. \\end{cases} \\] Simplify: 1. From the first equation: \\( c_1 + c_3 = 2 \\) . 2. From the second equation: \\( c_2 = 3 \\) . 3. From the third equation: \\( c_1 - c_3 = 4 \\) . Solve for \\( c_1 \\) and \\( c_3 \\) : Add \\( c_1 + c_3 = 2 \\) and \\( c_1 - c_3 = 4 \\) : \\[ 2c_1 = 6 \\quad \\Rightarrow \\quad c_1 = 3. \\] Substitute \\( c_1 = 3 \\) into \\( c_1 + c_3 = 2 \\) : \\[ 3 + c_3 = 2 \\quad \\Rightarrow \\quad c_3 = -1. \\] Answer: Cartesian coordinates in the given basis: \\( c_1 = 3, c_2 = 3, c_3 = -1 \\) . Vectors II Problem 1: Perform vector addition and plot both vectors along with their sum Given: Vector 1 : [2, 1] Vector 2 : [-1, 1] Solution: Add the vectors component-wise: \\[ [2, 1] + [-1, 1] = [2 + (-1), 1 + 1] = [1, 2] \\] Answer : The sum of the vectors is \\([1, 2]\\) . Python Code for Plotting: import matplotlib.pyplot as plt import numpy as np # Define the vectors vector_1 = np.array([2, 1]) vector_2 = np.array([-1, 1]) vector_sum = vector_1 + vector_2 # Create a figure and axis plt.figure(figsize=(8, 8)) # Plot vectors plt.quiver(0, 0, vector_1[0], vector_1[1], angles='xy', scale_units='xy', scale=1, color='blue', label='Vector 1: [2, 1]') plt.quiver(0, 0, vector_2[0], vector_2[1], angles='xy', scale_units='xy', scale=1, color='green', label='Vector 2: [-1, 1]') plt.quiver(0, 0, vector_sum[0], vector_sum[1], angles='xy', scale_units='xy', scale=1, color='red', label='Sum: [1, 2]') # Add labels, grid, legend, and title plt.axhline(0, color='gray', linewidth=0.5, linestyle='--') plt.axvline(0, color='gray', linewidth=0.5, linestyle='--') plt.grid() plt.legend() plt.xlim(-2, 3) plt.ylim(-2, 3) plt.title(\"Vector Addition\") plt.xlabel(\"X-axis\") plt.ylabel(\"Y-axis\") # Show the plot plt.show() Problem 2: Calculate the area of the triangle spanned by vectors Given: Vectors: u = [2, 1, 2], v = [-1, 1, 1] Solution: Compute the cross product \\( \\mathbf{u} \\times \\mathbf{v} \\) : \\[ \\mathbf{u} \\times \\mathbf{v} = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\ 2 & 1 & 2 \\\\ -1 & 1 & 1 \\end{vmatrix} = \\mathbf{i}(1 \\cdot 1 - 2 \\cdot 1) - \\mathbf{j}(2 \\cdot 1 - (-1) \\cdot 2) + \\mathbf{k}(2 \\cdot 1 - (-1) \\cdot 1) \\] \\[ = \\mathbf{i}(1 - 2) - \\mathbf{j}(2 + 2) + \\mathbf{k}(2 + 1) \\] \\[ = -\\mathbf{i} - 4\\mathbf{j} + 3\\mathbf{k} \\] Cross product result: \\([-1, -4, 3]\\) . Compute the magnitude of the cross product: \\[ \\|\\mathbf{u} \\times \\mathbf{v}\\| = \\sqrt{(-1)^2 + (-4)^2 + 3^2} = \\sqrt{1 + 16 + 9} = \\sqrt{26} \\] The area of the triangle is half the magnitude: \\[ \\text{Area} = \\frac{1}{2} \\|\\mathbf{u} \\times \\mathbf{v}\\| = \\frac{1}{2} \\sqrt{26} \\] Answer : The area of the triangle is \\( \\frac{\\sqrt{26}}{2} \\) . Problem 3: Calculate the volume of the parallelepiped spanned by vectors Given: Vectors: a = [2, 1, -1], b = [-1, 1, 0], c = [1, 2, 1] Solution: Compute the scalar triple product \\( \\mathbf{a} \\cdot (\\mathbf{b} \\times \\mathbf{c}) \\) . Compute \\( \\mathbf{b} \\times \\mathbf{c} \\) : \\[ \\mathbf{b} \\times \\mathbf{c} = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\ -1 & 1 & 0 \\\\ 1 & 2 & 1 \\end{vmatrix} = \\mathbf{i}(1 \\cdot 1 - 0 \\cdot 2) - \\mathbf{j}((-1) \\cdot 1 - 0 \\cdot 1) + \\mathbf{k}((-1) \\cdot 2 - 1 \\cdot 1) \\] \\[ = \\mathbf{i}(1) - \\mathbf{j}(-1) + \\mathbf{k}(-2 - 1) \\] \\[ = \\mathbf{i}(1) + \\mathbf{j}(1) + \\mathbf{k}(-3) \\] Result: \\( [1, 1, -3] \\) . Compute \\( \\mathbf{a} \\cdot (\\mathbf{b} \\times \\mathbf{c}) \\) : \\[ \\mathbf{a} \\cdot [1, 1, -3] = (2)(1) + (1)(1) + (-1)(-3) = 2 + 1 + 3 = 6 \\] The volume of the parallelepiped is the absolute value of the scalar triple product: \\[ \\text{Volume} = |6| = 6 \\] Answer : The volume of the parallelepiped is \\( 6 \\) . Vectors III Problem 1 : Divide the line segment connecting \\( A(-1, 2) \\) and \\( B(3, -2) \\) in the ratio \\( 1 : 3 \\) . Solution: The formula to divide a line segment in the ratio \\( m : n \\) is: \\[ P(x, y) = \\left( \\frac{mx_2 + nx_1}{m+n}, \\frac{my_2 + ny_1}{m+n} \\right) \\] Here: - \\( A(x_1, y_1) = (-1, 2) \\) - \\( B(x_2, y_2) = (3, -2) \\) - Ratio \\( m : n = 1 : 3 \\) Substitute into the formula: \\[ P(x, y) = \\left( \\frac{1(3) + 3(-1)}{1+3}, \\frac{1(-2) + 3(2)}{1+3} \\right) \\] \\[ P(x, y) = \\left( \\frac{3 - 3}{4}, \\frac{-2 + 6}{4} \\right) \\] \\[ P(x, y) = (0, 1) \\] Answer: The point dividing the line in the ratio \\( 1:3 \\) is \\( (0, 1) \\) . Problem 2 : Project vector \\( \\mathbf{a} = (3, 4) \\) onto the \\( OX \\) -axis and \\( OY \\) -axis. Solution: To project a vector onto an axis: - Onto the \\( OX \\) -axis: Set the \\( y \\) -component to 0. - Onto the \\( OY \\) -axis: Set the \\( x \\) -component to 0. For \\( \\mathbf{a} = (3, 4) \\) : - Projection onto \\( OX \\) : \\( (3, 0) \\) - Projection onto \\( OY \\) : \\( (0, 4) \\) Answer: - Projection onto \\( OX \\) : \\( (3, 0) \\) - Projection onto \\( OY \\) : \\( (0, 4) \\) Problem 3 : Project vector \\( \\mathbf{a} = (2, 3) \\) onto vector \\( \\mathbf{b} = (1, 1) \\) . Solution: The formula for projecting \\( \\mathbf{a} \\) onto \\( \\mathbf{b} \\) is: \\[ \\text{Projection}_{\\mathbf{b}}(\\mathbf{a}) = \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{\\|\\mathbf{b}\\|^2} \\mathbf{b} \\] Calculate \\( \\mathbf{a} \\cdot \\mathbf{b} \\) : \\[ \\mathbf{a} \\cdot \\mathbf{b} = (2)(1) + (3)(1) = 2 + 3 = 5 \\] Calculate \\( \\|\\mathbf{b}\\|^2 \\) : \\[ \\|\\mathbf{b}\\|^2 = (1)^2 + (1)^2 = 1 + 1 = 2 \\] Compute the projection: \\[ \\text{Projection}_{\\mathbf{b}}(\\mathbf{a}) = \\frac{5}{2} \\mathbf{b} = \\frac{5}{2}(1, 1) = \\left( \\frac{5}{2}, \\frac{5}{2} \\right) \\] Answer: The projection of \\( \\mathbf{a} \\) onto \\( \\mathbf{b} \\) is \\( \\left( \\frac{5}{2}, \\frac{5}{2} \\right) \\) . Python Code: import matplotlib.pyplot as plt import numpy as np # Define vectors a = np.array([2, 3]) b = np.array([1, 1]) # Calculate the projection b_norm_squared = np.dot(b, b) projection = (np.dot(a, b) / b_norm_squared) * b # Create a plot plt.figure(figsize=(6, 6)) plt.axhline(0, color='gray', linewidth=0.5, linestyle='--') plt.axvline(0, color='gray', linewidth=0.5, linestyle='--') # Plot the vectors plt.quiver(0, 0, a[0], a[1], angles='xy', scale_units='xy', scale=1, color='blue', label='Vector a') plt.quiver(0, 0, b[0], b[1], angles='xy', scale_units='xy', scale=1, color='green', label='Vector b') plt.quiver(0, 0, projection[0], projection[1], angles='xy', scale_units='xy', scale=1, color='red', label='Projection of a onto b') # Add labels and legend plt.legend() plt.grid() plt.xlim(-1, 4) plt.ylim(-1, 4) plt.title('Vector Projection') plt.xlabel('X-axis') plt.ylabel('Y-axis') plt.show() Problem 4 : Project vector \\( \\mathbf{b} = (1, 1) \\) onto vector \\( \\mathbf{a} = (2, 3) \\) . Solution: Use the same projection formula as Problem 3. Calculate \\( \\mathbf{b} \\cdot \\mathbf{a} \\) : \\[ \\mathbf{b} \\cdot \\mathbf{a} = (1)(2) + (1)(3) = 2 + 3 = 5 \\] Calculate \\( \\|\\mathbf{a}\\|^2 \\) : \\[ \\|\\mathbf{a}\\|^2 = (2)^2 + (3)^2 = 4 + 9 = 13 \\] Compute the projection: \\[ \\text{Projection}_{\\mathbf{a}}(\\mathbf{b}) = \\frac{5}{13} \\mathbf{a} = \\frac{5}{13}(2, 3) = \\left( \\frac{10}{13}, \\frac{15}{13} \\right) \\] Answer: The projection of \\( \\mathbf{b} \\) onto \\( \\mathbf{a} \\) is \\( \\left( \\frac{10}{13}, \\frac{15}{13} \\right) \\) . Python Code: Similar to Problem 3, modify the vectors to reflect \\( a \\) and \\( b \\) . import matplotlib.pyplot as plt import numpy as np # Define vectors a = np.array([2, 3]) # Vector a b = np.array([1, 1]) # Vector b # Calculate the projection of b onto a a_norm_squared = np.dot(a, a) projection = (np.dot(b, a) / a_norm_squared) * a # Create the plot plt.figure(figsize=(6, 6)) plt.axhline(0, color='gray', linewidth=0.5, linestyle='--') plt.axvline(0, color='gray', linewidth=0.5, linestyle='--') # Plot the vectors plt.quiver(0, 0, a[0], a[1], angles='xy', scale_units='xy', scale=1, color='blue', label='Vector a') plt.quiver(0, 0, b[0], b[1], angles='xy', scale_units='xy', scale=1, color='green', label='Vector b') plt.quiver(0, 0, projection[0], projection[1], angles='xy', scale_units='xy', scale=1, color='red', label='Projection of b onto a') # Add labels, grid, legend, and title plt.legend() plt.grid() plt.title('Projection of b onto a') plt.xlabel('X-axis') plt.ylabel('Y-axis') plt.xlim(-1, 3.5) plt.ylim(-1, 3.5) # Show the plot plt.show() Equations of lines on a plane Problem 1: Find the equation of the line passing through points \\( A(1,2) \\) and \\( B(3,4) \\) . Solution: The equation of a line passing through two points \\( (x_1, y_1) \\) and \\( (x_2, y_2) \\) is given by: \\[ y - y_1 = \\frac{y_2 - y_1}{x_2 - x_1}(x - x_1) \\] Here: - \\( A(1, 2) \\) , \\( B(3, 4) \\) - \\( m = \\frac{4 - 2}{3 - 1} = \\frac{2}{2} = 1 \\) The equation becomes: \\[ y - 2 = 1(x - 1) \\] \\[ y - 2 = x - 1 \\] \\[ y = x + 1 \\] Answer: The equation of the line is \\( y = x + 1 \\) . Problem 2: Find the equation of the line passing through \\( A(1,2) \\) and parallel to \\( y = 2x + 3 \\) . Solution: The slope of the line parallel to \\( y = 2x + 3 \\) is \\( m = 2 \\) . Using the point-slope form: \\[ y - y_1 = m(x - x_1) \\] \\[ y - 2 = 2(x - 1) \\] \\[ y - 2 = 2x - 2 \\] \\[ y = 2x \\] Answer: The equation of the line is \\( y = 2x \\) . Problem 3: Find the equation of the line passing through \\( A(1,2) \\) and perpendicular to \\( y = 2x + 3 \\) . Solution: The slope of a line perpendicular to \\( y = 2x + 3 \\) is the negative reciprocal of \\( m = 2 \\) , which is \\( m = -\\frac{1}{2} \\) . Using the point-slope form: \\[ y - y_1 = m(x - x_1) \\] \\[ y - 2 = -\\frac{1}{2}(x - 1) \\] \\[ y - 2 = -\\frac{1}{2}x + \\frac{1}{2} \\] \\[ y = -\\frac{1}{2}x + \\frac{5}{2} \\] Answer: The equation of the line is \\( y = -\\frac{1}{2}x + \\frac{5}{2} \\) . Problem 4: Find the intersection point of \\( y = 2x + 3 \\) and \\( y = 3x + 2 \\) , and calculate the angle between them. Solution: Intersection Point : Set the two equations equal to each other: \\[ 2x + 3 = 3x + 2 \\] \\[ x = 1 \\] Substitute \\( x = 1 \\) into \\( y = 2x + 3 \\) : \\[ y = 2(1) + 3 = 5 \\] Intersection Point : \\( (1, 5) \\) . Angle Between the Lines : The formula for the angle \\( \\theta \\) between two lines with slopes \\( m_1 \\) and \\( m_2 \\) is: \\[ \\tan \\theta = \\left| \\frac{m_1 - m_2}{1 + m_1m_2} \\right| \\] Here: \\( m_1 = 2 \\) , \\( m_2 = 3 \\) \\[ \\tan \\theta = \\left| \\frac{2 - 3}{1 + (2)(3)} \\right| = \\left| \\frac{-1}{7} \\right| = \\frac{1}{7} \\] The angle \\( \\theta \\) is: \\[ \\theta = \\tan^{-1}\\left(\\frac{1}{7}\\right) \\] Answer: Intersection Point: \\( (1, 5) \\) , Angle: \\( \\tan^{-1}\\left(\\frac{1}{7}\\right) \\) . Equations of second-order curves (conic sections) Problem 1 : Find the equation of a circle with center \\( A(1, 2) \\) and radius \\( r = 3 \\) . Solution: The equation of a circle is: \\[ (x - h)^2 + (y - k)^2 = r^2 \\] Substitute \\( h = 1 \\) , \\( k = 2 \\) , and \\( r = 3 \\) : \\[ (x - 1)^2 + (y - 2)^2 = 3^2 \\] \\[ (x - 1)^2 + (y - 2)^2 = 9 \\] Answer: The equation of the circle is: \\[ (x - 1)^2 + (y - 2)^2 = 9 \\] Problem 2 : Find the equation of a parabola intersecting the \\( Ox \\) -axis at points \\( x = 2, x = 4 \\) , and passing through \\( y(3) = 1 \\) . Solution: The general form of a parabola intersecting the \\( Ox \\) -axis is: \\[ y = a(x - x_1)(x - x_2) \\] Here, the roots are \\( x_1 = 2 \\) and \\( x_2 = 4 \\) . So: \\[ y = a(x - 2)(x - 4) \\] Substitute \\( x = 3 \\) , \\( y = 1 \\) to find \\( a \\) : \\[ 1 = a(3 - 2)(3 - 4) \\] \\[ 1 = a(1)(-1) \\quad \\Rightarrow \\quad a = -1 \\] The equation is: \\[ y = -1(x - 2)(x - 4) \\] \\[ y = -(x^2 - 6x + 8) \\] \\[ y = -x^2 + 6x - 8 \\] Answer: The equation of the parabola is: \\[ y = -x^2 + 6x - 8 \\] Problem 3 : Find the center of the ellipse with the equation \\( x^2 + 4y^2 - 4x - 16y + 16 = 0 \\) . Solution: Rewrite the equation in standard form by completing the square: 1. Group \\( x \\) -terms and \\( y \\) -terms: \\[ (x^2 - 4x) + (4y^2 - 16y) = -16 \\] Complete the square for \\( x \\) -terms: \\[ x^2 - 4x = (x - 2)^2 - 4 \\] Complete the square for \\( y \\) -terms: \\[ 4y^2 - 16y = 4[(y^2 - 4y)] = 4[(y - 2)^2 - 4] = 4(y - 2)^2 - 16 \\] Substitute back: \\[ (x - 2)^2 - 4 + 4(y - 2)^2 - 16 = -16 \\] \\[ (x - 2)^2 + 4(y - 2)^2 = 4 \\] The standard form is: \\[ \\frac{(x - 2)^2}{4} + \\frac{(y - 2)^2}{1} = 1 \\] The center is \\( (2, 2) \\) . Answer: The center of the ellipse is \\( (2, 2) \\) . Problem 4 : Find the slope ( \\( m > 0 \\) ) of the line \\( y = mx - 5 \\) that is tangent to the circle \\( x^2 + y^2 = 1 \\) . Solution: The slope \\( m \\) satisfies the tangency condition: \\[ \\text{Distance from the center } (0, 0) \\text{ to the line } y = mx - 5 \\text{ equals the radius } r = 1. \\] The distance from \\( (0, 0) \\) to \\( y = mx - 5 \\) is: \\[ \\text{Distance} = \\frac{|c|}{\\sqrt{1 + m^2}} = \\frac{|-5|}{\\sqrt{1 + m^2}} \\] Set the distance equal to the radius: \\[ \\frac{5}{\\sqrt{1 + m^2}} = 1 \\] Solve for \\( m \\) : \\[ 5 = \\sqrt{1 + m^2} \\] \\[ 25 = 1 + m^2 \\] \\[ m^2 = 24 \\quad \\Rightarrow \\quad m = \\sqrt{24} = 2\\sqrt{6} \\] Answer: The slope of the tangent line is \\( m = 2\\sqrt{6} \\) . Problem 5 : Find the intersection points of the hyperbola \\( x^2 - y^2 = 1 \\) with the ellipse \\( x^2 + 4y^2 = 6 \\) . Solution: Substitute \\( x^2 = 1 + y^2 \\) from \\( x^2 - y^2 = 1 \\) into \\( x^2 + 4y^2 = 6 \\) : \\[ (1 + y^2) + 4y^2 = 6 \\] \\[ 1 + 5y^2 = 6 \\] \\[ 5y^2 = 5 \\quad \\Rightarrow \\quad y^2 = 1 \\quad \\Rightarrow \\quad y = \\pm 1 \\] Solve for \\( x \\) using \\( x^2 = 1 + y^2 \\) : For \\( y = 1 \\) : \\[ x^2 = 1 + 1 = 2 \\quad \\Rightarrow \\quad x = \\pm\\sqrt{2} \\] For \\( y = -1 \\) : \\[ x^2 = 1 + 1 = 2 \\quad \\Rightarrow \\quad x = \\pm\\sqrt{2} \\] Answer: The intersection points are: \\[ (\\sqrt{2}, 1), \\, (-\\sqrt{2}, 1), \\, (\\sqrt{2}, -1), \\, (-\\sqrt{2}, -1) \\] Problem 6 : Find the distance between the branches of the hyperbola \\( x^2 - y^2 = 1 \\) . Solution: For a hyperbola \\( x^2 - y^2 = a^2 \\) , the distance between the branches is given by \\( 2a \\) . Here: \\[ a^2 = 1 \\quad \\Rightarrow \\quad a = 1 \\] Answer: The distance between the branches is \\( 2 \\) . Equations of planes in space Problem 1 : Find the equation of the plane passing through points \\( A(1, 2, 3) \\) , \\( B(3, 4, 5) \\) , and \\( C(2, 1, 4) \\) . Solution: To find the equation of a plane passing through three points, we use the vector equation: \\[ \\mathbf{n} \\cdot (\\mathbf{r} - \\mathbf{r}_0) = 0 \\] Where: - \\( \\mathbf{n} \\) is the normal vector to the plane, - \\( \\mathbf{r}_0 \\) is a point on the plane (e.g., \\( A(1, 2, 3) \\) ), - \\( \\mathbf{r} \\) is a general point \\( (x, y, z) \\) . Step 1: Compute two vectors in the plane Use points \\( A, B, \\) and \\( C \\) to form vectors: \\[ \\mathbf{AB} = \\mathbf{B} - \\mathbf{A} = (3 - 1, 4 - 2, 5 - 3) = (2, 2, 2) \\] \\[ \\mathbf{AC} = \\mathbf{C} - \\mathbf{A} = (2 - 1, 1 - 2, 4 - 3) = (1, -1, 1) \\] Step 2: Compute the normal vector \\( \\mathbf{n} \\) using the cross product \\[ \\mathbf{n} = \\mathbf{AB} \\times \\mathbf{AC} = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\ 2 & 2 & 2 \\\\ 1 & -1 & 1 \\end{vmatrix} \\] \\[ \\mathbf{n} = \\mathbf{i}((2)(1) - (2)(-1)) - \\mathbf{j}((2)(1) - (2)(1)) + \\mathbf{k}((2)(-1) - (2)(1)) \\] \\[ \\mathbf{n} = \\mathbf{i}(2 + 2) - \\mathbf{j}(2 - 2) + \\mathbf{k}(-2 - 2) \\] \\[ \\mathbf{n} = 4\\mathbf{i} + 0\\mathbf{j} - 4\\mathbf{k} \\] \\[ \\mathbf{n} = (4, 0, -4) \\] Step 3: Write the equation of the plane \\[ \\mathbf{n} \\cdot (\\mathbf{r} - \\mathbf{r}_0) = 0 \\] Substitute \\( \\mathbf{n} = (4, 0, -4) \\) and \\( \\mathbf{r}_0 = (1, 2, 3) \\) : \\[ 4(x - 1) + 0(y - 2) - 4(z - 3) = 0 \\] \\[ 4x - 4 - 4z + 12 = 0 \\] \\[ 4x - 4z + 8 = 0 \\] Answer: The equation of the plane is: \\[ 4x - 4z + 8 = 0 \\] Problem 2 : Find the equation of the plane passing through \\( A(1, 2, 3) \\) and parallel to the plane \\( 2x + 3y + 4z = 5 \\) . Solution: For a plane parallel to another plane, the normal vector remains the same. So, the normal vector of the plane is \\( \\mathbf{n} = [2, 3, 4] \\) . Substitute \\( \\mathbf{r}_0 = (1, 2, 3) \\) into the general equation: \\[ 2(x - 1) + 3(y - 2) + 4(z - 3) = 0 \\] Simplify: \\[ 2x - 2 + 3y - 6 + 4z - 12 = 0 \\] \\[ 2x + 3y + 4z - 20 = 0 \\] Answer: The equation of the plane is: \\[ 2x + 3y + 4z - 20 = 0 \\] Equations of second-order surfaces Problem 1 : Write the equation of a sphere with center at point \\( P = (1, 2, 3) \\) and radius \\( r = 3 \\) . Solution: The general equation of a sphere is given by: \\[ (x - h)^2 + (y - k)^2 + (z - l)^2 = r^2 \\] Substitute the center coordinates \\( h = 1, k = 2, l = 3 \\) and the radius \\( r = 3 \\) : \\[ (x - 1)^2 + (y - 2)^2 + (z - 3)^2 = 9 \\] Answer: The equation of the sphere is: \\[ (x - 1)^2 + (y - 2)^2 + (z - 3)^2 = 9 \\] Problem 2 : Do the spheres with equations \\( x^2 + y^2 + z^2 = 1 \\) and \\( x^2 + y^2 + z^2 = 2 \\) have any common points? Solution: The spheres \\( x^2 + y^2 + z^2 = 1 \\) and \\( x^2 + y^2 + z^2 = 2 \\) are concentric, as they both have the same center at \\( (0, 0, 0) \\) but different radii: - The first sphere has radius \\( r_1 = 1 \\) , - The second sphere has radius \\( r_2 = \\sqrt{2} \\) . Since the radii are different, the spheres do not intersect and have no common points . Answer: No, the spheres do not have any common points. Problem 3 : What curve in space is formed by the intersection of the sphere \\( x^2 + y^2 + z^2 = 1 \\) with the sphere \\( (x - 1)^2 + y^2 + z^2 = 1 \\) ? Find the equation of this curve. Solution: To find the intersection curve: 1. Write both sphere equations: - Sphere 1: \\( x^2 + y^2 + z^2 = 1 \\) , - Sphere 2: \\( (x - 1)^2 + y^2 + z^2 = 1 \\) . Expand Sphere 2: \\[ (x - 1)^2 + y^2 + z^2 = x^2 - 2x + 1 + y^2 + z^2 = 1 \\] Simplify: \\[ x^2 - 2x + 1 + y^2 + z^2 = 1 \\quad \\Rightarrow \\quad x^2 + y^2 + z^2 - 2x = 0 \\] Substitute \\( x^2 + y^2 + z^2 = 1 \\) (from Sphere 1) into Sphere 2: \\[ 1 - 2x = 0 \\quad \\Rightarrow \\quad x = \\frac{1}{2} \\] The intersection curve is a circle in the plane \\( x = \\frac{1}{2} \\) with radius: Substitute \\( x = \\frac{1}{2} \\) into Sphere 1: \\[ \\left(\\frac{1}{2}\\right)^2 + y^2 + z^2 = 1 \\quad \\Rightarrow \\quad \\frac{1}{4} + y^2 + z^2 = 1 \\] Simplify: \\[ y^2 + z^2 = \\frac{3}{4} \\] Answer: The intersection curve is a circle in the plane \\( x = \\frac{1}{2} \\) with the equation: \\[ y^2 + z^2 = \\frac{3}{4} \\] Problem 4 : Write the equation of the tangent plane to the paraboloid \\( z = (x - 1)^2 + y^2 + 1 \\) at point \\( P(1, 0, 1) \\) . Solution: The equation of the tangent plane to a surface \\( z = f(x, y) \\) at point \\( P(x_0, y_0, z_0) \\) is: \\[ z - z_0 = f_x(x_0, y_0)(x - x_0) + f_y(x_0, y_0)(y - y_0) \\] Where \\( f_x \\) and \\( f_y \\) are partial derivatives of \\( f(x, y) \\) . Given \\( f(x, y) = (x - 1)^2 + y^2 + 1 \\) , calculate partial derivatives: \\( f_x = 2(x - 1) \\) , \\( f_y = 2y \\) . Evaluate at \\( P(1, 0, 1) \\) : \\( f_x(1, 0) = 2(1 - 1) = 0 \\) , \\( f_y(1, 0) = 2(0) = 0 \\) . Write the tangent plane equation: \\[ z - z_0 = 0(x - 1) + 0(y - 0) \\] \\[ z - 1 = 0 \\quad \\Rightarrow \\quad z = 1 \\] Answer: The equation of the tangent plane is: \\[ z = 1 \\]","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#vectors-i","text":"","title":"Vectors I"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-1","text":"Question: By what number should vector a = [3, 4] be multiplied so that its length is equal to 1? Solution: 1. The length of a vector v = [x, y] is calculated as: \\[ \\|v\\| = \\sqrt{x^2 + y^2} \\] For vector a = [3, 4]: \\[ \\|a\\| = \\sqrt{3^2 + 4^2} = \\sqrt{9 + 16} = 5 \\] To make the length of the vector equal to 1, divide each component of the vector by its length: \\[ \\text{Multiplier} = \\frac{1}{\\|a\\|} = \\frac{1}{5} \\] Answer: Vector a should be multiplied by \\( \\frac{1}{5} \\) .","title":"Problem 1"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-2","text":"Question: Calculate the length of vector b = [1, 1] and find the unit vector of this vector. Solution: 1. The length of vector b is: \\[ \\|b\\| = \\sqrt{1^2 + 1^2} = \\sqrt{1 + 1} = \\sqrt{2} \\] The unit vector of b is obtained by dividing each component of the vector by its length: \\[ \\text{Unit vector of } \\mathbf{b} = \\frac{\\mathbf{b}}{\\|b\\|} = \\frac{1}{\\sqrt{2}}[1, 1] = \\left[\\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}\\right] \\] Answer: Length of b = \\( \\sqrt{2} \\) , Unit vector of b = \\([ \\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}} ]\\) .","title":"Problem 2"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-3","text":"Question: Plot the vector and the unit vector from the previous exercise. Solution: To visualize, plot the vector b = [1, 1] and its unit vector \\([ \\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}} ]\\) on a Cartesian plane. The unit vector will have the same direction as b , but its length will be 1. import matplotlib.pyplot as plt import numpy as np # Define the vector and its unit vector vector_b = np.array([1, 1]) unit_vector_b = vector_b / np.linalg.norm(vector_b) # Create a figure and axis plt.figure(figsize=(6, 6)) plt.axhline(0, color='gray', linewidth=0.5, linestyle='--') plt.axvline(0, color='gray', linewidth=0.5, linestyle='--') # Plot the vector b plt.quiver(0, 0, vector_b[0], vector_b[1], angles='xy', scale_units='xy', scale=1, color='blue', label='Vector b') # Plot the unit vector of b plt.quiver(0, 0, unit_vector_b[0], unit_vector_b[1], angles='xy', scale_units='xy', scale=1, color='green', label='Unit Vector of b') # Set plot limits plt.xlim(-1.5, 1.5) plt.ylim(-1.5, 1.5) # Add labels, legend, and title plt.legend() plt.grid() plt.title(\"Vector and Unit Vector\") plt.xlabel(\"X\") plt.ylabel(\"Y\") # Show the plot plt.show()","title":"Problem 3"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-4","text":"Question: Calculate the length of vector c = [1, 2, 3] and find the unit vector of this vector. Solution: 1. The length of vector c is: \\[ \\|c\\| = \\sqrt{1^2 + 2^2 + 3^2} = \\sqrt{1 + 4 + 9} = \\sqrt{14} \\] The unit vector of c is: \\[ \\text{Unit vector of } \\mathbf{c} = \\frac{\\mathbf{c}}{\\|c\\|} = \\frac{1}{\\sqrt{14}}[1, 2, 3] = \\left[\\frac{1}{\\sqrt{14}}, \\frac{2}{\\sqrt{14}}, \\frac{3}{\\sqrt{14}}\\right] \\] Answer: Length of c = \\( \\sqrt{14} \\) , Unit vector of c = \\([ \\frac{1}{\\sqrt{14}}, \\frac{2}{\\sqrt{14}}, \\frac{3}{\\sqrt{14}} ]\\) .","title":"Problem 4"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-5","text":"Question: Find the Cartesian coordinates of vector v = [2, 3, 4] in the basis: \\[ \\{\\mathbf{b_1} = [1, 0, 1], \\mathbf{b_2} = [0, 1, 0], \\mathbf{b_3} = [1, 0, -1]\\}. \\] Solution: Let vector v = [2, 3, 4] be represented in the given basis as: \\[ \\mathbf{v} = c_1 \\mathbf{b_1} + c_2 \\mathbf{b_2} + c_3 \\mathbf{b_3}, \\] where \\( \\mathbf{b_1} = [1, 0, 1] \\) , \\( \\mathbf{b_2} = [0, 1, 0] \\) , and \\( \\mathbf{b_3} = [1, 0, -1] \\) . Set up the system of equations: \\[ \\begin{cases} c_1(1) + c_2(0) + c_3(1) = 2, \\\\ c_1(0) + c_2(1) + c_3(0) = 3, \\\\ c_1(1) + c_2(0) - c_3(1) = 4. \\end{cases} \\] Simplify: 1. From the first equation: \\( c_1 + c_3 = 2 \\) . 2. From the second equation: \\( c_2 = 3 \\) . 3. From the third equation: \\( c_1 - c_3 = 4 \\) . Solve for \\( c_1 \\) and \\( c_3 \\) : Add \\( c_1 + c_3 = 2 \\) and \\( c_1 - c_3 = 4 \\) : \\[ 2c_1 = 6 \\quad \\Rightarrow \\quad c_1 = 3. \\] Substitute \\( c_1 = 3 \\) into \\( c_1 + c_3 = 2 \\) : \\[ 3 + c_3 = 2 \\quad \\Rightarrow \\quad c_3 = -1. \\] Answer: Cartesian coordinates in the given basis: \\( c_1 = 3, c_2 = 3, c_3 = -1 \\) .","title":"Problem 5"},{"location":"2%20Mathematics/2%20Analytic_geometry/#vectors-ii","text":"","title":"Vectors II"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-1-perform-vector-addition-and-plot-both-vectors-along-with-their-sum","text":"","title":"Problem 1: Perform vector addition and plot both vectors along with their sum"},{"location":"2%20Mathematics/2%20Analytic_geometry/#given","text":"Vector 1 : [2, 1] Vector 2 : [-1, 1]","title":"Given:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#solution","text":"Add the vectors component-wise: \\[ [2, 1] + [-1, 1] = [2 + (-1), 1 + 1] = [1, 2] \\] Answer : The sum of the vectors is \\([1, 2]\\) .","title":"Solution:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#python-code-for-plotting","text":"import matplotlib.pyplot as plt import numpy as np # Define the vectors vector_1 = np.array([2, 1]) vector_2 = np.array([-1, 1]) vector_sum = vector_1 + vector_2 # Create a figure and axis plt.figure(figsize=(8, 8)) # Plot vectors plt.quiver(0, 0, vector_1[0], vector_1[1], angles='xy', scale_units='xy', scale=1, color='blue', label='Vector 1: [2, 1]') plt.quiver(0, 0, vector_2[0], vector_2[1], angles='xy', scale_units='xy', scale=1, color='green', label='Vector 2: [-1, 1]') plt.quiver(0, 0, vector_sum[0], vector_sum[1], angles='xy', scale_units='xy', scale=1, color='red', label='Sum: [1, 2]') # Add labels, grid, legend, and title plt.axhline(0, color='gray', linewidth=0.5, linestyle='--') plt.axvline(0, color='gray', linewidth=0.5, linestyle='--') plt.grid() plt.legend() plt.xlim(-2, 3) plt.ylim(-2, 3) plt.title(\"Vector Addition\") plt.xlabel(\"X-axis\") plt.ylabel(\"Y-axis\") # Show the plot plt.show()","title":"Python Code for Plotting:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-2-calculate-the-area-of-the-triangle-spanned-by-vectors","text":"","title":"Problem 2: Calculate the area of the triangle spanned by vectors"},{"location":"2%20Mathematics/2%20Analytic_geometry/#given_1","text":"Vectors: u = [2, 1, 2], v = [-1, 1, 1]","title":"Given:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#solution_1","text":"Compute the cross product \\( \\mathbf{u} \\times \\mathbf{v} \\) : \\[ \\mathbf{u} \\times \\mathbf{v} = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\ 2 & 1 & 2 \\\\ -1 & 1 & 1 \\end{vmatrix} = \\mathbf{i}(1 \\cdot 1 - 2 \\cdot 1) - \\mathbf{j}(2 \\cdot 1 - (-1) \\cdot 2) + \\mathbf{k}(2 \\cdot 1 - (-1) \\cdot 1) \\] \\[ = \\mathbf{i}(1 - 2) - \\mathbf{j}(2 + 2) + \\mathbf{k}(2 + 1) \\] \\[ = -\\mathbf{i} - 4\\mathbf{j} + 3\\mathbf{k} \\] Cross product result: \\([-1, -4, 3]\\) . Compute the magnitude of the cross product: \\[ \\|\\mathbf{u} \\times \\mathbf{v}\\| = \\sqrt{(-1)^2 + (-4)^2 + 3^2} = \\sqrt{1 + 16 + 9} = \\sqrt{26} \\] The area of the triangle is half the magnitude: \\[ \\text{Area} = \\frac{1}{2} \\|\\mathbf{u} \\times \\mathbf{v}\\| = \\frac{1}{2} \\sqrt{26} \\]","title":"Solution:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#answer","text":"The area of the triangle is \\( \\frac{\\sqrt{26}}{2} \\) .","title":"Answer:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-3-calculate-the-volume-of-the-parallelepiped-spanned-by-vectors","text":"","title":"Problem 3: Calculate the volume of the parallelepiped spanned by vectors"},{"location":"2%20Mathematics/2%20Analytic_geometry/#given_2","text":"Vectors: a = [2, 1, -1], b = [-1, 1, 0], c = [1, 2, 1]","title":"Given:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#solution_2","text":"Compute the scalar triple product \\( \\mathbf{a} \\cdot (\\mathbf{b} \\times \\mathbf{c}) \\) . Compute \\( \\mathbf{b} \\times \\mathbf{c} \\) : \\[ \\mathbf{b} \\times \\mathbf{c} = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\ -1 & 1 & 0 \\\\ 1 & 2 & 1 \\end{vmatrix} = \\mathbf{i}(1 \\cdot 1 - 0 \\cdot 2) - \\mathbf{j}((-1) \\cdot 1 - 0 \\cdot 1) + \\mathbf{k}((-1) \\cdot 2 - 1 \\cdot 1) \\] \\[ = \\mathbf{i}(1) - \\mathbf{j}(-1) + \\mathbf{k}(-2 - 1) \\] \\[ = \\mathbf{i}(1) + \\mathbf{j}(1) + \\mathbf{k}(-3) \\] Result: \\( [1, 1, -3] \\) . Compute \\( \\mathbf{a} \\cdot (\\mathbf{b} \\times \\mathbf{c}) \\) : \\[ \\mathbf{a} \\cdot [1, 1, -3] = (2)(1) + (1)(1) + (-1)(-3) = 2 + 1 + 3 = 6 \\] The volume of the parallelepiped is the absolute value of the scalar triple product: \\[ \\text{Volume} = |6| = 6 \\]","title":"Solution:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#answer_1","text":"The volume of the parallelepiped is \\( 6 \\) .","title":"Answer:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#vectors-iii","text":"","title":"Vectors III"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-1-divide-the-line-segment-connecting-a-1-2-and-b3-2-in-the-ratio-1-3","text":"","title":"Problem 1: Divide the line segment connecting \\( A(-1, 2) \\) and \\( B(3, -2) \\) in the ratio \\( 1 : 3 \\)."},{"location":"2%20Mathematics/2%20Analytic_geometry/#solution_3","text":"The formula to divide a line segment in the ratio \\( m : n \\) is: \\[ P(x, y) = \\left( \\frac{mx_2 + nx_1}{m+n}, \\frac{my_2 + ny_1}{m+n} \\right) \\] Here: - \\( A(x_1, y_1) = (-1, 2) \\) - \\( B(x_2, y_2) = (3, -2) \\) - Ratio \\( m : n = 1 : 3 \\) Substitute into the formula: \\[ P(x, y) = \\left( \\frac{1(3) + 3(-1)}{1+3}, \\frac{1(-2) + 3(2)}{1+3} \\right) \\] \\[ P(x, y) = \\left( \\frac{3 - 3}{4}, \\frac{-2 + 6}{4} \\right) \\] \\[ P(x, y) = (0, 1) \\] Answer: The point dividing the line in the ratio \\( 1:3 \\) is \\( (0, 1) \\) .","title":"Solution:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-2-project-vector-mathbfa-3-4-onto-the-ox-axis-and-oy-axis","text":"","title":"Problem 2: Project vector \\( \\mathbf{a} = (3, 4) \\) onto the \\( OX \\)-axis and \\( OY \\)-axis."},{"location":"2%20Mathematics/2%20Analytic_geometry/#solution_4","text":"To project a vector onto an axis: - Onto the \\( OX \\) -axis: Set the \\( y \\) -component to 0. - Onto the \\( OY \\) -axis: Set the \\( x \\) -component to 0. For \\( \\mathbf{a} = (3, 4) \\) : - Projection onto \\( OX \\) : \\( (3, 0) \\) - Projection onto \\( OY \\) : \\( (0, 4) \\) Answer: - Projection onto \\( OX \\) : \\( (3, 0) \\) - Projection onto \\( OY \\) : \\( (0, 4) \\)","title":"Solution:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-3-project-vector-mathbfa-2-3-onto-vector-mathbfb-1-1","text":"","title":"Problem 3: Project vector \\( \\mathbf{a} = (2, 3) \\) onto vector \\( \\mathbf{b} = (1, 1) \\)."},{"location":"2%20Mathematics/2%20Analytic_geometry/#solution_5","text":"The formula for projecting \\( \\mathbf{a} \\) onto \\( \\mathbf{b} \\) is: \\[ \\text{Projection}_{\\mathbf{b}}(\\mathbf{a}) = \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{\\|\\mathbf{b}\\|^2} \\mathbf{b} \\] Calculate \\( \\mathbf{a} \\cdot \\mathbf{b} \\) : \\[ \\mathbf{a} \\cdot \\mathbf{b} = (2)(1) + (3)(1) = 2 + 3 = 5 \\] Calculate \\( \\|\\mathbf{b}\\|^2 \\) : \\[ \\|\\mathbf{b}\\|^2 = (1)^2 + (1)^2 = 1 + 1 = 2 \\] Compute the projection: \\[ \\text{Projection}_{\\mathbf{b}}(\\mathbf{a}) = \\frac{5}{2} \\mathbf{b} = \\frac{5}{2}(1, 1) = \\left( \\frac{5}{2}, \\frac{5}{2} \\right) \\] Answer: The projection of \\( \\mathbf{a} \\) onto \\( \\mathbf{b} \\) is \\( \\left( \\frac{5}{2}, \\frac{5}{2} \\right) \\) .","title":"Solution:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#python-code","text":"import matplotlib.pyplot as plt import numpy as np # Define vectors a = np.array([2, 3]) b = np.array([1, 1]) # Calculate the projection b_norm_squared = np.dot(b, b) projection = (np.dot(a, b) / b_norm_squared) * b # Create a plot plt.figure(figsize=(6, 6)) plt.axhline(0, color='gray', linewidth=0.5, linestyle='--') plt.axvline(0, color='gray', linewidth=0.5, linestyle='--') # Plot the vectors plt.quiver(0, 0, a[0], a[1], angles='xy', scale_units='xy', scale=1, color='blue', label='Vector a') plt.quiver(0, 0, b[0], b[1], angles='xy', scale_units='xy', scale=1, color='green', label='Vector b') plt.quiver(0, 0, projection[0], projection[1], angles='xy', scale_units='xy', scale=1, color='red', label='Projection of a onto b') # Add labels and legend plt.legend() plt.grid() plt.xlim(-1, 4) plt.ylim(-1, 4) plt.title('Vector Projection') plt.xlabel('X-axis') plt.ylabel('Y-axis') plt.show()","title":"Python Code:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-4-project-vector-mathbfb-1-1-onto-vector-mathbfa-2-3","text":"","title":"Problem 4: Project vector \\( \\mathbf{b} = (1, 1) \\) onto vector \\( \\mathbf{a} = (2, 3) \\)."},{"location":"2%20Mathematics/2%20Analytic_geometry/#solution_6","text":"Use the same projection formula as Problem 3. Calculate \\( \\mathbf{b} \\cdot \\mathbf{a} \\) : \\[ \\mathbf{b} \\cdot \\mathbf{a} = (1)(2) + (1)(3) = 2 + 3 = 5 \\] Calculate \\( \\|\\mathbf{a}\\|^2 \\) : \\[ \\|\\mathbf{a}\\|^2 = (2)^2 + (3)^2 = 4 + 9 = 13 \\] Compute the projection: \\[ \\text{Projection}_{\\mathbf{a}}(\\mathbf{b}) = \\frac{5}{13} \\mathbf{a} = \\frac{5}{13}(2, 3) = \\left( \\frac{10}{13}, \\frac{15}{13} \\right) \\] Answer: The projection of \\( \\mathbf{b} \\) onto \\( \\mathbf{a} \\) is \\( \\left( \\frac{10}{13}, \\frac{15}{13} \\right) \\) .","title":"Solution:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#python-code_1","text":"Similar to Problem 3, modify the vectors to reflect \\( a \\) and \\( b \\) . import matplotlib.pyplot as plt import numpy as np # Define vectors a = np.array([2, 3]) # Vector a b = np.array([1, 1]) # Vector b # Calculate the projection of b onto a a_norm_squared = np.dot(a, a) projection = (np.dot(b, a) / a_norm_squared) * a # Create the plot plt.figure(figsize=(6, 6)) plt.axhline(0, color='gray', linewidth=0.5, linestyle='--') plt.axvline(0, color='gray', linewidth=0.5, linestyle='--') # Plot the vectors plt.quiver(0, 0, a[0], a[1], angles='xy', scale_units='xy', scale=1, color='blue', label='Vector a') plt.quiver(0, 0, b[0], b[1], angles='xy', scale_units='xy', scale=1, color='green', label='Vector b') plt.quiver(0, 0, projection[0], projection[1], angles='xy', scale_units='xy', scale=1, color='red', label='Projection of b onto a') # Add labels, grid, legend, and title plt.legend() plt.grid() plt.title('Projection of b onto a') plt.xlabel('X-axis') plt.ylabel('Y-axis') plt.xlim(-1, 3.5) plt.ylim(-1, 3.5) # Show the plot plt.show()","title":"Python Code:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#equations-of-lines-on-a-plane","text":"","title":"Equations of lines on a plane"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-1-find-the-equation-of-the-line-passing-through-points-a12-and-b34","text":"","title":"Problem 1: Find the equation of the line passing through points \\( A(1,2) \\) and \\( B(3,4) \\)."},{"location":"2%20Mathematics/2%20Analytic_geometry/#solution_7","text":"The equation of a line passing through two points \\( (x_1, y_1) \\) and \\( (x_2, y_2) \\) is given by: \\[ y - y_1 = \\frac{y_2 - y_1}{x_2 - x_1}(x - x_1) \\] Here: - \\( A(1, 2) \\) , \\( B(3, 4) \\) - \\( m = \\frac{4 - 2}{3 - 1} = \\frac{2}{2} = 1 \\) The equation becomes: \\[ y - 2 = 1(x - 1) \\] \\[ y - 2 = x - 1 \\] \\[ y = x + 1 \\] Answer: The equation of the line is \\( y = x + 1 \\) .","title":"Solution:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-2-find-the-equation-of-the-line-passing-through-a12-and-parallel-to-y-2x-3","text":"","title":"Problem 2: Find the equation of the line passing through \\( A(1,2) \\) and parallel to \\( y = 2x + 3 \\)."},{"location":"2%20Mathematics/2%20Analytic_geometry/#solution_8","text":"The slope of the line parallel to \\( y = 2x + 3 \\) is \\( m = 2 \\) . Using the point-slope form: \\[ y - y_1 = m(x - x_1) \\] \\[ y - 2 = 2(x - 1) \\] \\[ y - 2 = 2x - 2 \\] \\[ y = 2x \\] Answer: The equation of the line is \\( y = 2x \\) .","title":"Solution:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-3-find-the-equation-of-the-line-passing-through-a12-and-perpendicular-to-y-2x-3","text":"","title":"Problem 3: Find the equation of the line passing through \\( A(1,2) \\) and perpendicular to \\( y = 2x + 3 \\)."},{"location":"2%20Mathematics/2%20Analytic_geometry/#solution_9","text":"The slope of a line perpendicular to \\( y = 2x + 3 \\) is the negative reciprocal of \\( m = 2 \\) , which is \\( m = -\\frac{1}{2} \\) . Using the point-slope form: \\[ y - y_1 = m(x - x_1) \\] \\[ y - 2 = -\\frac{1}{2}(x - 1) \\] \\[ y - 2 = -\\frac{1}{2}x + \\frac{1}{2} \\] \\[ y = -\\frac{1}{2}x + \\frac{5}{2} \\] Answer: The equation of the line is \\( y = -\\frac{1}{2}x + \\frac{5}{2} \\) .","title":"Solution:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-4-find-the-intersection-point-of-y-2x-3-and-y-3x-2-and-calculate-the-angle-between-them","text":"","title":"Problem 4: Find the intersection point of \\( y = 2x + 3 \\) and \\( y = 3x + 2 \\), and calculate the angle between them."},{"location":"2%20Mathematics/2%20Analytic_geometry/#solution_10","text":"Intersection Point : Set the two equations equal to each other: \\[ 2x + 3 = 3x + 2 \\] \\[ x = 1 \\] Substitute \\( x = 1 \\) into \\( y = 2x + 3 \\) : \\[ y = 2(1) + 3 = 5 \\] Intersection Point : \\( (1, 5) \\) . Angle Between the Lines : The formula for the angle \\( \\theta \\) between two lines with slopes \\( m_1 \\) and \\( m_2 \\) is: \\[ \\tan \\theta = \\left| \\frac{m_1 - m_2}{1 + m_1m_2} \\right| \\] Here: \\( m_1 = 2 \\) , \\( m_2 = 3 \\) \\[ \\tan \\theta = \\left| \\frac{2 - 3}{1 + (2)(3)} \\right| = \\left| \\frac{-1}{7} \\right| = \\frac{1}{7} \\] The angle \\( \\theta \\) is: \\[ \\theta = \\tan^{-1}\\left(\\frac{1}{7}\\right) \\] Answer: Intersection Point: \\( (1, 5) \\) , Angle: \\( \\tan^{-1}\\left(\\frac{1}{7}\\right) \\) .","title":"Solution:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#equations-of-second-order-curves-conic-sections","text":"","title":"Equations of second-order curves (conic sections)"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-1-find-the-equation-of-a-circle-with-center-a1-2-and-radius-r-3","text":"","title":"Problem 1: Find the equation of a circle with center \\( A(1, 2) \\) and radius \\( r = 3 \\)."},{"location":"2%20Mathematics/2%20Analytic_geometry/#solution_11","text":"The equation of a circle is: \\[ (x - h)^2 + (y - k)^2 = r^2 \\] Substitute \\( h = 1 \\) , \\( k = 2 \\) , and \\( r = 3 \\) : \\[ (x - 1)^2 + (y - 2)^2 = 3^2 \\] \\[ (x - 1)^2 + (y - 2)^2 = 9 \\] Answer: The equation of the circle is: \\[ (x - 1)^2 + (y - 2)^2 = 9 \\]","title":"Solution:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-2-find-the-equation-of-a-parabola-intersecting-the-ox-axis-at-points-x-2-x-4-and-passing-through-y3-1","text":"","title":"Problem 2: Find the equation of a parabola intersecting the \\( Ox \\)-axis at points \\( x = 2, x = 4 \\), and passing through \\( y(3) = 1 \\)."},{"location":"2%20Mathematics/2%20Analytic_geometry/#solution_12","text":"The general form of a parabola intersecting the \\( Ox \\) -axis is: \\[ y = a(x - x_1)(x - x_2) \\] Here, the roots are \\( x_1 = 2 \\) and \\( x_2 = 4 \\) . So: \\[ y = a(x - 2)(x - 4) \\] Substitute \\( x = 3 \\) , \\( y = 1 \\) to find \\( a \\) : \\[ 1 = a(3 - 2)(3 - 4) \\] \\[ 1 = a(1)(-1) \\quad \\Rightarrow \\quad a = -1 \\] The equation is: \\[ y = -1(x - 2)(x - 4) \\] \\[ y = -(x^2 - 6x + 8) \\] \\[ y = -x^2 + 6x - 8 \\] Answer: The equation of the parabola is: \\[ y = -x^2 + 6x - 8 \\]","title":"Solution:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-3-find-the-center-of-the-ellipse-with-the-equation-x2-4y2-4x-16y-16-0","text":"","title":"Problem 3: Find the center of the ellipse with the equation \\( x^2 + 4y^2 - 4x - 16y + 16 = 0 \\)."},{"location":"2%20Mathematics/2%20Analytic_geometry/#solution_13","text":"Rewrite the equation in standard form by completing the square: 1. Group \\( x \\) -terms and \\( y \\) -terms: \\[ (x^2 - 4x) + (4y^2 - 16y) = -16 \\] Complete the square for \\( x \\) -terms: \\[ x^2 - 4x = (x - 2)^2 - 4 \\] Complete the square for \\( y \\) -terms: \\[ 4y^2 - 16y = 4[(y^2 - 4y)] = 4[(y - 2)^2 - 4] = 4(y - 2)^2 - 16 \\] Substitute back: \\[ (x - 2)^2 - 4 + 4(y - 2)^2 - 16 = -16 \\] \\[ (x - 2)^2 + 4(y - 2)^2 = 4 \\] The standard form is: \\[ \\frac{(x - 2)^2}{4} + \\frac{(y - 2)^2}{1} = 1 \\] The center is \\( (2, 2) \\) . Answer: The center of the ellipse is \\( (2, 2) \\) .","title":"Solution:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-4-find-the-slope-m-0-of-the-line-y-mx-5-that-is-tangent-to-the-circle-x2-y2-1","text":"","title":"Problem 4: Find the slope (\\( m &gt; 0 \\)) of the line \\( y = mx - 5 \\) that is tangent to the circle \\( x^2 + y^2 = 1 \\)."},{"location":"2%20Mathematics/2%20Analytic_geometry/#solution_14","text":"The slope \\( m \\) satisfies the tangency condition: \\[ \\text{Distance from the center } (0, 0) \\text{ to the line } y = mx - 5 \\text{ equals the radius } r = 1. \\] The distance from \\( (0, 0) \\) to \\( y = mx - 5 \\) is: \\[ \\text{Distance} = \\frac{|c|}{\\sqrt{1 + m^2}} = \\frac{|-5|}{\\sqrt{1 + m^2}} \\] Set the distance equal to the radius: \\[ \\frac{5}{\\sqrt{1 + m^2}} = 1 \\] Solve for \\( m \\) : \\[ 5 = \\sqrt{1 + m^2} \\] \\[ 25 = 1 + m^2 \\] \\[ m^2 = 24 \\quad \\Rightarrow \\quad m = \\sqrt{24} = 2\\sqrt{6} \\] Answer: The slope of the tangent line is \\( m = 2\\sqrt{6} \\) .","title":"Solution:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-5-find-the-intersection-points-of-the-hyperbola-x2-y2-1-with-the-ellipse-x2-4y2-6","text":"","title":"Problem 5: Find the intersection points of the hyperbola \\( x^2 - y^2 = 1 \\) with the ellipse \\( x^2 + 4y^2 = 6 \\)."},{"location":"2%20Mathematics/2%20Analytic_geometry/#solution_15","text":"Substitute \\( x^2 = 1 + y^2 \\) from \\( x^2 - y^2 = 1 \\) into \\( x^2 + 4y^2 = 6 \\) : \\[ (1 + y^2) + 4y^2 = 6 \\] \\[ 1 + 5y^2 = 6 \\] \\[ 5y^2 = 5 \\quad \\Rightarrow \\quad y^2 = 1 \\quad \\Rightarrow \\quad y = \\pm 1 \\] Solve for \\( x \\) using \\( x^2 = 1 + y^2 \\) : For \\( y = 1 \\) : \\[ x^2 = 1 + 1 = 2 \\quad \\Rightarrow \\quad x = \\pm\\sqrt{2} \\] For \\( y = -1 \\) : \\[ x^2 = 1 + 1 = 2 \\quad \\Rightarrow \\quad x = \\pm\\sqrt{2} \\] Answer: The intersection points are: \\[ (\\sqrt{2}, 1), \\, (-\\sqrt{2}, 1), \\, (\\sqrt{2}, -1), \\, (-\\sqrt{2}, -1) \\]","title":"Solution:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-6-find-the-distance-between-the-branches-of-the-hyperbola-x2-y2-1","text":"","title":"Problem 6: Find the distance between the branches of the hyperbola \\( x^2 - y^2 = 1 \\)."},{"location":"2%20Mathematics/2%20Analytic_geometry/#solution_16","text":"For a hyperbola \\( x^2 - y^2 = a^2 \\) , the distance between the branches is given by \\( 2a \\) . Here: \\[ a^2 = 1 \\quad \\Rightarrow \\quad a = 1 \\] Answer: The distance between the branches is \\( 2 \\) .","title":"Solution:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#equations-of-planes-in-space","text":"","title":"Equations of planes in space"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-1-find-the-equation-of-the-plane-passing-through-points-a1-2-3-b3-4-5-and-c2-1-4","text":"","title":"Problem 1: Find the equation of the plane passing through points \\( A(1, 2, 3) \\), \\( B(3, 4, 5) \\), and \\( C(2, 1, 4) \\)."},{"location":"2%20Mathematics/2%20Analytic_geometry/#solution_17","text":"To find the equation of a plane passing through three points, we use the vector equation: \\[ \\mathbf{n} \\cdot (\\mathbf{r} - \\mathbf{r}_0) = 0 \\] Where: - \\( \\mathbf{n} \\) is the normal vector to the plane, - \\( \\mathbf{r}_0 \\) is a point on the plane (e.g., \\( A(1, 2, 3) \\) ), - \\( \\mathbf{r} \\) is a general point \\( (x, y, z) \\) .","title":"Solution:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#step-1-compute-two-vectors-in-the-plane","text":"Use points \\( A, B, \\) and \\( C \\) to form vectors: \\[ \\mathbf{AB} = \\mathbf{B} - \\mathbf{A} = (3 - 1, 4 - 2, 5 - 3) = (2, 2, 2) \\] \\[ \\mathbf{AC} = \\mathbf{C} - \\mathbf{A} = (2 - 1, 1 - 2, 4 - 3) = (1, -1, 1) \\]","title":"Step 1: Compute two vectors in the plane"},{"location":"2%20Mathematics/2%20Analytic_geometry/#step-2-compute-the-normal-vector-mathbfn-using-the-cross-product","text":"\\[ \\mathbf{n} = \\mathbf{AB} \\times \\mathbf{AC} = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\ 2 & 2 & 2 \\\\ 1 & -1 & 1 \\end{vmatrix} \\] \\[ \\mathbf{n} = \\mathbf{i}((2)(1) - (2)(-1)) - \\mathbf{j}((2)(1) - (2)(1)) + \\mathbf{k}((2)(-1) - (2)(1)) \\] \\[ \\mathbf{n} = \\mathbf{i}(2 + 2) - \\mathbf{j}(2 - 2) + \\mathbf{k}(-2 - 2) \\] \\[ \\mathbf{n} = 4\\mathbf{i} + 0\\mathbf{j} - 4\\mathbf{k} \\] \\[ \\mathbf{n} = (4, 0, -4) \\]","title":"Step 2: Compute the normal vector \\( \\mathbf{n} \\) using the cross product"},{"location":"2%20Mathematics/2%20Analytic_geometry/#step-3-write-the-equation-of-the-plane","text":"\\[ \\mathbf{n} \\cdot (\\mathbf{r} - \\mathbf{r}_0) = 0 \\] Substitute \\( \\mathbf{n} = (4, 0, -4) \\) and \\( \\mathbf{r}_0 = (1, 2, 3) \\) : \\[ 4(x - 1) + 0(y - 2) - 4(z - 3) = 0 \\] \\[ 4x - 4 - 4z + 12 = 0 \\] \\[ 4x - 4z + 8 = 0 \\] Answer: The equation of the plane is: \\[ 4x - 4z + 8 = 0 \\]","title":"Step 3: Write the equation of the plane"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-2-find-the-equation-of-the-plane-passing-through-a1-2-3-and-parallel-to-the-plane-2x-3y-4z-5","text":"","title":"Problem 2: Find the equation of the plane passing through \\( A(1, 2, 3) \\) and parallel to the plane \\( 2x + 3y + 4z = 5 \\)."},{"location":"2%20Mathematics/2%20Analytic_geometry/#solution_18","text":"For a plane parallel to another plane, the normal vector remains the same. So, the normal vector of the plane is \\( \\mathbf{n} = [2, 3, 4] \\) . Substitute \\( \\mathbf{r}_0 = (1, 2, 3) \\) into the general equation: \\[ 2(x - 1) + 3(y - 2) + 4(z - 3) = 0 \\] Simplify: \\[ 2x - 2 + 3y - 6 + 4z - 12 = 0 \\] \\[ 2x + 3y + 4z - 20 = 0 \\] Answer: The equation of the plane is: \\[ 2x + 3y + 4z - 20 = 0 \\]","title":"Solution:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#equations-of-second-order-surfaces","text":"","title":"Equations of second-order surfaces"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-1-write-the-equation-of-a-sphere-with-center-at-point-p-1-2-3-and-radius-r-3","text":"","title":"Problem 1: Write the equation of a sphere with center at point \\( P = (1, 2, 3) \\) and radius \\( r = 3 \\)."},{"location":"2%20Mathematics/2%20Analytic_geometry/#solution_19","text":"The general equation of a sphere is given by: \\[ (x - h)^2 + (y - k)^2 + (z - l)^2 = r^2 \\] Substitute the center coordinates \\( h = 1, k = 2, l = 3 \\) and the radius \\( r = 3 \\) : \\[ (x - 1)^2 + (y - 2)^2 + (z - 3)^2 = 9 \\] Answer: The equation of the sphere is: \\[ (x - 1)^2 + (y - 2)^2 + (z - 3)^2 = 9 \\]","title":"Solution:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-2-do-the-spheres-with-equations-x2-y2-z2-1-and-x2-y2-z2-2-have-any-common-points","text":"","title":"Problem 2: Do the spheres with equations \\( x^2 + y^2 + z^2 = 1 \\) and \\( x^2 + y^2 + z^2 = 2 \\) have any common points?"},{"location":"2%20Mathematics/2%20Analytic_geometry/#solution_20","text":"The spheres \\( x^2 + y^2 + z^2 = 1 \\) and \\( x^2 + y^2 + z^2 = 2 \\) are concentric, as they both have the same center at \\( (0, 0, 0) \\) but different radii: - The first sphere has radius \\( r_1 = 1 \\) , - The second sphere has radius \\( r_2 = \\sqrt{2} \\) . Since the radii are different, the spheres do not intersect and have no common points . Answer: No, the spheres do not have any common points.","title":"Solution:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-3-what-curve-in-space-is-formed-by-the-intersection-of-the-sphere-x2-y2-z2-1-with-the-sphere-x-12-y2-z2-1-find-the-equation-of-this-curve","text":"","title":"Problem 3: What curve in space is formed by the intersection of the sphere \\( x^2 + y^2 + z^2 = 1 \\) with the sphere \\( (x - 1)^2 + y^2 + z^2 = 1 \\)? Find the equation of this curve."},{"location":"2%20Mathematics/2%20Analytic_geometry/#solution_21","text":"To find the intersection curve: 1. Write both sphere equations: - Sphere 1: \\( x^2 + y^2 + z^2 = 1 \\) , - Sphere 2: \\( (x - 1)^2 + y^2 + z^2 = 1 \\) . Expand Sphere 2: \\[ (x - 1)^2 + y^2 + z^2 = x^2 - 2x + 1 + y^2 + z^2 = 1 \\] Simplify: \\[ x^2 - 2x + 1 + y^2 + z^2 = 1 \\quad \\Rightarrow \\quad x^2 + y^2 + z^2 - 2x = 0 \\] Substitute \\( x^2 + y^2 + z^2 = 1 \\) (from Sphere 1) into Sphere 2: \\[ 1 - 2x = 0 \\quad \\Rightarrow \\quad x = \\frac{1}{2} \\] The intersection curve is a circle in the plane \\( x = \\frac{1}{2} \\) with radius: Substitute \\( x = \\frac{1}{2} \\) into Sphere 1: \\[ \\left(\\frac{1}{2}\\right)^2 + y^2 + z^2 = 1 \\quad \\Rightarrow \\quad \\frac{1}{4} + y^2 + z^2 = 1 \\] Simplify: \\[ y^2 + z^2 = \\frac{3}{4} \\] Answer: The intersection curve is a circle in the plane \\( x = \\frac{1}{2} \\) with the equation: \\[ y^2 + z^2 = \\frac{3}{4} \\]","title":"Solution:"},{"location":"2%20Mathematics/2%20Analytic_geometry/#problem-4-write-the-equation-of-the-tangent-plane-to-the-paraboloid-z-x-12-y2-1-at-point-p1-0-1","text":"","title":"Problem 4: Write the equation of the tangent plane to the paraboloid \\( z = (x - 1)^2 + y^2 + 1 \\) at point \\( P(1, 0, 1) \\)."},{"location":"2%20Mathematics/2%20Analytic_geometry/#solution_22","text":"The equation of the tangent plane to a surface \\( z = f(x, y) \\) at point \\( P(x_0, y_0, z_0) \\) is: \\[ z - z_0 = f_x(x_0, y_0)(x - x_0) + f_y(x_0, y_0)(y - y_0) \\] Where \\( f_x \\) and \\( f_y \\) are partial derivatives of \\( f(x, y) \\) . Given \\( f(x, y) = (x - 1)^2 + y^2 + 1 \\) , calculate partial derivatives: \\( f_x = 2(x - 1) \\) , \\( f_y = 2y \\) . Evaluate at \\( P(1, 0, 1) \\) : \\( f_x(1, 0) = 2(1 - 1) = 0 \\) , \\( f_y(1, 0) = 2(0) = 0 \\) . Write the tangent plane equation: \\[ z - z_0 = 0(x - 1) + 0(y - 0) \\] \\[ z - 1 = 0 \\quad \\Rightarrow \\quad z = 1 \\] Answer: The equation of the tangent plane is: \\[ z = 1 \\]","title":"Solution:"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus Functions Task 1 Functions: \\( f(x) = x^2 \\) \\( g(x) = \\sqrt{x} \\) \\( h(x) = \\frac{1}{x} \\) \\( j(x) = \\sin(x) \\) Calculation: For \\( f(x) = x^2 \\) : \\[ f(2) = 2^2 = 4 \\] For \\( g(x) = \\sqrt{x} \\) : \\[ g(2) = \\sqrt{2} \\approx 1.414 \\] For \\( h(x) = \\frac{1}{x} \\) : \\[ h(2) = \\frac{1}{2} = 0.5 \\] For \\( j(x) = \\sin(x) \\) : Assuming \\( x = 2 \\) is in radians, \\[ j(2) = \\sin(2) \\approx 0.909 \\] Summary: \\( f(2) = 4 \\) \\( g(2) \\approx 1.414 \\) \\( h(2) = 0.5 \\) \\( j(2) \\approx 0.909 \\) Task 2 Step 1: Definitions of the Functions Given: \\( f(x) = 3x - 1 \\) \\( g(x) = \\sqrt{x} \\) Step 2: Compositions of Functions \\( f(g(x)) \\) : Substitute \\( g(x) = \\sqrt{x} \\) into \\( f(x) \\) : \\[ f(g(x)) = f(\\sqrt{x}) = 3\\sqrt{x} - 1 \\] \\( g(f(x)) \\) : Substitute \\( f(x) = 3x - 1 \\) into \\( g(x) \\) : \\[ g(f(x)) = g(3x - 1) = \\sqrt{3x - 1} \\] \\( f(f(x)) \\) : Substitute \\( f(x) = 3x - 1 \\) into \\( f(x) \\) again: \\[ f(f(x)) = f(3x - 1) = 3(3x - 1) - 1 = 9x - 3 - 1 = 9x - 4 \\] \\( g(g(x)) \\) : Substitute \\( g(x) = \\sqrt{x} \\) into \\( g(x) \\) again: \\[ g(g(x)) = g(\\sqrt{x}) = \\sqrt{\\sqrt{x}} = x^{1/4} \\] Step 3: Instructions for Visualizing in GeoGebra To plot the functions \\( f(g(x)) \\) , \\( g(f(x)) \\) , \\( f(f(x)) \\) , and \\( g(g(x)) \\) in GeoGebra: Access the GeoGebra application or the online version at GeoGebra.org . In the Input field, type the functions as follows: \\( f(g(x)) = 3\\sqrt{x} - 1 \\) \\( g(f(x)) = \\sqrt{3x - 1} \\) \\( f(f(x)) = 9x - 4 \\) \\( g(g(x)) = x^{1/4} \\) For \\( f(g(x)) \\) , \\( g(f(x)) \\) , and \\( g(g(x)) \\) , restrict the domain to ensure the square root is defined (e.g., \\( x \\geq 0 \\) for \\( g(x) \\) ). Use the syntax in GeoGebra, such as: For \\( g(f(x)) \\) : If[3x - 1 >= 0, sqrt(3x - 1)] Assign different colors to each function for better visualization. Right-click on a function and select \"Settings\" to change its color and style. Use GeoGebra\u2019s point tool to evaluate the compositions at specific \\( x \\) -values. Observe intersections or relationships between the curves. Task 3 Compositions of Functions Given: \\( f(x) = e^x \\) (exponential function) \\( g(x) = \\ln(x) \\) (natural logarithm function) Composition 1: \\( f(g(x)) \\) Substitute \\( g(x) = \\ln(x) \\) into \\( f(x) \\) : \\[ f(g(x)) = f(\\ln(x)) = e^{\\ln(x)} \\] From the properties of logarithms and exponentials: \\[ e^{\\ln(x)} = x \\quad \\text{(for \\( x > 0 \\))}. \\] Composition 2: \\( g(f(x)) \\) Substitute \\( f(x) = e^x \\) into \\( g(x) \\) : \\[ g(f(x)) = g(e^x) = \\ln(e^x) \\] From the properties of logarithms: \\[ \\ln(e^x) = x. \\] Conclusion For both compositions \\( f(g(x)) \\) and \\( g(f(x)) \\) , the result is \\( x \\) . This demonstrates that the exponential function \\( e^x \\) and the natural logarithm function \\( \\ln(x) \\) are inverse functions of each other. Domain Constraints : \\( g(x) = \\ln(x) \\) requires \\( x > 0 \\) , \\( f(x) = e^x \\) is valid for all real \\( x \\) . Task 4 Problem 1: Inverse Function Given the function \\( f = \\{(1, 7), (2, 9), (3, 11)\\} \\) , we are tasked to find its inverse \\( f^{-1} \\) . To find the inverse function \\( f^{-1} \\) , we simply swap the elements in each ordered pair. Solution: \\[ f = \\{(1, 7), (2, 9), (3, 11)\\} \\] Inverse: \\[ f^{-1} = \\{(7, 1), (9, 2), (11, 3)\\} \\] Problem 2: Composition of Functions The functions \\( f(x) = e^x \\) and \\( g(x) = \\ln(x) \\) are given. We need to evaluate \\( f(g(x)) \\) and \\( g(f(x)) \\) , and determine the relationship. Evaluate \\( f(g(x)) \\) : \\[ f(g(x)) = f(\\ln(x)) = e^{\\ln(x)} \\] From the properties of logarithms and exponentials: \\[ e^{\\ln(x)} = x \\quad \\text{(for \\( x > 0 \\))}. \\] Evaluate \\( g(f(x)) \\) : \\[ g(f(x)) = g(e^x) = \\ln(e^x) \\] From the properties of logarithms: \\[ \\ln(e^x) = x. \\] Conclusion: Both compositions yield: \\[ f(g(x)) = x \\quad \\text{and} \\quad g(f(x)) = x. \\] This shows that \\( f(x) = e^x \\) and \\( g(x) = \\ln(x) \\) are inverse functions of each other. Domain Constraints : \\( g(x) = \\ln(x) \\) requires \\( x > 0 \\) , \\( f(x) = e^x \\) is valid for all real \\( x \\) . Task 5 Solution to the Inverse Function Given Function : \\[ f = \\{(1, 7), (2, 7), (3, 11)\\} \\] Finding the Inverse Function : To compute the inverse \\( f^{-1} \\) , we swap the elements in each ordered pair from the given function \\( f \\) . This means: The \\( x \\) -coordinate becomes the \\( y \\) -coordinate, and vice versa. Inverse Function : \\[ f^{-1} = \\{(7, 1), (7, 2), (11, 3)\\} \\] Note : In the inverse function \\( f^{-1} \\) , \\( 7 \\) maps to both \\( 1 \\) and \\( 2 \\) , which means \\( f^{-1} \\) is not a function in the strict mathematical sense because a function requires each input to correspond to exactly one output. Task 6 To address the given task, we need to derive the inverse function of \\( f(x) = x - 1 \\) and visualize both functions in GeoGebra. Step 1: Find the Inverse Function The given function is \\( f(x) = x - 1 \\) . To find the inverse function \\( f^{-1}(x) \\) , perform the following steps: Replace \\( f(x) \\) with \\( y \\) : \\[ y = x - 1 \\] Swap \\( x \\) and \\( y \\) to find the inverse: \\[ x = y - 1 \\] Solve for \\( y \\) : \\[ y = x + 1 \\] Thus, the inverse function is: \\[ f^{-1}(x) = x + 1 \\] Step 2: Graph Both Functions In GeoGebra, you can graph \\( f(x) = x - 1 \\) and \\( f^{-1}(x) = x + 1 \\) as follows: Access the GeoGebra application or the online tool at GeoGebra.org . In the Input box, type: f(x) = x - 1 f_inverse(x) = x + 1 To show the relationship between \\( f \\) and \\( f^{-1} \\) , graph the identity line \\( y = x \\) . This helps illustrate that the functions are reflections of each other across this line. Use different colors for the graphs of \\( f(x) \\) , \\( f^{-1}(x) \\) , and \\( y = x \\) to make them visually distinct. Final Notes Both functions \\( f(x) = x - 1 \\) and \\( f^{-1}(x) = x + 1 \\) are linear. Their graphs will intersect the identity line \\( y = x \\) , demonstrating their inverse relationship.","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#functions","text":"","title":"Functions"},{"location":"2%20Mathematics/3%20Calculus/#task-1","text":"Functions: \\( f(x) = x^2 \\) \\( g(x) = \\sqrt{x} \\) \\( h(x) = \\frac{1}{x} \\) \\( j(x) = \\sin(x) \\) Calculation: For \\( f(x) = x^2 \\) : \\[ f(2) = 2^2 = 4 \\] For \\( g(x) = \\sqrt{x} \\) : \\[ g(2) = \\sqrt{2} \\approx 1.414 \\] For \\( h(x) = \\frac{1}{x} \\) : \\[ h(2) = \\frac{1}{2} = 0.5 \\] For \\( j(x) = \\sin(x) \\) : Assuming \\( x = 2 \\) is in radians, \\[ j(2) = \\sin(2) \\approx 0.909 \\] Summary: \\( f(2) = 4 \\) \\( g(2) \\approx 1.414 \\) \\( h(2) = 0.5 \\) \\( j(2) \\approx 0.909 \\)","title":"Task 1"},{"location":"2%20Mathematics/3%20Calculus/#task-2","text":"Step 1: Definitions of the Functions Given: \\( f(x) = 3x - 1 \\) \\( g(x) = \\sqrt{x} \\) Step 2: Compositions of Functions \\( f(g(x)) \\) : Substitute \\( g(x) = \\sqrt{x} \\) into \\( f(x) \\) : \\[ f(g(x)) = f(\\sqrt{x}) = 3\\sqrt{x} - 1 \\] \\( g(f(x)) \\) : Substitute \\( f(x) = 3x - 1 \\) into \\( g(x) \\) : \\[ g(f(x)) = g(3x - 1) = \\sqrt{3x - 1} \\] \\( f(f(x)) \\) : Substitute \\( f(x) = 3x - 1 \\) into \\( f(x) \\) again: \\[ f(f(x)) = f(3x - 1) = 3(3x - 1) - 1 = 9x - 3 - 1 = 9x - 4 \\] \\( g(g(x)) \\) : Substitute \\( g(x) = \\sqrt{x} \\) into \\( g(x) \\) again: \\[ g(g(x)) = g(\\sqrt{x}) = \\sqrt{\\sqrt{x}} = x^{1/4} \\] Step 3: Instructions for Visualizing in GeoGebra To plot the functions \\( f(g(x)) \\) , \\( g(f(x)) \\) , \\( f(f(x)) \\) , and \\( g(g(x)) \\) in GeoGebra: Access the GeoGebra application or the online version at GeoGebra.org . In the Input field, type the functions as follows: \\( f(g(x)) = 3\\sqrt{x} - 1 \\) \\( g(f(x)) = \\sqrt{3x - 1} \\) \\( f(f(x)) = 9x - 4 \\) \\( g(g(x)) = x^{1/4} \\) For \\( f(g(x)) \\) , \\( g(f(x)) \\) , and \\( g(g(x)) \\) , restrict the domain to ensure the square root is defined (e.g., \\( x \\geq 0 \\) for \\( g(x) \\) ). Use the syntax in GeoGebra, such as: For \\( g(f(x)) \\) : If[3x - 1 >= 0, sqrt(3x - 1)] Assign different colors to each function for better visualization. Right-click on a function and select \"Settings\" to change its color and style. Use GeoGebra\u2019s point tool to evaluate the compositions at specific \\( x \\) -values. Observe intersections or relationships between the curves.","title":"Task 2"},{"location":"2%20Mathematics/3%20Calculus/#task-3","text":"Compositions of Functions Given: \\( f(x) = e^x \\) (exponential function) \\( g(x) = \\ln(x) \\) (natural logarithm function) Composition 1: \\( f(g(x)) \\) Substitute \\( g(x) = \\ln(x) \\) into \\( f(x) \\) : \\[ f(g(x)) = f(\\ln(x)) = e^{\\ln(x)} \\] From the properties of logarithms and exponentials: \\[ e^{\\ln(x)} = x \\quad \\text{(for \\( x > 0 \\))}. \\] Composition 2: \\( g(f(x)) \\) Substitute \\( f(x) = e^x \\) into \\( g(x) \\) : \\[ g(f(x)) = g(e^x) = \\ln(e^x) \\] From the properties of logarithms: \\[ \\ln(e^x) = x. \\] Conclusion For both compositions \\( f(g(x)) \\) and \\( g(f(x)) \\) , the result is \\( x \\) . This demonstrates that the exponential function \\( e^x \\) and the natural logarithm function \\( \\ln(x) \\) are inverse functions of each other. Domain Constraints : \\( g(x) = \\ln(x) \\) requires \\( x > 0 \\) , \\( f(x) = e^x \\) is valid for all real \\( x \\) .","title":"Task 3"},{"location":"2%20Mathematics/3%20Calculus/#task-4","text":"Problem 1: Inverse Function Given the function \\( f = \\{(1, 7), (2, 9), (3, 11)\\} \\) , we are tasked to find its inverse \\( f^{-1} \\) . To find the inverse function \\( f^{-1} \\) , we simply swap the elements in each ordered pair. Solution: \\[ f = \\{(1, 7), (2, 9), (3, 11)\\} \\] Inverse: \\[ f^{-1} = \\{(7, 1), (9, 2), (11, 3)\\} \\] Problem 2: Composition of Functions The functions \\( f(x) = e^x \\) and \\( g(x) = \\ln(x) \\) are given. We need to evaluate \\( f(g(x)) \\) and \\( g(f(x)) \\) , and determine the relationship. Evaluate \\( f(g(x)) \\) : \\[ f(g(x)) = f(\\ln(x)) = e^{\\ln(x)} \\] From the properties of logarithms and exponentials: \\[ e^{\\ln(x)} = x \\quad \\text{(for \\( x > 0 \\))}. \\]","title":"Task 4"},{"location":"2%20Mathematics/3%20Calculus/#evaluate-gfx","text":"\\[ g(f(x)) = g(e^x) = \\ln(e^x) \\] From the properties of logarithms: \\[ \\ln(e^x) = x. \\] Conclusion: Both compositions yield: \\[ f(g(x)) = x \\quad \\text{and} \\quad g(f(x)) = x. \\] This shows that \\( f(x) = e^x \\) and \\( g(x) = \\ln(x) \\) are inverse functions of each other. Domain Constraints : \\( g(x) = \\ln(x) \\) requires \\( x > 0 \\) , \\( f(x) = e^x \\) is valid for all real \\( x \\) .","title":"Evaluate \\( g(f(x)) \\):"},{"location":"2%20Mathematics/3%20Calculus/#task-5","text":"Solution to the Inverse Function Given Function : \\[ f = \\{(1, 7), (2, 7), (3, 11)\\} \\] Finding the Inverse Function : To compute the inverse \\( f^{-1} \\) , we swap the elements in each ordered pair from the given function \\( f \\) . This means: The \\( x \\) -coordinate becomes the \\( y \\) -coordinate, and vice versa. Inverse Function : \\[ f^{-1} = \\{(7, 1), (7, 2), (11, 3)\\} \\] Note : In the inverse function \\( f^{-1} \\) , \\( 7 \\) maps to both \\( 1 \\) and \\( 2 \\) , which means \\( f^{-1} \\) is not a function in the strict mathematical sense because a function requires each input to correspond to exactly one output.","title":"Task 5"},{"location":"2%20Mathematics/3%20Calculus/#task-6","text":"To address the given task, we need to derive the inverse function of \\( f(x) = x - 1 \\) and visualize both functions in GeoGebra. Step 1: Find the Inverse Function The given function is \\( f(x) = x - 1 \\) . To find the inverse function \\( f^{-1}(x) \\) , perform the following steps: Replace \\( f(x) \\) with \\( y \\) : \\[ y = x - 1 \\] Swap \\( x \\) and \\( y \\) to find the inverse: \\[ x = y - 1 \\] Solve for \\( y \\) : \\[ y = x + 1 \\] Thus, the inverse function is: \\[ f^{-1}(x) = x + 1 \\] Step 2: Graph Both Functions In GeoGebra, you can graph \\( f(x) = x - 1 \\) and \\( f^{-1}(x) = x + 1 \\) as follows: Access the GeoGebra application or the online tool at GeoGebra.org . In the Input box, type: f(x) = x - 1 f_inverse(x) = x + 1 To show the relationship between \\( f \\) and \\( f^{-1} \\) , graph the identity line \\( y = x \\) . This helps illustrate that the functions are reflections of each other across this line. Use different colors for the graphs of \\( f(x) \\) , \\( f^{-1}(x) \\) , and \\( y = x \\) to make them visually distinct.","title":"Task 6"},{"location":"2%20Mathematics/3%20Calculus/#final-notes","text":"Both functions \\( f(x) = x - 1 \\) and \\( f^{-1}(x) = x + 1 \\) are linear. Their graphs will intersect the identity line \\( y = x \\) , demonstrating their inverse relationship.","title":"Final Notes"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}