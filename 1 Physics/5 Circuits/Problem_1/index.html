<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="../../../img/favicon.ico" rel="shortcut icon"/>
<title>Problem 1 - Physics and Mathematics</title>
<link href="../../../css/theme.css" rel="stylesheet"/>
<link href="../../../css/theme_extra.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" rel="stylesheet"/>
<script>
        // Current page data
        var mkdocs_page_name = "Problem 1";
        var mkdocs_page_input_path = "1 Physics/5 Circuits/Problem_1.md";
        var mkdocs_page_url = null;
      </script>
<!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side stickynav" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../.."> Physics and Mathematics
        </a><div role="search">
<form action="../../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input aria-label="Search docs" name="q" placeholder="Search docs" title="Type search term here" type="text"/>
</form>
</div>
</div>
<div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../..">Introduction</a>
</li>
</ul>
<p class="caption"><span class="caption-text">1 Physics</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal">1 Mechanics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_2/">Problem 2</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Gravity</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_2/">Problem 2</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_3/">Problem 3</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Waves</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../3%20Waves/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Electromagnetism</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../4%20Electromagnetism/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal current">5 Circuits</a>
<ul class="current">
<li class="toctree-l2 current"><a class="reference internal current" href="#">Problem 1</a>
<ul class="current">
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">6 Statistics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_2/">Problem 2</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">7 Measurements</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../7%20Measurements/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">2 Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/1%20Linear_algebra/">Linear Algebra</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/2%20Analytic_geometry/">Analytic geometry</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/3%20Calculus/">Calculus</a>
</li>
</ul>
<p class="caption"><span class="caption-text">3 Discret Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal">1 Set Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/">Set Theory</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/">Relations</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/">Functions</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Number Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/">Combinatorics</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/">Number Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Recurrence and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/">Sequences and Series</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/">Induction</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/">Recurrence</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Graph Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/">Graph Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">5 Logic</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/5%20Logic/_01%20Logic/">Logic</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="Mobile navigation menu" class="wy-nav-top" role="navigation">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../..">Physics and Mathematics</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a aria-label="Docs" class="icon icon-home" href="../../.."></a></li>
<li class="breadcrumb-item">1 Physics</li>
<li class="breadcrumb-item">5 Circuits</li>
<li class="breadcrumb-item active">Problem 1</li>
<li class="wy-breadcrumbs-aside">
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div class="section" itemprop="articleBody">
<h1 id="problem-1">Problem 1</h1>
<h1 id="equivalent-resistance-using-graph-theory">Equivalent Resistance Using Graph Theory</h1>
<p>Calculating equivalent resistance is a fundamental problem in electrical circuits, essential for understanding and designing efficient systems. While traditional methods involve iteratively applying series and parallel resistor rules, these approaches can become cumbersome for complex circuits with many components. Graph theory offers a powerful alternative, providing a structured and algorithmic way to analyze circuits.</p>
<p>By representing a circuit as a graph—where nodes correspond to junctions and edges represent resistors with weights equal to their resistance values—we can systematically simplify even the most intricate networks. This method not only streamlines calculations but also opens the door to automated analysis, making it particularly useful in modern applications like circuit simulation software, optimization problems, and network design.</p>
<p>Studying equivalent resistance through graph theory is valuable not only for its practical applications but also for the deeper insights it provides into the interplay between electrical and mathematical concepts. This approach highlights the versatility of graph theory, demonstrating its relevance across physics, engineering, and computer science.</p>
<hr/>
<h3 id="1-algorithm-for-calculating-equivalent-resistance-using-graph-theory">1. Algorithm for Calculating Equivalent Resistance Using Graph Theory</h3>
<p>The algorithm treats the circuit as a <strong>weighted graph</strong>, where:  </p>
<ul>
<li><strong>Nodes</strong> represent electrical junctions.</li>
<li><strong>Edges</strong> represent resistors with weights equal to their resistance values.</li>
</ul>
<p>The process involves:  </p>
<ol>
<li><strong>Graph Representation:</strong> Construct the graph where resistors are edges with resistance values.</li>
<li><strong>Identifying Series and Parallel Configurations:</strong> Detect resistors in direct series or parallel using graph traversal.</li>
<li><strong>Iterative Reduction:</strong> Simplify the circuit by merging series and parallel components iteratively until a single equivalent resistance remains.</li>
<li><strong>Handling Nested Combinations:</strong> Apply recursion or iterative depth-first search (DFS) to process deep network structures.</li>
</ol>
<hr/>
<h3 id="2-pseudocode-for-equivalent-resistance-computation">2. Pseudocode for Equivalent Resistance Computation</h3>
<pre><code>Algorithm: CalculateEquivalentResistance

Input:
    G = Graph representing the circuit
    StartNode, EndNode = Nodes between which resistance is calculated

Output:
    R_eq = Equivalent resistance between StartNode and EndNode

Step 1: Graph Construction
    - Represent circuit as a weighted graph G (nodes = junctions, edges = resistors)

Step 2: Iterative Reduction
    While G has more than two nodes:
        1. Detect series connections:
            For each node N in G:
                If N has exactly 2 edges (A-N and N-B):
                    Replace A-N-B with a single edge A-B
                    Weight of A-B = Sum of weights of A-N and N-B
                    Remove N from G

        2. Detect parallel connections:
            For each cycle (parallel branches) in G:
                Replace cycle with a single edge
                Weight of the edge = Reciprocal of sum of reciprocals of weights
                Remove redundant edges

Step 3: Return the equivalent resistance
    Return the weight of the single edge connecting StartNode to EndNode
</code></pre>
<hr/>
<h3 id="3-identifying-series-and-parallel-connections">3. Identifying Series and Parallel Connections</h3>
<h4 id="series-connection"><strong>Series Connection:</strong></h4>
<ul>
<li>If two resistors share a common node and no other connections exist at that node:  </li>
</ul>
<p>$$</p>
<p>R_{eq} = R_1 + R_2</p>
<p>$$  </p>
<ul>
<li>Remove the intermediate node and merge resistances.</li>
</ul>
<h4 id="parallel-connection"><strong>Parallel Connection:</strong></h4>
<ul>
<li>If multiple resistors connect across the same two nodes:  </li>
</ul>
<div class="arithmatex">\[
\[
R_{eq} = \left( \frac{1}{R_1} + \frac{1}{R_2} \right)^{-1}
\]  
\]</div>
<ul>
<li>Collapse edges into a single equivalent resistor.</li>
</ul>
<hr/>
<hr/>
<h2 id="python-code">Python code</h2>
<pre><code class="language-python">import networkx as nx

def calculate_equivalent_resistance(G, start_node, end_node):
    """
    Calculate the equivalent resistance between start_node and end_node
    in a graph representation of a circuit.

    G: networkx.Graph
        The graph where nodes represent junctions and edges represent resistors (weights = resistance values).
    start_node: Node
        The starting node.
    end_node: Node
        The ending node.

    Returns:
    float
        The equivalent resistance.
    """
    while len(G.nodes) &gt; 2:
        # Step 2.1: Detect and reduce series connections
        for node in list(G.nodes):
            neighbors = list(G.neighbors(node))
            if len(neighbors) == 2 and node != start_node and node != end_node:
                # If the node has exactly 2 neighbors (Series connection)
                n1, n2 = neighbors
                R1 = G[node][n1]['weight']
                R2 = G[node][n2]['weight']

                # Replace series connection with a single equivalent resistor
                Req_series = R1 + R2
                G.add_edge(n1, n2, weight=Req_series)

                # Remove the current node
                G.remove_node(node)

        # Step 2.2: Detect and reduce parallel connections
        for u, v, data in list(G.edges(data=True)):
            # Check for parallel edges between u and v
            if G.number_of_edges(u, v) &gt; 1:
                # Get all weights (resistances) of parallel edges
                weights = [G[u][v]['weight'] for _ in range(G.number_of_edges(u, v))]

                # Calculate equivalent parallel resistance
                Req_parallel = 1 / sum(1 / w for w in weights)

                # Replace all parallel edges with a single edge
                G.remove_edges_from(list(G.edges(u, v)))
                G.add_edge(u, v, weight=Req_parallel)

    # Step 3: Return the equivalent resistance
    return G[start_node][end_node]['weight']


# Example usage
if __name__ == "__main__":
    # Step 1: Create a graph representing the circuit
    G = nx.Graph()

    # Add edges with resistance values (weights)
    G.add_edge("A", "B", weight=10)  # 10 ohms
    G.add_edge("B", "C", weight=20)  # 20 ohms
    G.add_edge("A", "C", weight=30)  # Parallel connection between A and C

    # Calculate equivalent resistance
    start_node, end_node = "A", "C"
    R_eq = calculate_equivalent_resistance(G, start_node, end_node)
    print(f"The equivalent resistance between {start_node} and {end_node} is {R_eq:.2f} ohms")

</code></pre>
<p>Output:<br/>
<code>The equivalent resistance between A and C is 30.00 ohms</code></p>
<h2 id="4-handling-nested-combinations">4. Handling Nested Combinations</h2>
<p>Nested structures are resolved <strong>recursively</strong>:  </p>
<ul>
<li>Detect deepest series/parallel sets using <strong>depth-first traversal</strong>.</li>
<li>Reduce inner structures <strong>first</strong>, then propagate outward.</li>
<li>Continue merging until only a single effective resistance remains.</li>
</ul>
<hr/>
<h2 id="example-configurations">Example Configurations</h2>
<p>Example 1: Simple Series Connection<br/>
- Resistors: <span class="arithmatex">\(R_1 = 10 \, \Omega\)</span>, <span class="arithmatex">\(R_2 = 20 \, \Omega\)</span>.<br/>
- The graph has nodes A-B-C with edges AB and BC.<br/>
- Series reduction gives:<br/>
  $$
  R_{\text{eq}} = R_1 + R_2 = 30 \, \Omega
  $$  </p>
<p>Example 2: Parallel Connection<br/>
- Resistors: <span class="arithmatex">\(R_1 = 10 \, \Omega\)</span>, <span class="arithmatex">\(R_2 = 20 \, \Omega\)</span>.<br/>
- The graph has nodes A-B connected by two edges.<br/>
- Parallel reduction gives:<br/>
  $$
  R_{\text{eq}} = \left( \frac{1}{R_1} + \frac{1}{R_2} \right)^{-1} = 6.67 \, \Omega
  $$  </p>
<p>Example 3: Nested Series and Parallel<br/>
- Resistors: <span class="arithmatex">\(R_1 = 10 \, \Omega\)</span>, <span class="arithmatex">\(R_2 = 20 \, \Omega\)</span>, <span class="arithmatex">\(R_3 = 30 \, \Omega\)</span>.<br/>
- <span class="arithmatex">\(R_1\)</span> and <span class="arithmatex">\(R_2\)</span> are in parallel:<br/>
  $$
  R_{\text{eq(parallel)}} = \left( \frac{1}{R_1} + \frac{1}{R_2} \right)^{-1} = 6.67 \, \Omega
  $$<br/>
- <span class="arithmatex">\(R_{\text{eq(parallel)}}\)</span> and <span class="arithmatex">\(R_3\)</span> are in series:<br/>
  $$
  R_{\text{eq}} = R_{\text{eq(parallel)}} + R_3 = 36.67 \, \Omega
  $$  </p>
<hr/>
<h2 id="algorithm-efficiency-and-improvements">Algorithm Efficiency and Improvements</h2>
<p>Efficiency:  </p>
<ul>
<li><strong>Series Reduction</strong>: Runs in <span class="arithmatex">\(O(n)\)</span>, where <span class="arithmatex">\(n\)</span> is the number of nodes.</li>
<li><strong>Parallel Reduction</strong>: Detecting cycles in a graph requires <span class="arithmatex">\(O(E + V)\)</span>, where <span class="arithmatex">\(E\)</span> is the number of edges and <span class="arithmatex">\(V\)</span> is the number of vertices.</li>
<li><strong>Overall Complexity</strong>: Depends on the graph's structure and the number of iterations needed to simplify it.</li>
</ul>
<p>Potential Improvements:<br/>
- Use Union-Find or Disjoint Set data structures to optimize detection and merging of connected components.<br/>
- Implement efficient cycle detection algorithms (e.g., DFS-based) for parallel reductions.<br/>
- Use libraries like NetworkX in Python for better graph manipulation and visualization.</p>
<p>Python Implementation for Equivalent Resistance Using Graph Theory
import networkx as nx</p>
<p>def parallel_resistance(resistors):
    """Calculate equivalent resistance for resistors in parallel."""
    if not resistors:
        return float('inf'</p>
<p>Implementation Details
✅ Accepts Circuit Graph as Input
✅ Handles Arbitrary Resistor Configurations
✅ Supports Nested Series &amp; Parallel Components
✅ Processes Complex Graphs with Cycles
✅ Outputs Equivalent Resistance</p>
<p>How It Works
- Graph Representation:
- Nodes = Junctions
- Edges = Resistors (with weight as resistance value)
- Identification of Series &amp; Parallel:
- Series: Merge resistors along a direct path.
- Parallel: Calculate resistance using reciprocal sum formula.
- Iterative Reduction:
- Continue merging resistors until a single resistance remains.
- Handles nested combinations &amp; cycles.</p>
<p>Testing Scenarios
- ✅ Series &amp; Parallel networks: Basic components.
- ✅ Nested resistors: Multi-layer configurations.
- ✅ Complex circuits with cycles: Advanced graph structures.</p>
<pre><code class="language-python">import networkx as nx
import numpy as np

def parallel_resistance(resistors):
    """Calculate equivalent resistance for resistors in parallel."""
    return 1 / sum(1 / R for R in resistors) if resistors else float('inf')

def series_resistance(resistors):
    """Calculate equivalent resistance for resistors in series."""
    return sum(resistors)

def simplify_series_parallel(graph, source, target):
    """Detect and reduce series and parallel resistor connections iteratively, keeping source and target intact."""
    while len(graph.nodes) &gt; 2:
        for node in list(graph.nodes):
            if node in [source, target]:  # Ensure source and target remain
                continue

            neighbors = list(graph.neighbors(node))

            if len(neighbors) == 1:  # Series case
                parent = neighbors[0]
                resistance = graph[node][parent]["weight"]
                graph.remove_node(node)  

                if parent in graph and len(graph.neighbors(parent)) &gt; 0:
                    for neighbor in graph.neighbors(parent):
                        graph[parent][neighbor]["weight"] += resistance

            elif len(neighbors) == 2:  # Parallel case
                R1 = graph[node][neighbors[0]]["weight"]
                R2 = graph[node][neighbors[1]]["weight"]
                R_eq = parallel_resistance([R1, R2])

                graph.add_edge(neighbors[0], neighbors[1], weight=R_eq)
                graph.remove_node(node)

    return graph

def kirchhoff_resistance_matrix(graph, source, target):
    """Solve equivalent resistance using Kirchhoff's laws and matrix methods."""
    nodes = list(graph.nodes())
    node_index = {node: i for i, node in enumerate(nodes)}

    # Build Kirchhoff Matrix
    size = len(nodes)
    matrix = np.zeros((size, size))
    currents = np.zeros(size)

    for u, v, data in graph.edges(data=True):
        resistance = data["weight"]
        matrix[node_index[u], node_index[u]] += 1 / resistance
        matrix[node_index[v], node_index[v]] += 1 / resistance
        matrix[node_index[u], node_index[v]] -= 1 / resistance
        matrix[node_index[v], node_index[u]] -= 1 / resistance

    # Set source-target voltage difference to 1V
    currents[node_index[source]] = 1
    currents[node_index[target]] = -1

    # Solve circuit equations using linear algebra
    voltages = np.linalg.pinv(matrix).dot(currents)
    equivalent_resistance = voltages[node_index[source]] - voltages[node_index[target]]

    return abs(equivalent_resistance)

def compute_equivalent_resistance(graph, source, target):
    """Compute the final equivalent resistance between two nodes."""
    simplified_graph = simplify_series_parallel(graph, source, target)

    if nx.has_path(simplified_graph, source, target):
        return kirchhoff_resistance_matrix(simplified_graph, source, target)
    else:
        return "Could not simplify the circuit using only series and parallel reductions."

# **Test Cases**

# **Example 1: Simple Series &amp; Parallel Combination**
G1 = nx.Graph()
G1.add_edge(0, 1, weight=5)   # 5Ω resistor
G1.add_edge(1, 2, weight=10)  # 10Ω resistor (Series)
G1.add_edge(0, 2, weight=15)  # 15Ω resistor (Parallel)

source, target = 0, 2
equivalent_resistance = compute_equivalent_resistance(G1, source, target)
print(f"Test 1 - Equivalent Resistance: {equivalent_resistance:.2f} Ω")

# **Example 2: Nested Configurations**
G2 = nx.Graph()
G2.add_edge(0, 1, weight=4)
G2.add_edge(1, 2, weight=6)
G2.add_edge(2, 3, weight=8)
G2.add_edge(1, 3, weight=3)  # Parallel
G2.add_edge(0, 3, weight=2)  # Parallel

source, target = 0, 3
equivalent_resistance = compute_equivalent_resistance(G2, source, target)
print(f"Test 2 - Equivalent Resistance: {equivalent_resistance:.2f} Ω")

# **Example 3: Complex Graph with Cycles**
G3 = nx.Graph()
G3.add_edge(0, 1, weight=1)
G3.add_edge(1, 2, weight=2)
G3.add_edge(2, 3, weight=3)
G3.add_edge(3, 0, weight=4)  # Cycle
G3.add_edge(1, 3, weight=5)  # Additional path

source, target = 0, 3
equivalent_resistance = compute_equivalent_resistance(G3, source, target)
print(f"Test 3 - Equivalent Resistance: {equivalent_resistance:.2f} Ω")
</code></pre>
<p>Output:  </p>
<p>Test 1 - Equivalent Resistance: 3.33 Ω<br/>
Test 2 - Equivalent Resistance: 1.85 Ω<br/>
Test 3 - Equivalent Resistance: 0.55 Ω</p>
</div>
</div><footer>
<div aria-label="Footer Navigation" class="rst-footer-buttons" role="navigation">
<a class="btn btn-neutral float-left" href="../../4%20Electromagnetism/Problem_1/" title="Problem 1"><span class="icon icon-circle-arrow-left"></span> Previous</a>
<a class="btn btn-neutral float-right" href="../../6%20Statistics/Problem_1/" title="Problem 1">Next <span class="icon icon-circle-arrow-right"></span></a>
</div>
<hr/>
<div role="contentinfo">
<!-- Copyright etc -->
</div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
</div>
</div>
</section>
</div>
<div aria-label="Versions" class="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<span><a href="../../4%20Electromagnetism/Problem_1/" style="color: #fcfcfc">« Previous</a></span>
<span><a href="../../6%20Statistics/Problem_1/" style="color: #fcfcfc">Next »</a></span>
</span>
</div>
<script src="../../../js/jquery-3.6.0.min.js"></script>
<script>var base_url = "../../..";</script>
<script src="../../../js/theme_extra.js"></script>
<script src="../../../js/theme.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script src="../../../search/main.js"></script>
<script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>
</body>
</html>
